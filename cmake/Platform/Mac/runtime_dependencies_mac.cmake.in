#
# Copyright (c) Contributors to the Open 3D Engine Project.
# For complete copyright and license terms please see the LICENSE at the root of this distribution.
#
# SPDX-License-Identifier: Apache-2.0 OR MIT
#
#
cmake_minimum_required(VERSION 3.22)

function(gp_resolve_item_override context item exepath dirs resolved_item_var resolved_var)
    # Qt frameworks could resolve the binary to eg qt/lib/QtCore.framework/Headers/QtCore instead of qt/lib/QtCore.framework/Versions/5/QtCore
    # This is because GetPrerequisites.cmake gp_resolve_item function searches for the first file that matches the "frameworks name"
    if(${${resolved_var}} AND ${item} MATCHES "/(Qt[^\\.]+\\.framework)/(.*)")
        set(qt_framework ${CMAKE_MATCH_1})
        set(qt_framework_subpath ${CMAKE_MATCH_2})
        string(REGEX REPLACE "(.*)/(Qt[^\\.]+\\.framework)/(.*)" "\\1/\\2/${qt_framework_subpath}" new_resolved_item "${${resolved_item_var}}")
        set(${resolved_item_var} ${new_resolved_item} PARENT_SCOPE)
    endif()
endfunction()

include(BundleUtilities)

cmake_policy(SET CMP0012 NEW) # new policy for the if that evaluates a boolean out of the LY_BUILD_FIXUP_BUNDLE expansion
cmake_policy(SET CMP0009 NEW) # do not traverse symlinks on GLOB_RECURSE


# Values configured for the output locations of the target
# Gathered from the generator expression for TARGET_FILE_DIR, TARGET_BUNDLE_DIR
# and TARGET_BUNDLE_CONTENT_DIR
cmake_path(SET target_file_dir "@target_file_dir@")
cmake_path(SET target_bundle_dir "@target_bundle_dir@")
# The parent of the bundle directory contains the bundle.app file
# It should be the same as the TARGET_FILE_DIR for a non-bundle
cmake_path(GET target_bundle_dir PARENT_PATH target_bundle_parent_dir)
cmake_path(SET target_bundle_content_dir "@target_bundle_content_dir@")

set(target_copy_files $<FILTER:$<REMOVE_DUPLICATES:"@target_copy_files@">,EXCLUDE,"^$">)
set(target_target_files $<FILTER:$<REMOVE_DUPLICATES:"@target_target_files@">,EXCLUDE,"^$">)
set(target_link_files $<FILTER:$<REMOVE_DUPLICATES:"@target_link_files@">,EXCLUDE,"^$">)
set(target_imported_files $<FILTER:$<REMOVE_DUPLICATES:"@target_imported_files@">,EXCLUDE,"^$">)

find_program(LY_INSTALL_NAME_TOOL install_name_tool)
if (NOT LY_INSTALL_NAME_TOOL)
    message(FATAL_ERROR "Unable to locate 'install_name_tool'")
endif()

# IS_NEWER_THAN returns true if:
# 1. file1 is newer than file2
# 2. Either file1 or file2 do not exist
# 3. If both files have the same timestamp
# We would like it to return false if the mod times are the same.
function(ly_is_newer_than file1 file2 is_newer)

    set(${is_newer} FALSE PARENT_SCOPE)

    if("${file1}" IS_NEWER_THAN "${file2}")
        file(TIMESTAMP "${file1}" file1_mod_time)
        file(TIMESTAMP "${file2}" file2_mod_time)
        # note that the above modtimes will come thru in string format
        # like "2022-06-09T14:21:30" - not as numbers, so use STREQUAL
        if (NOT "${file1_mod_time}" STREQUAL "${file2_mod_time}")
            set(${is_newer} TRUE PARENT_SCOPE)
        endif()
    endif()

endfunction()

function(o3de_copy_file_to_bundle)
    set(options)
    set(oneValueArgs SOURCE_FILE SOURCE_TYPE SOURCE_GEM_MODULE RELATIVE_TARGET_DIRECTORY)
    set(multiValueArgs)
    cmake_parse_arguments("${CMAKE_CURRENT_FUNCTION}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    set(source_file "${${CMAKE_CURRENT_FUNCTION}_SOURCE_FILE}")
    set(source_type "${${CMAKE_CURRENT_FUNCTION}_SOURCE_TYPE}")
    set(source_is_gem "${${CMAKE_CURRENT_FUNCTION}_SOURCE_GEM_MODULE}")
    set(relative_target_directory "${${CMAKE_CURRENT_FUNCTION}_RELATIVE_TARGET_DIRECTORY}")

    # Use the final component of the source file has the target_filename
    cmake_path(GET source_file FILENAME target_filename)

    # Set the Frameworks directory using the <bundle-content-dir> as the root
    unset(target_bundle_framework_dir)
    cmake_path(APPEND target_bundle_framework_dir "${target_bundle_content_dir}" "Frameworks")
    cmake_path(APPEND target_bundle_plugins_dir "${target_bundle_content_dir}" "PlugIns")

    if("${source_file}" MATCHES "qt/translations")
        # Do not copy QT translation files to bundle
        return()
    endif()

    string(REGEX MATCH "\\.dylib$" is_dylib "${source_file}")
    string(REGEX MATCH "^(.*\\.[Ff]ramework)(/.*|$)" is_framework "${source_file}")
    # If the source file is in a framework, get it's framework directory
    if(is_framework)
        set(source_framework_directory ${CMAKE_MATCH_1})
    endif()

    ## Get the full target path based on the dependency type
    # Link time dylib dependencies should go into the Contents/Frameworks folder according to the
    # Apple Placing Content in a Bundle page
    # https://developer.apple.com/documentation/bundleresources/placing_content_in_a_bundle#3875930
    if("${source_file}" MATCHES "qt/plugins")
        unset(target_file)
        # set the target file QT plugins to be inside <bundle-content-dir>/PlugIns directory
        cmake_path(APPEND target_file "${target_bundle_plugins_dir}" "${relative_target_directory}" "${target_filename}")
    elseif(is_framework)
        cmake_path(GET source_framework_directory FILENAME source_framework_filename)
        unset(target_file)
        cmake_path(APPEND target_file "${target_bundle_framework_dir}" "${source_framework_filename}")
        # Python.framework produces a bug in BundleUtilities so it needs manual handling
        # https://gitlab.kitware.com/cmake/cmake/-/issues/20165
        # if the source file being copied is from the Python framework
        # copy the entire Python.framework folder to the <bundle-app/Conents/Frameworks directory
        cmake_path(COMPARE "${source_framework_filename}" EQUAL "Python.framework" is_python_framework)
        if(is_python_framework)
            set_property(SOURCE "${CMAKE_CURRENT_LIST_FILE}" APPEND PROPERTY DEPENDS_ON_PYTHON TRUE)
        endif()
    elseif("${source_file}" IN_LIST target_copy_files OR "${source_file}" IN_LIST target_imported_files)
        unset(target_file)
        # copy the file dependencies to the directory relative to the <bundle-app>/Content/MacOS directory
        # imported dependencies refer to the IMPORTED_LOCATION property of the TARGET, so those
        # should also be copied to the <bundle-dir>/Content/MacOS if they are not a dylib
        if(is_dylib)
            cmake_path(APPEND target_file "${target_bundle_framework_dir}" "${relative_target_directory}" "${target_filename}")
        else()
            cmake_path(APPEND target_file "${target_file_dir}" "${relative_target_directory}" "${target_filename}")
        endif()
    elseif("${source_file}" IN_LIST target_link_files)
        unset(target_file)
        # copy the link dependencies to the <bundle-app>/Content/Frameworks directory
        cmake_path(APPEND target_file "${target_bundle_framework_dir}" "${relative_target_directory}" "${target_filename}")
    elseif("${source_file}" IN_LIST target_target_files)
        unset(target_file)
        # copy the target dependencies to the directory containing the bundle
        cmake_path(APPEND target_file "${target_bundle_parent_dir}" "${relative_target_directory}" "${target_filename}")
    endif()

    # Set the target directory to be the parent of the target_file
    cmake_path(GET target_file PARENT_PATH target_directory)

    ## Fixup source file to copy
    if("${source_file}" MATCHES "\\.[Ff]ramework[^\\.]")
        # fixup origin to copy the whole Framework folder and change destination to Contents/Frameworks
        string(REGEX REPLACE "(.*\\.[Ff]ramework)(/.*|$)" "\\1" source_file "${source_file}")
        cmake_path(GET source_file PARENT_PATH source_file_folder)
    endif()

    # dylibs and frameworks ared passed to fixup bundle
    if(is_dylib OR is_framework )
        # Invoke fixup bundle on copy dependencies, link dependencies and imported dependencies
        # Fixup bundle should not be invoked to target dependencies.
        # target dependencies can be dynamically loaded libraries via `dlopen`
        # or dependencies that need to build before the current target and are used
        # in some way that is only in the runtime
        # This is needed for Gem Modules dylibs as they can depend on the
        # the libO3DEKernel.dylib and libAzQtComponents.dylib via
        # static linking
        # Also skip adding symlinks to the list of libraries to fix up
        if(NOT IS_SYMLINK "${source_file}" AND NOT "${source_file}" IN_LIST target_target_files)
            # Append to the SOURCE file property target file path if the target_file is a dylib
            # otherwise the target_file is within a Mac framework so append to the bundle directory property
            if(is_dylib)
                set_property(SOURCE "${CMAKE_CURRENT_LIST_FILE}" APPEND PROPERTY BUNDLE_LIBS "${target_file}")
            else()
                set_property(SOURCE "${CMAKE_CURRENT_LIST_FILE}" APPEND PROPERTY BUNDLE_DIRS "${target_directory}")
            endif()
        endif()
    endif()

    # invoke o3de_copy_file_to_filesystem to copy the files to the bundle
    o3de_copy_file_to_filesystem(
        SOURCE_FILE "${source_file}"
        SOURCE_TYPE "${source_type}"
        SOURCE_GEM_MODULE "${source_is_gem}"
        TARGET_FILE "${target_file}"
    )
endfunction()

function(o3de_copy_file_to_filesystem)
    set(options)
    set(oneValueArgs SOURCE_FILE SOURCE_TYPE SOURCE_GEM_MODULE TARGET_FILE)
    set(multiValueArgs)
    cmake_parse_arguments("${CMAKE_CURRENT_FUNCTION}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    set(source_file "${${CMAKE_CURRENT_FUNCTION}_SOURCE_FILE}")
    set(source_type "${${CMAKE_CURRENT_FUNCTION}_SOURCE_TYPE}")
    set(source_is_gem "${${CMAKE_CURRENT_FUNCTION}_SOURCE_GEM_MODULE}")
    set(target_file "${${CMAKE_CURRENT_FUNCTION}_TARGET_FILE}")
    cmake_path(GET target_file PARENT_PATH target_directory)

    # Only copy the the source_file to destination if they are different
    cmake_path(COMPARE "${source_file}" EQUAL "${target_file}" same_location)
    if(NOT ${same_location})
        if(NOT EXISTS "${target_directory}")
            file(MAKE_DIRECTORY "${target_directory}")
        endif()

        unset(is_source_newer)

        # ly_is_newer_than will be true if:
        # 1. The source library was rebuilt.
        # 2. The library is a 3rdParty lib and it was downloaded after the target was copied.
        # 3. The library is being copied over for the first time(target does not exist).
        # While downloaded 3rdParty libs will have the creation time set to when it was built,
        # their modification time will reflect the time it was downloaded.
        ly_is_newer_than(${source_file} ${target_file} is_source_newer)

        if(${is_source_newer})
            message(STATUS "Copying \"${source_file}\" to \"${target_directory}\"...")
            file(MAKE_DIRECTORY "${target_directory}")
            file(COPY "${source_file}" DESTINATION "${target_directory}" FILE_PERMISSIONS @LY_COPY_PERMISSIONS@ FOLLOW_SYMLINK_CHAIN)
            file(TOUCH_NOCREATE "${target_file}")
            set_property(SOURCE "${CMAKE_CURRENT_LIST_FILE}" PROPERTY ANYTHING_NEW TRUE)
        endif()
    endif()
endfunction()

function(ly_copy source_files relative_target_directory)
    set(options)
    set(oneValueArgs TARGET_FILE_DIR SOURCE_TYPE SOURCE_GEM_MODULE)
    set(multiValueArgs)
    cmake_parse_arguments("${CMAKE_CURRENT_FUNCTION}" "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    set(source_type "${${CMAKE_CURRENT_FUNCTION}_SOURCE_TYPE}")
    set(source_is_gem "${${CMAKE_CURRENT_FUNCTION}_SOURCE_GEM_MODULE}")

    foreach(source_file IN LISTS source_files)
        # target is a bundle
        if(target_bundle_dir)
            o3de_copy_file_to_bundle(
                SOURCE_FILE "${source_file}"
                SOURCE_TYPE "${source_type}"
                SOURCE_GEM_MODULE "${source_is_gem}"
                RELATIVE_TARGET_DIRECTORY "${relative_target_directory}"
            )
        else()
            # target is not a bundle
            if("${source_file}" MATCHES "\\.[Ff]ramework[^\\.]")
                # fixup origin to copy the whole Framework folder
                string(REGEX REPLACE "(.*\\.[Ff]ramework).*" "\\1" source_file "${source_file}")
            endif()

            # Use final path segment as target file name
            cmake_path(GET source_file FILENAME target_filename)
            cmake_path(APPEND target_file "${target_file_dir}" "${relative_target_directory}" "${target_filename}")

            # Invoke o3de_copy_file_to_filestream to copy the source_file to the target_file
            o3de_copy_file_to_filesystem(
                SOURCE_FILE "${source_file}"
                SOURCE_TYPE "${source_type}"
                SOURCE_GEM_MODULE "${source_is_gem}"
                TARGET_FILE "${target_file}"
            )
        endif()
    endforeach()
endfunction()

@LY_COPY_COMMANDS@

if(NOT @LY_BUILD_FIXUP_BUNDLE@)
    return()
endif()

if(target_bundle_content_dir)
    # Use get_property(SOURCE) to query the variables set within the ly_copy function calls
    # The PARENT_SCOPE option to set only applys to the immediate function scope
    # So a nested function call would prevent the variables from being set in this file scope
    get_property(anything_new SOURCE "${CMAKE_CURRENT_LIST_FILE}" PROPERTY ANYTHING_NEW)
    get_property(plugin_libs SOURCE "${CMAKE_CURRENT_LIST_FILE}" PROPERTY BUNDLE_LIBS)
    get_property(plugin_dirs SOURCE "${CMAKE_CURRENT_LIST_FILE}" PROPERTY BUNDLE_DIRS)
    get_property(depends_on_python SOURCE "${CMAKE_CURRENT_LIST_FILE}" PROPERTY DEPENDS_ON_PYTHON)

    set(fixup_timestamp_file "${target_bundle_dir}.fixup.stamp")
    if(NOT anything_new)
        ly_is_newer_than(${target_bundle_dir} ${fixup_timestamp_file} anything_new)
    endif()
    if(anything_new)
        unset(fixup_bundle_ignore)
        # LYN-4505: Patch dxc, is configured in the wrong folder in 3p
        if(EXISTS ${target_file_dir}/Builders/DirectXShaderCompiler/bin/dxc-3.7)
            #message(STATUS "Ignore \"${target_file_dir}/Builders/DirectXShaderCompiler/bin/dxc-3.7\" ...")
            #list(APPEND fixup_bundle_ignore dxc-3.7)
        endif()
        # LYN-4502: Patch python bundle, it contains some windows executables, some files that fixup_bundle doesnt like and has
        # other issues that produce signature problems
        if(depends_on_python)
            cmake_path(APPEND target_bundle_framework_dir "${target_bundle_content_dir}" "Frameworks")
            message(STATUS "Fixing ${target_bundle_framework_dir}/Python.framework...")
            list(APPEND fixup_bundle_ignore Python python3.10m python3.10)
            file(REMOVE_RECURSE
                "${target_bundle_framework_dir}/Python.framework/Versions/Current"
                "${target_bundle_framework_dir}/Python.framework/Versions/3.10/Headers"
                "${target_bundle_framework_dir}/Python.framework/Versions/3.10/lib/Python"
                "${target_bundle_framework_dir}/Python.framework/Versions/3.10/lib/python3.10/test"
                "${target_bundle_framework_dir}/Python.framework/Versions/3.10/lib/python3.10/site-packages/scipy/io/tests"
                "${target_bundle_framework_dir}/Python.framework/Python"
                "${target_bundle_framework_dir}/Python.framework/Resources"
                "${target_bundle_framework_dir}/Python.framework/Headers"
            )
            file(GLOB_RECURSE exe_file_list "${target_bundle_framework_dir}/Python.framework/**/*.exe")
            if(exe_file_list)
                file(REMOVE_RECURSE ${exe_file_list})
            endif()
            execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink include/python3.10m Headers
                WORKING_DIRECTORY "${target_bundle_framework_dir}/Python.framework/Versions/3.10"
            )
            execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink 3.10 Current
                WORKING_DIRECTORY "${target_bundle_framework_dir}/Python.framework/Versions/"
            )
            execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink Versions/Current/Python Python
                WORKING_DIRECTORY "${target_bundle_framework_dir}/Python.framework"
            )
            execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink Versions/Current/Headers Headers
                WORKING_DIRECTORY "${target_bundle_framework_dir}/Python.framework"
            )
            execute_process(COMMAND "${CMAKE_COMMAND}" -E create_symlink Versions/Current/Resources Resources
                WORKING_DIRECTORY "${target_bundle_framework_dir}/Python.framework"
            )
            file(CHMOD "${target_bundle_framework_dir}/Python.framework/Versions/Current/Python"
                PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_WRITE GROUP_EXECUTE WORLD_READ WORLD_EXECUTE
            )
        endif()
        list(REMOVE_DUPLICATES plugin_libs)
        list(REMOVE_DUPLICATES plugin_dirs)
        fixup_bundle("${target_bundle_dir}" "${plugin_libs}" "${plugin_dirs}" IGNORE_ITEM ${fixup_bundle_ignore})

        # fixup bundle ends up removing the rpath of dxc (despite we exclude it)
        if(EXISTS "${target_file_dir}//Builders/DirectXShaderCompiler/bin/dxc-3.7")
            execute_process(COMMAND "${LY_INSTALL_NAME_TOOL}" -add_rpath @executable_path/../lib ${target_file_dir}/Builders/DirectXShaderCompiler/bin/dxc-3.7)
        endif()

        # misplaced .DS_Store files can cause signing to fail
        # Interrupted signatures can leave cstemp files behind that fail next signature
        file(GLOB_RECURSE remove_file_list
            "${target_bundle_dir}/**/.DS_Store"
            "${target_bundle_dir}/**/*.cstemp"
        )
        if(remove_file_list)
            file(REMOVE_RECURSE "${remove_file_list}")
        endif()

        file(TOUCH "${target_bundle_dir}")
        file(TOUCH "${fixup_timestamp_file}")

    endif()
endif()
