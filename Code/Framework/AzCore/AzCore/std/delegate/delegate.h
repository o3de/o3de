/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

/**
 * Based on Fast-Delegate v. 1.5 from Don Clugston. http://www.codeproject.com/cpp/FastDelegate.asp
 *
 * IMPORTANT: This version is not even complaint with the C++ standard, but it seems well tested
 * on all compilers we care about. This can be replaces with http://www.codeproject.com/KB/cpp/ImpossiblyFastCppDelegate.aspx
 * which conform with the standard with some minor limitations (compare). In both ways if we have any issues using
 * delegates, just default to AZStd::funciton and AZStd::bind.
 *
 * \note A good article about fast delegates and tr1::function can be found http://www.codeproject.com/KB/cpp/fastdelegate2.aspx
 */
#ifndef AZSTD_DELEGATE_H
#define AZSTD_DELEGATE_H

#include <AzCore/std/base.h>

////////////////////////////////////////////////////////////////////////////////
//                      Configuration options
//
////////////////////////////////////////////////////////////////////////////////

// Uncomment the following #define for optimally-sized delegates.
// In this case, the generated asm code is almost identical to the code you'd get
// if the compiler had native support for delegates.
// It will not work on systems where sizeof(dataptr) < sizeof(codeptr).
// Thus, it will not work for DOS compilers using the medium model.
// It will also probably fail on some DSP systems.
#define FASTDELEGATE_USESTATICFUNCTIONHACK

// Uncomment the next line to allow function declarator syntax.
// It is automatically enabled for those compilers where it is known to work.
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

////////////////////////////////////////////////////////////////////////////////
//                      Compiler identification for workarounds
//
////////////////////////////////////////////////////////////////////////////////

// Does the compiler uses Microsoft's member function pointer structure?
// If so, it needs special treatment.
// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's
// identifier, _MSC_VER. We need to filter Metrowerks out.
#if defined(_MSC_VER)
#define FASTDLGT_ISMSVC
#define FASTDLGT_MICROSOFT_MFP
#define FASTDLGT_HASINHERITANCE_KEYWORDS
#endif

////////////////////////////////////////////////////////////////////////////////
//                      General tricks used in this code
//
// (a) Error messages are generated by typdefing an array of negative size to
//     generate compile-time errors.
// (b) Warning messages on MSVC are generated by declaring unused variables, and
//      enabling the "variable XXX is never used" warning.
// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
//     (char *) first to ensure that the correct number of *bytes* are added.
//
////////////////////////////////////////////////////////////////////////////////
//                      Helper templates
//
////////////////////////////////////////////////////////////////////////////////


namespace AZStd
{
    namespace Internal
    {
        // we'll hide the implementation details in a nested namespace.
        //      implicit_cast< >
        // I believe this was originally going to be in the C++ standard but
        // was left out by accident. It's even milder than static_cast.
        // I use it instead of static_cast<> to emphasize that I'm not doing
        // anything nasty.
        // Usage is identical to static_cast<>
        template <class OutputClass, class InputClass>
        inline OutputClass implicit_cast(InputClass input)
        {
            return input;
        }

        //      horrible_cast< >
        // This is truly evil. It completely subverts C++'s type system, allowing you
        // to cast from any class to any other class. Technically, using a union
        // to perform the cast is undefined behaviour (even in C). But we can see if
        // it is OK by checking that the union is the same size as each of its members.
        // horrible_cast<> should only be used for compiler-specific workarounds.
        // Usage is identical to reinterpret_cast<>.

        // This union is declared outside the horrible_cast because BCC 5.5.1
        // can't inline a function with a nested class, and gives a warning.
        template <class OutputClass, class InputClass>
        union horrible_union
        {
            OutputClass out;
            InputClass in;
        };

        template <class OutputClass, class InputClass>
        inline OutputClass horrible_cast(const InputClass input)
        {
            horrible_union<OutputClass, InputClass> u;
            // Cause a compile-time error if in, out and u are not the same size.
            // If the compile fails here, it means the compiler has peculiar
            // unions which would prevent the cast from working.
            static_assert(sizeof(InputClass) == sizeof(u)
                && sizeof(InputClass) == sizeof(OutputClass),
                "Can't use horrible_cast");
            u.in = input;
            return u.out;
        }

        ////////////////////////////////////////////////////////////////////////////////
        //                      Workarounds
        //
        ////////////////////////////////////////////////////////////////////////////////

        // Backwards compatibility: This macro used to be necessary in the virtual inheritance
        // case for Intel and Microsoft. Now it just forward-declares the class.
        #define FASTDELEGATEDECLARE(CLASSNAME)  class CLASSNAME;

        ////////////////////////////////////////////////////////////////////////////////
        //                      Fast Delegates, part 1:
        //
        //      Conversion of member function pointer to a standard form
        //
        ////////////////////////////////////////////////////////////////////////////////

        // GenericClass is a fake class, ONLY used to provide a type.
        // It is vitally important that it is never defined, so that the compiler doesn't
        // think it can optimize the invocation. For example, Borland generates simpler
        // code if it knows the class only uses single inheritance.

        // Compilers using Microsoft's structure need to be treated as a special case.
        #ifdef  FASTDLGT_MICROSOFT_MFP

        #ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
        // For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP
        // (4 bytes), even when the /vmg option is used. Declaring an empty class
        // would give 16 byte pointers in this case....
        class __single_inheritance GenericClass;
        #endif
        // ...but for Codeplay, an empty class *always* gives 4 byte pointers.
        // If compiled with the /clr option ("managed C++"), the JIT compiler thinks
        // it needs to load GenericClass before it can call any of its functions,
        // (compiles OK but crashes at runtime!), so we need to declare an
        // empty class to make it happy.
        // Codeplay and VC4 can't cope with the unknown_inheritance case either.
        class GenericClass
        {
        };
        #else
        class GenericClass;
        #endif

        // The size of a single inheritance member function pointer.
        const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());

        //                      SimplifyMemFunc< >::Convert()
        //
        //  A template function that converts an arbitrary member function pointer into the
        //  simplest possible form of member function pointer, using a supplied 'this' pointer.
        //  According to the standard, this can be done legally with reinterpret_cast<>.
        //  For (non-standard) compilers which use member function pointers which vary in size
        //  depending on the class, we need to use  knowledge of the internal structure of a
        //  member function pointer, as used by the compiler. Template specialization is used
        //  to distinguish between the sizes. Because some compilers don't support partial
        //  template specialization, I use full specialization of a wrapper struct.

        // general case -- don't know how to convert it. Force a compile failure
        template <int N>
        struct SimplifyMemFunc
        {
            template <class X, class XFuncType, class GenericMemFuncType>
            inline static GenericClass* Convert(X* pthis, XFuncType function_to_bind, GenericMemFuncType& bound_func)
            {
                (void)pthis;
                (void)function_to_bind;
                (void)bound_func;
                // Unsupported member function type -- force a compile failure.
                // (it's illegal to have a array with negative size).
                static_assert((N - 100) > 0, "Unsupported member function pointer on this compiler");
                return 0;
            }
        };

        // For compilers where all member func ptrs are the same size, everything goes here.
        // For non-standard compilers, only single_inheritance classes go here.
        template <>
        struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE>
        {
            template <class X, class XFuncType, class GenericMemFuncType>
            inline static GenericClass* Convert(X* pthis, XFuncType function_to_bind, GenericMemFuncType& bound_func)
            {
        #if defined __DMC__
                // Digital Mars doesn't allow you to cast between abitrary PMF's,
                // even though the standard says you can. The 32-bit compiler lets you
                // static_cast through an int, but the DOS compiler doesn't.
                bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
        #else
                bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);
        #endif
                return reinterpret_cast<GenericClass*>(pthis);
            }
        };

        ////////////////////////////////////////////////////////////////////////////////
        //                      Fast Delegates, part 1b:
        //
        //                  Workarounds for Microsoft and Intel
        //
        ////////////////////////////////////////////////////////////////////////////////


        // Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
        // need to be treated as a special case.
        #ifdef FASTDLGT_MICROSOFT_MFP
        // We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
        // at the start of each function for extra safety, but VC6 seems to ICE
        // intermittently if you do this inside a template.

        // __multiple_inheritance classes go here
        // Nasty hack for Microsoft and Intel (IA32 and Itanium)
        template<>
        struct SimplifyMemFunc< SINGLE_MEMFUNCPTR_SIZE + sizeof(int) >
        {
            template <class X, class XFuncType, class GenericMemFuncType>
            inline static GenericClass* Convert(X* pthis, XFuncType function_to_bind,
                GenericMemFuncType& bound_func)
            {
                // We need to use a horrible_cast to do this conversion.
                // In MSVC, a multiple inheritance member pointer is internally defined as:
                union
                {
                    XFuncType func;
                    struct
                    {
                        GenericMemFuncType funcaddress; // points to the actual member function
                        int delta;       // #BYTES to be added to the 'this' pointer
                    } s;
                } u;
                // Check that the horrible_cast will work
                static_assert(sizeof(function_to_bind) == sizeof(u.s), "Can't use horrible_cast");
                u.func = function_to_bind;
                bound_func = u.s.funcaddress;
                return reinterpret_cast<GenericClass*>(reinterpret_cast<char*>(pthis) + u.s.delta);
            }
        };

        // virtual inheritance is a real nuisance. It's inefficient and complicated.
        // On MSVC and Intel, there isn't enough information in the pointer itself to
        // enable conversion to a closure pointer. Earlier versions of this code didn't
        // work for all cases, and generated a compile-time error instead.
        // But a very clever hack invented by John M. Dlugosz solves this problem.
        // My code is somewhat different to his: I have no asm code, and I make no
        // assumptions about the calling convention that is used.

        // In VC++ and ICL, a virtual_inheritance member pointer
        // is internally defined as:
        struct MicrosoftVirtualMFP
        {
            void (GenericClass::* codeptr)(); // points to the actual member function
            int delta;      // #bytes to be added to the 'this' pointer
            int vtable_index; // or 0 if no virtual inheritance
        };
        // The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
        // m_codeptr member is *always* called, regardless of the values of the other
        // members. (This is *not* true for other compilers, eg GCC, which obtain the
        // function address from the vtable if a virtual function is being called).
        // Dlugosz's trick is to make the codeptr point to a probe function which
        // returns the 'this' pointer that was used.

        // Define a generic class that uses virtual inheritance.
        // It has a trivial member function that returns the value of the 'this' pointer.
        struct GenericVirtualClass
            : virtual public GenericClass
        {
            typedef GenericVirtualClass* (GenericVirtualClass::* ProbePtrType)();
            GenericVirtualClass* GetThis() { return this; }
        };

        // __virtual_inheritance classes go here
        template <>
        struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2* sizeof(int) >
        {
            AZ_PUSH_DISABLE_WARNING(4121, "-Wunknown-warning-option") // alignment of a member was sensitive to packing
            // GenericClass* (X::*ProbeFunc) changes it's size. From Microsoft:
            //          Jason Shirk [MSFT]
            //          This is a known bug/issue. Unfortunately, we can't fix it in X86 product
            //              because there are backwards compatibility issues. Changing the alignment
            //              would change the offset of subsequent members in a class.
            //              We have addressed the issue for all future platforms (including IA64) where
            //              binary compatibility isn't yet an issue.
            // We can fix this warning by adding forward decl class __single_inheritance CLASS; if the XFuncType is member function.
            template <class X, class XFuncType, class GenericMemFuncType>
            inline static GenericClass* Convert(X* pthis, XFuncType function_to_bind, GenericMemFuncType& bound_func)
            {
                union
                {
                    XFuncType func;
                    GenericClass* (X::* ProbeFunc)();
                    MicrosoftVirtualMFP s;
                } u;
                u.func = function_to_bind;
                bound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);
                union
                {
                    GenericVirtualClass::ProbePtrType virtfunc;
                    MicrosoftVirtualMFP s;
                } u2;
                // Check that the horrible_cast<>s will work
                static_assert(sizeof(function_to_bind) == sizeof(u.s)
                    && sizeof(function_to_bind) == sizeof(u.ProbeFunc)
                    && sizeof(u2.virtfunc) == sizeof(u2.s),
                    "Can't use horrible_cast");
                // Unfortunately, taking the address of a MF prevents it from being inlined, so
                // this next line can't be completely optimized away by the compiler.
                u2.virtfunc = &GenericVirtualClass::GetThis;
                u.s.codeptr = u2.s.codeptr;
                return (pthis->*u.ProbeFunc)();
            }
            AZ_POP_DISABLE_WARNING
        };

        // Nasty hack for Microsoft and Intel (IA32 and Itanium)
        // unknown_inheritance classes go here
        // This is probably the ugliest bit of code I've ever written. Look at the casts!
        // There is a compiler bug in MSVC6 which prevents it from using this code.
        template <>
        struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3* sizeof(int) >
        {
            template <class X, class XFuncType, class GenericMemFuncType>
            inline static GenericClass* Convert(X* pthis, XFuncType function_to_bind,
                GenericMemFuncType& bound_func)
            {
                // The member function pointer is 16 bytes long. We can't use a normal cast, but
                // we can use a union to do the conversion.
                union
                {
                    XFuncType func;
                    // In VC++ and ICL, an unknown_inheritance member pointer
                    // is internally defined as:
                    struct
                    {
                        GenericMemFuncType m_funcaddress; // points to the actual member function
                        int delta;      // #bytes to be added to the 'this' pointer
                        int vtordisp;       // #bytes to add to 'this' to find the vtable
                        int vtable_index; // or 0 if no virtual inheritance
                    } s;
                } u;
                // Check that the horrible_cast will work
                static_assert(sizeof(XFuncType) == sizeof(u.s), "Can't use horrible_cast");
                u.func = function_to_bind;
                bound_func = u.s.funcaddress;
                int virtual_delta = 0;
                if (u.s.vtable_index)   // Virtual inheritance is used
                {   // First, get to the vtable.
                    // It is 'vtordisp' bytes from the start of the class.
                    const int* vtable = *reinterpret_cast<const int* const*>(
                            reinterpret_cast<const char*>(pthis) + u.s.vtordisp);

                    // 'vtable_index' tells us where in the table we should be looking.
                    virtual_delta = u.s.vtordisp + *reinterpret_cast<const int*>(
                            reinterpret_cast<const char*>(vtable) + u.s.vtable_index);
                }
                // The int at 'virtual_delta' gives us the amount to add to 'this'.
                // Finally we can add the three components together. Phew!
                return reinterpret_cast<GenericClass*>(
                    reinterpret_cast<char*>(pthis) + u.s.delta + virtual_delta);
            };
        };
        #endif // MS/Intel hacks
    }

    ////////////////////////////////////////////////////////////////////////////////
    //                      Fast Delegates, part 2:
    //
    //  Define the delegate storage, and cope with static functions
    //
    ////////////////////////////////////////////////////////////////////////////////

    // delegate_memento -- an opaque structure which can hold an arbitrary delegate.
    // It knows nothing about the calling convention or number of arguments used by
    // the function pointed to.
    // It supplies comparison operators so that it can be stored in STL collections.
    // It cannot be set to anything other than null, nor invoked directly:
    //   it must be converted to a specific delegate.

    // Implementation:
    // There are two possible implementations: the Safe method and the Evil method.
    //              delegate_memento - Safe version
    //
    // This implementation is standard-compliant, but a bit tricky.
    // A static function pointer is stored inside the class.
    // Here are the valid values:
    // +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+
    // |   0                |  0       |   0        | Empty          |
    // |   !=0              |(dontcare)|  Invoker   | Static function|
    // |   0                |  !=0     |  !=0*      | Method call    |
    // +--------------------+----------+------------+----------------+
    //  * For Metrowerks, this can be 0. (first virtual function in a
    //       single_inheritance class).
    // When stored stored inside a specific delegate, the 'dontcare' entries are replaced
    // with a reference to the delegate itself. This complicates the = and == operators
    // for the delegate class.

    //              delegate_memento - Evil version
    //
    // For compilers where data pointers are at least as big as code pointers, it is
    // possible to store the function pointer in the this pointer, using another
    // horrible_cast. In this case the delegate_memento implementation is simple:
    // +--pThis --+-- pMemFunc-+-- Meaning---------------------+
    // |    0     |  0         | Empty                         |
    // |  !=0     |  !=0*      | Static function or method call|
    // +----------+------------+-------------------------------+
    //  * For Metrowerks, this can be 0. (first virtual function in a
    //       single_inheritance class).
    // Note that the Sun C++ and MSVC documentation explicitly state that they
    // support static_cast between void * and function pointers.
    class delegate_memento
    {
    protected:
        // the data is protected, not private, because many
        // compilers have problems with template friends.
        typedef void (Internal::GenericClass::* GenericMemFuncType)(); // arbitrary MFP.
        Internal::GenericClass* m_pthis;
        GenericMemFuncType m_pFunction;

    #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
        typedef void (* GenericFuncPtr)(); // arbitrary code pointer
        GenericFuncPtr m_pStaticFunction;
    #endif

    public:
    #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
        delegate_memento()
            : m_pthis(0)
            , m_pFunction(0)
            , m_pStaticFunction(0) {};
        void clear()
        {
            m_pthis = 0;
            m_pFunction = 0;
            m_pStaticFunction = 0;
        }
    #else
        delegate_memento()
            : m_pthis(0)
            , m_pFunction(0) {};
        void clear() {  m_pthis = 0; m_pFunction = 0;   }
    #endif
    public:
    #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
        inline bool is_equal (const delegate_memento& x) const
        {
            // We have to cope with the static function pointers as a special case
            if (m_pFunction != x.m_pFunction)
            {
                return false;
            }
            // the static function ptrs must either both be equal, or both be 0.
            if (m_pStaticFunction != x.m_pStaticFunction)
            {
                return false;
            }
            if (m_pStaticFunction != 0)
            {
                return m_pthis == x.m_pthis;
            }
            else
            {
                return true;
            }
        }
    #else // Evil Method
        inline bool is_equal (const delegate_memento& x) const
        {
            return m_pthis == x.m_pthis && m_pFunction == x.m_pFunction;
        }
    #endif
        // Provide a strict weak ordering for DelegateMementos.
        inline bool is_less(const delegate_memento& right) const
        {
            // deal with static function pointers first
    #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
            if (m_pStaticFunction != 0 || right.m_pStaticFunction != 0)
            {
                return m_pStaticFunction < right.m_pStaticFunction;
            }
    #endif
            if (m_pthis != right.m_pthis)
            {
                return m_pthis < right.m_pthis;
            }
            // There are no ordering operators for member function pointers,
            // but we can fake one by comparing each byte. The resulting ordering is
            // arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.
            return memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;
        }
        // BUGFIX (Mar 2005):
        // We can't just compare m_pFunction because on Metrowerks,
        // m_pFunction can be zero even if the delegate is not empty!
        inline bool operator ! () const     // Is it bound to anything?
        { return m_pthis == 0 && m_pFunction == 0; }
        inline bool empty() const       // Is it bound to anything?
        { return m_pthis == 0 && m_pFunction == 0; }
    public:
        delegate_memento& operator = (const delegate_memento& right)
        {
            SetMementoFrom(right);
            return *this;
        }
        inline bool operator <(const delegate_memento& right)
        {
            return is_less(right);
        }
        inline bool operator >(const delegate_memento& right)
        {
            return right.is_less(*this);
        }

        inline delegate_memento(const delegate_memento& right)
            : m_pthis(right.m_pthis)
            , m_pFunction(right.m_pFunction)
    #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
            , m_pStaticFunction (right.m_pStaticFunction)
    #endif
        {}
    protected:
        void SetMementoFrom(const delegate_memento& right)
        {
            m_pFunction = right.m_pFunction;
            m_pthis = right.m_pthis;
    #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
            m_pStaticFunction = right.m_pStaticFunction;
    #endif
        }
    };

    //                      ClosurePtr<>
    //
    // A private wrapper class that adds function signatures to delegate_memento.
    // It's the class that does most of the actual work.
    // The signatures are specified by:
    // GenericMemFunc: must be a type of GenericClass member function pointer.
    // StaticFuncPtr:  must be a type of function pointer with the same signature
    //                 as GenericMemFunc.
    // UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6
    //                 where it never returns void (returns void instead).

    // An outer class, delegateN<>, handles the invoking and creates the
    // necessary typedefs.
    // This class does everything else.
    namespace Internal
    {
        template < class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr>
        class ClosurePtr
            : public delegate_memento
        {
        public:
            // These functions are for setting the delegate to a member function.

            // Here's the clever bit: we convert an arbitrary member function into a
            // standard form. XMemFunc should be a member function of class X, but I can't
            // enforce that here. It needs to be enforced by the wrapper class.
            template < class X, class XMemFunc >
            inline void bindmemfunc(X* pthis, XMemFunc function_to_bind)
            {
                m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
                        ::Convert(pthis, function_to_bind, m_pFunction);
        #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
                m_pStaticFunction = 0;
        #endif
            }
            // For const member functions, we only need a const class pointer.
            // Since we know that the member function is const, it's safe to
            // remove the const qualifier from the 'this' pointer with a const_cast.
            // VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.
            template < class X, class XMemFunc>
            inline void bindconstmemfunc(const X* pthis, XMemFunc function_to_bind)
            {
                m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
                        ::Convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);
        #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
                m_pStaticFunction = 0;
        #endif
            }
            // These functions are required for invoking the stored function
            inline GenericClass*   GetClosureThis() const { return m_pthis; }
            inline GenericMemFunc   GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }

            // There are a few ways of dealing with static function pointers.
            // There's a standard-compliant, but tricky method.
            // There's also a straightforward hack, that won't work on DOS compilers using the
            // medium memory model. It's so evil that I can't recommend it, but I've
            // implemented it anyway because it produces very nice asm code.

        #if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)

            //              ClosurePtr<> - Safe version
            //
            // This implementation is standard-compliant, but a bit tricky.
            // I store the function pointer inside the class, and the delegate then
            // points to itself. Whenever the delegate is copied, these self-references
            // must be transformed, and this complicates the = and == operators.
        public:
            // The next two functions are for operator ==, =, and the copy constructor.
            // We may need to convert the m_pthis pointers, so that
            // they remain as self-references.
            template< class DerivedClass >
            inline void CopyFrom (DerivedClass* pParent, const delegate_memento& x)
            {
                SetMementoFrom(x);
                if (m_pStaticFunction != 0)
                {
                    // transform self references...
                    m_pthis = reinterpret_cast<GenericClass*>(pParent);
                }
            }
            // For static functions, the 'static_function_invoker' class in the parent
            // will be called. The parent then needs to call GetStaticFunction() to find out
            // the actual function to invoke.
            template < class DerivedClass, class ParentInvokerSig >
            inline void bindstaticfunc(DerivedClass* pParent, ParentInvokerSig static_function_invoker,
                StaticFuncPtr function_to_bind)
            {
                if (function_to_bind == 0) // cope with assignment to 0
                {
                    m_pFunction = 0;
                }
                else
                {
                    bindmemfunc(pParent, static_function_invoker);
                }
                m_pStaticFunction = reinterpret_cast<GenericFuncPtr>(function_to_bind);
            }
            inline UnvoidStaticFuncPtr getStaticFunction() const
            {
                return reinterpret_cast<UnvoidStaticFuncPtr>(m_pStaticFunction);
            }
        #else

            //              ClosurePtr<> - Evil version
            //
            // For compilers where data pointers are at least as big as code pointers, it is
            // possible to store the function pointer in the this pointer, using another
            // horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
            // speeds up comparison and assignment. If C++ provided direct language support
            // for delegates, they would produce asm code that was almost identical to this.
            // Note that the Sun C++ and MSVC documentation explicitly state that they
            // support static_cast between void * and function pointers.

            template< class DerivedClass >
            inline void CopyFrom (DerivedClass* pParent, const delegate_memento& right)
            {
                (void)pParent;
                SetMementoFrom(right);
            }
            // For static functions, the 'static_function_invoker' class in the parent
            // will be called. The parent then needs to call GetStaticFunction() to find out
            // the actual function to invoke.
            // ******** EVIL, EVIL CODE! *******
            template <  class DerivedClass, class ParentInvokerSig>
            inline void bindstaticfunc(DerivedClass* pParent, ParentInvokerSig static_function_invoker,
                StaticFuncPtr function_to_bind)
            {
                if (function_to_bind == 0) // cope with assignment to 0
                {
                    m_pFunction = 0;
                }
                else
                {
                    // We'll be ignoring the 'this' pointer, but we need to make sure we pass
                    // a valid value to bindmemfunc().
                    bindmemfunc(pParent, static_function_invoker);
                }

                // WARNING! Evil hack. We store the function in the 'this' pointer!
                // Ensure that there's a compilation failure if function pointers
                // and data pointers have different sizes.
                // If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
                static_assert(sizeof(GenericClass*) == sizeof(function_to_bind), "Can't use static function hack");
                m_pthis = horrible_cast<GenericClass*>(function_to_bind);
                // MSVC, SunC++ and DMC accept the following (non-standard) code:
                //      m_pthis = static_cast<GenericClass *>(static_cast<void *>(function_to_bind));
                // BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long
                //      m_pthis = reinterpret_cast<GenericClass *>(reinterpret_cast<long>(function_to_bind));
            }
            // ******** EVIL, EVIL CODE! *******
            // This function will be called with an invalid 'this' pointer!!
            // We're just returning the 'this' pointer, converted into
            // a function pointer!
            inline UnvoidStaticFuncPtr GetStaticFunction() const
            {
                // Ensure that there's a compilation failure if function pointers
                // and data pointers have different sizes.
                // If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
                static_assert(sizeof(UnvoidStaticFuncPtr) == sizeof(this), "Can't use static function hack");
                return horrible_cast<UnvoidStaticFuncPtr>(this);
            }
        #endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)

            // Does the closure contain this static function?
            inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr)
            {
                if (funcptr == 0)
                {
                    return empty();
                }
                // For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary
                // value that is not equal to any valid function pointer.
                else
                {
                    return funcptr == reinterpret_cast<StaticFuncPtr>(GetStaticFunction());
                }
            }
        };
    } // namespace Internal

    ////////////////////////////////////////////////////////////////////////////////
    //                      Fast Delegates, part 3:
    //
    //              Wrapper classes to ensure type safety
    //
    ////////////////////////////////////////////////////////////////////////////////


    // Once we have the member function conversion templates, it's easy to make the
    // wrapper classes. So that they will work with as many compilers as possible,
    // the classes are of the form  delegate<int (char *, double)>
    // They can cope with any combination of parameters. The max number of parameters
    // allowed is 8, but it is trivial to increase this limit.
    // Note that we need to treat const member functions seperately.
    // All this class does is to enforce type safety, and invoke the delegate with
    // the correct list of parameters.

    // Because of the weird rule about the class of derived member function pointers,
    // you sometimes need to apply a downcast to the 'this' pointer.
    // This is the reason for the use of "implicit_cast<X*>(pthis)" in the code below.
    // If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
    // without this trick you'd need to write:
    //      MyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);
    // but with the trick you can write
    //      MyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);

    // Implicit conversion to "bool" is achieved using the safe_bool idiom,
    // using member data pointers (MDP). This allows "if (dg)..." syntax
    // Because some compilers (eg codeplay) don't have a unique value for a zero
    // MDP, an extra padding member is added to the SafeBool struct.
    // Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
    // in that case the static function constructor is not made explicit; this
    // allows "if (dg==0) ..." to compile.

    // Declare delegate as a class template.  It will be specialized
    // later for all number of arguments.
    template <typename Signature>
    class delegate;

    //N=0
    template<typename R>
    class delegate< R () >
    {
    private:
        typedef R (* StaticFunctionPtr)();
        typedef R (* UnvoidStaticFunctionPtr)();
        typedef R (Internal::GenericClass::* GenericMemFn)();
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R () > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)())
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)())
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)() const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)() const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)())
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)())
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)())
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() () const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))();
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction() const
        {
            return (*(m_Closure.GetStaticFunction()))();
        }
    };

    //N=1
    template<typename R, class Param1>
    class delegate< R (Param1) >
    {
    private:

        typedef R (* StaticFunctionPtr)(Param1 p1);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1);
        }
    };

    //N=2
    template<typename R, class Param1, class Param2>
    class delegate< R (Param1, Param2) >
    {
    private:

        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        inline delegate(R (*function_to_bind)(Param1 p1, Param2 p2))   { bind(function_to_bind);   }
        // for efficiency, prevent creation of a temporary
        inline void operator = (R (* function_to_bind)(Param1 p1, Param2 p2))   { bind(function_to_bind);   }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2))       { m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction, function_to_bind); }
        // Invoke the delegate
        inline R operator() (Param1 p1, Param2 p2) const { return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2);
        }
    };

    //N=3
    template<typename R, class Param1, class Param2, class Param3>
    class delegate< R (Param1, Param2, Param3) >
    {
    private:

        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2, Param3) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1, Param2 p2, Param3 p3) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2, p3);
        }
    };

    //N=4
    template<typename R, class Param1, class Param2, class Param3, class Param4>
    class delegate< R (Param1, Param2, Param3, Param4) >
    {
    private:

        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2, Param3, Param4) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4);
        }
    };

    //N=5
    template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5>
    class delegate< R (Param1, Param2, Param3, Param4, Param5) >
    {
    private:

        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2, Param3, Param4, Param5) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5);
        }
    };

    //N=6
    template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
    class delegate< R (Param1, Param2, Param3, Param4, Param5, Param6) >
    {
    private:

        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2, Param3, Param4, Param5, Param6) >  type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6);
        }
    };

    //N=7
    template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
    class delegate< R (Param1, Param2, Param3, Param4, Param5, Param6, Param7) >
    {
    private:
        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2, Param3, Param4, Param5, Param6, Param7) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7);
        }
    };

    //N=8
    template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
    class delegate< R (Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) >
    {
    private:
        typedef R (* StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
        typedef R (* UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
        typedef R (Internal::GenericClass::* GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
        typedef Internal::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
        ClosureType m_Closure;
    public:
        // Typedefs to aid generic programming
        typedef delegate< R (Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) > type;

        // Construction and comparison functions
        delegate() { clear(); }
        delegate(const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        void operator = (const delegate& x)
        {
            m_Closure.CopyFrom(this, x.m_Closure);
        }
        bool operator ==(const delegate& x) const
        {
            return m_Closure.is_equal(x.m_Closure);
        }
        bool operator !=(const delegate& x) const
        {
            return !m_Closure.is_equal(x.m_Closure);
        }
        bool operator <(const delegate& x) const
        {
            return m_Closure.is_less(x.m_Closure);
        }
        bool operator >(const delegate& x) const
        {
            return x.m_Closure.is_less(m_Closure);
        }
        // Binding to non-const member functions
        template < class X, class Y >
        delegate(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
        {
            m_Closure.bindmemfunc(Internal::implicit_cast<X*>(pthis), function_to_bind);
        }
        // Binding to const member functions.
        template < class X, class Y >
        delegate(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        template < class X, class Y >
        inline void bind(const Y* pthis, R (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
        {
            m_Closure.bindconstmemfunc(Internal::implicit_cast<const X*>(pthis), function_to_bind);
        }
        // Static functions. We convert them into a member function call.
        // This constructor also provides implicit conversion
        delegate(R (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
        {
            bind(function_to_bind);
        }
        // for efficiency, prevent creation of a temporary
        void operator = (R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
        {
            bind(function_to_bind);
        }
        inline void bind(R (* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
        {
            m_Closure.bindstaticfunc(this, &delegate::InvokeStaticFunction,
                function_to_bind);
        }
        // Invoke the delegate
        R operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
        {
            return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8);
        }
        // Implicit conversion to "bool" using the safe_bool idiom
    private:
        typedef struct SafeBoolStruct
        {
            int a_data_pointer_to_this_is_0_on_buggy_compilers;
            StaticFunctionPtr m_nonzero;
        } UselessTypedef;
        typedef StaticFunctionPtr SafeBoolStruct::* unspecified_bool_type;
    public:
        operator unspecified_bool_type() const {
            return empty() ? 0 : &SafeBoolStruct::m_nonzero;
        }
        // necessary to allow ==0 to work despite the safe_bool idiom
        inline bool operator==(StaticFunctionPtr funcptr)
        {
            return m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator!=(StaticFunctionPtr funcptr)
        {
            return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
        }
        inline bool operator ! () const     // Is it bound to anything?
        {
            return !m_Closure;
        }
        inline bool empty() const
        {
            return !m_Closure;
        }
        void clear() { m_Closure.clear(); }
        // Conversion to and from the delegate_memento storage class
        const delegate_memento& GetMemento() { return m_Closure; }
        void SetMemento(const delegate_memento& any) { m_Closure.CopyFrom(this, any); }

    private:    // Invoker for static functions
        R InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const
        {
            return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8);
        }
    };

    ////////////////////////////////////////////////////////////////////////////////
    //                      Fast Delegates, part 4:
    //
    //              make_delegate() helper function
    //
    //          make_delegate(&x, &X::func) returns a fastdelegate of the type
    //          necessary for calling x.func() with the correct number of arguments.
    //          This makes it possible to eliminate many typedefs from user code.
    //
    ////////////////////////////////////////////////////////////////////////////////

    // Also declare overloads of a make_delegate() global function to
    // reduce the need for typedefs.
    // We need separate overloads for const and non-const member functions.
    // Also, because of the weird rule about the class of derived member function pointers,
    // implicit downcasts may need to be applied later to the 'this' pointer.
    // That's why two classes (X and Y) appear in the definitions. Y must be implicitly
    // castable to X.

    //N=0
    template <class X, class Y, class R>
    delegate<R ()> make_delegate(Y* x, R (X::* func)())
    {
        return delegate<R ()>(x, func);
    }

    template <class X, class Y, class R>
    delegate<R ()> make_delegate(Y* x, R (X::* func)() const)
    {
        return delegate<R ()>(x, func);
    }

    //N=1
    template <class X, class Y, class Param1, class R>
    delegate<R (Param1) > make_delegate(Y* x, R (X::* func)(Param1 p1))
    {
        return delegate<R (Param1) >(x, func);
    }

    template <class X, class Y, class Param1, class R>
    delegate<R (Param1) > make_delegate(Y* x, R (X::* func)(Param1 p1) const)
    {
        return delegate<R (Param1) >(x, func);
    }

    //N=2
    template <class X, class Y, class Param1, class Param2, class R>
    delegate<R (Param1, Param2)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2))
    {
        return delegate<R (Param1, Param2)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class R>
    delegate<R (Param1, Param2)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2) const)
    {
        return delegate<R (Param1, Param2)>(x, func);
    }

    //N=3
    template <class X, class Y, class Param1, class Param2, class Param3, class R>
    delegate<R (Param1, Param2, Param3)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3))
    {
        return delegate<R (Param1, Param2, Param3)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class Param3, class R>
    delegate<R (Param1, Param2, Param3)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3) const)
    {
        return delegate<R (Param1, Param2, Param3)>(x, func);
    }

    //N=4
    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class R>
    delegate<R (Param1, Param2, Param3, Param4)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
    {
        return delegate<R(Param1, Param2, Param3, Param4)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class R>
    delegate<R (Param1, Param2, Param3, Param4)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
    {
        return delegate<R(Param1, Param2, Param3, Param4)>(x, func);
    }

    //N=5
    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5)>(x, func);
    }

    //N=6
    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5, Param6)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5, Param6)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5, Param6)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5, Param6)>(x, func);
    }

    //N=7
    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7)>(x, func);
    }

    //N=8
    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8)>(x, func);
    }

    template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class R>
    delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8)> make_delegate(Y* x, R (X::* func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
    {
        return delegate<R (Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8)>(x, func);
    }
}



#endif // AZSTD_DELEGATE_H
#pragma once
