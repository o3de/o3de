#!/usr/bin/env groovy
/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

import groovy.json.JsonOutput
import java.util.regex.Pattern

PIPELINE_CONFIG_FILE = 'scripts/build/Jenkins/o3de.json'
INCREMENTAL_BUILD_SCRIPT_PATH = 'scripts/build/bootstrap/incremental_build_util.py'
EBS_SNAPSHOT_SCRIPT_PATH = 'scripts/build/tools/ebs_snapshot.py'
PIPELINE_RETRY_ATTEMPTS = 3

// Number of minutes of inactivity in all stages of the pipeline to reach the timeout
PIPELINE_TIMEOUT = 60

EMPTY_JSON = readJSON text: '{}'

ENGINE_DEFAULT_ORGANIZATION_NAME = 'o3de'
ENGINE_REPOSITORY_NAME = 'o3de'
ENGINE_DEVELOPMENT_BRANCH = 'development'
EXTRAS_DEFAULT_ORGANIZATION_NAME = 'o3de'
EXTRAS_REPOSITORY_NAME = 'o3de-extras'
EXTRAS_DEVELOPMENT_BRANCH = 'development'

COMMIT_DOMAIN_NAME = ''
COMMIT_ORGANIZATION_NAME = ''
COMMIT_REPOSITORY_NAME = ''

@NonCPS
def doit()
{
    def httpsPattern = ~'https://(.+)/(.+)/(.+).git'
    def commitUrl = scm.userRemoteConfigs.url[0]
    def matcher = commitUrl =~ httpsPattern
    echo "matcher ${commitUrl} =~ ${httpsPattern}"
    matcher.find()
    COMMIT_DOMAIN_NAME = matcher.group(1)
    echo "matcher.group(1) = COMMIT_DOMAIN_NAME = ${COMMIT_DOMAIN_NAME}"
    COMMIT_ORGANIZATION_NAME = matcher.group(2)
    echo "matcher.group(2) = COMMIT_ORGANIZATION_NAME = ${COMMIT_ORGANIZATION_NAME}"
    COMMIT_REPOSITORY_NAME = matcher.group(3)
    echo "matcher.group(3) = COMMIT_REPOSITORY_NAME = ${COMMIT_REPOSITORY_NAME}"
}
doit()

ENGINE_COMMIT = false
EXTRAS_COMMIT = false
ENGINE_URL = ''
EXTRAS_URL = ''
if(COMMIT_REPOSITORY_NAME == ENGINE_REPOSITORY_NAME) {
    ENGINE_COMMIT = true
    ENGINE_URL = scm.userRemoteConfigs.url[0]
    EXTRAS_URL = "https://${COMMIT_DOMAIN_NAME}/${EXTRAS_DEFAULT_ORGANIZATION_NAME}/${EXTRAS_REPOSITORY_NAME}.git"
}
else if(COMMIT_REPOSITORY_NAME == EXTRAS_REPOSITORY_NAME) {
    EXTRAS_COMMIT = true
    ENGINE_URL = "https://${COMMIT_DOMAIN_NAME}/${ENGINE_DEFAULT_ORGANIZATION_NAME}/${ENGINE_REPOSITORY_NAME}.git"
    EXTRAS_URL = scm.userRemoteConfigs.url[0]
} else {
    //Error unknown repo
    assert false : "Unknown repo"
}
echo "ENGINE_URL = ${ENGINE_URL}"
echo "EXTRAS_URL = ${EXTRAS_URL}"

// Branches with build snapshots
BUILD_SNAPSHOTS = ['development', 'stabilization/2210']

// Build snapshots with empty snapshot (for use with 'SNAPSHOT' pipeline parameter)
BUILD_SNAPSHOTS_WITH_EMPTY = BUILD_SNAPSHOTS + ''

// The default build snapshot to be selected in the 'SNAPSHOT' pipeline parameter
DEFAULT_BUILD_SNAPSHOT = BUILD_SNAPSHOTS_WITH_EMPTY.get(0)

// Branches with build snapshots as comma separated value string
env.BUILD_SNAPSHOTS = BUILD_SNAPSHOTS.join(",")

def pipelineProperties = []

def pipelineParameters = [
    // Build/clean Parameters
    // The CLEAN_OUTPUT_DIRECTORY is used by ci_build scripts. Creating the parameter here passes it as an environment variable to jobs and is consumed that way
    booleanParam(defaultValue: false, description: 'Deletes the contents of the output directory before building. This will cause a \"clean\" build. NOTE: does not imply CLEAN_ASSETS', name: 'CLEAN_OUTPUT_DIRECTORY'),
    booleanParam(defaultValue: false, description: 'Deletes the contents of the output directories of the AssetProcessor before building.', name: 'CLEAN_ASSETS'),
    booleanParam(defaultValue: false, description: 'Deletes the contents of the workspace and forces a complete pull.', name: 'CLEAN_WORKSPACE'),
    booleanParam(defaultValue: false, description: 'Recreates the volume used for the workspace. The volume will be created out of a snapshot taken from main.', name: 'RECREATE_VOLUME'),
    booleanParam(defaultValue: false, description: 'Cancels AR immediately on any failure in the pipeline and marks it as failed', name: 'FAIL_FAST'),
    booleanParam(defaultValue: false, description: 'Deletes the volume used for the workspace after the pipeline steps are completed.', name: 'DISCARD_VOLUME')
]

def PlatformSh(cmd, lbl = '', winSlashReplacement = true, winCharReplacement = true) {
    if (env.IS_UNIX) {
        sh label: lbl,
           script: cmd
    } else {
        if (winSlashReplacement) {
            cmd = cmd.replace('/','\\')
        }
        if (winCharReplacement) {
            cmd = cmd.replace('%', '%%')
        }
        bat label: lbl,
            script: cmd
    }
}

def PlatformMkdir(path) {
    if (env.IS_UNIX) {
        sh label: "Making directories ${path}",
           script: "mkdir -p ${path}"
    } else {
        def win_path = path.replace('/','\\')
        bat label: "Making directories ${win_path}",
            script: "mkdir ${win_path}."
    }
}

def PlatformRm(path) {
    if (env.IS_UNIX) {
        sh label: "Removing ${path}",
           script: "rm ${path}"
    } else {
        def win_path = path.replace('/','\\')
        bat label: "Removing ${win_path}",
            script: "del /Q ${win_path}"
    }
}

def PlatformRmDir(path) {
    if (env.IS_UNIX) {
        sh label: "Removing ${path}",
           script: "if [ -d ${path} ]; then rm -rf ${path}; fi"
    } else {
        def win_path = path.replace('/','\\')
        bat label: "Removing ${win_path}",
            script: "IF exist ${win_path} rd /s /q ${win_path}"
    }
}

def IsPullRequest(branchName) {
    // temporarily using the name to detect if we are in a PR
    // In the future we will check with github
    return branchName.startsWith('PR-')
}

def IsPeriodicPipeline(pipelineName) {
    return pipelineName.startsWith('periodic-')
}

def IsJobEnabled(branchName, buildTypeMap, pipelineName, platformName) {
    if (IsPullRequest(branchName) && !IsPeriodicPipeline(pipelineName)) {
        return buildTypeMap.value.TAGS && buildTypeMap.value.TAGS.contains(pipelineName)
    }
    def job_list_override = params.JOB_LIST_OVERRIDE ? params.JOB_LIST_OVERRIDE.tokenize(',') : ''
    if (!job_list_override.isEmpty()) {
        return params[platformName] && job_list_override.contains(buildTypeMap.key);
    } else {
        return params[platformName] && buildTypeMap.value.TAGS && buildTypeMap.value.TAGS.contains(pipelineName)
    }
}

def GetRunningPipelineName(JENKINS_JOB_NAME) {
    // If the job name has an underscore
    def job_parts = JENKINS_JOB_NAME.tokenize('/')[0].tokenize('_')
    if (job_parts.size() > 1) {
        return [job_parts.take(job_parts.size() - 1).join('_'), job_parts[job_parts.size()-1]]
    }
    return [job_parts[0], 'default']
}

@NonCPS
def RegexMatcher(str, regex) {
    def matcher = (str =~ regex)
    return matcher ? matcher.group(1) : null
}

def LoadPipelineConfig(String pipelineName, String branchName) {
    echo 'Loading pipeline config'
    def pipelineConfig = {}
    pipelineConfig = readJSON file: PIPELINE_CONFIG_FILE
    PlatformRm(PIPELINE_CONFIG_FILE)
    pipelineConfig.platforms = EMPTY_JSON

    // Load the pipeline configs per platform
    pipelineConfig.PIPELINE_CONFIGS.each { pipeline_config ->
        def platform_regex = pipeline_config.replace('.','\\.').replace('*', '(.*)')
        if (!env.IS_UNIX) {
            platform_regex = platform_regex.replace('/','\\\\')
        }
        echo "Searching platform pipeline configs in ${pipeline_config} using ${platform_regex}"
        for (pipeline_config_path in findFiles(glob: pipeline_config)) {
            echo "\tFound platform pipeline config ${pipeline_config_path}"
            def platform = RegexMatcher(pipeline_config_path, platform_regex)
            if(platform) {
                pipelineConfig.platforms[platform] = EMPTY_JSON
                pipelineConfig.platforms[platform].PIPELINE_ENV = readJSON file: pipeline_config_path.toString()
            }
            PlatformRm(pipeline_config_path.toString())
        }
    }

    // Load the build configs
    pipelineConfig.BUILD_CONFIGS.each { build_config ->
        def platform_regex = build_config.replace('.','\\.').replace('*', '(.*)')
        if (!env.IS_UNIX) {
            platform_regex = platform_regex.replace('/','\\\\')
        }
        echo "Searching configs in ${build_config} using ${platform_regex}"
        for (build_config_path in findFiles(glob: build_config)) {
            echo "\tFound config ${build_config_path}"
            def platform = RegexMatcher(build_config_path, platform_regex)
            if(platform) {
                pipelineConfig.platforms[platform].build_types = readJSON file: build_config_path.toString()
            }
        }
    }
    return pipelineConfig
}

def GetBuildEnvVars(Map platformEnv, Map buildTypeEnv, String pipelineName) {
    def envVarMap = [:]
    platformPipelineEnv = platformEnv['ENV'] ?: [:]
    platformPipelineEnv.each { var ->
        envVarMap[var.key] = var.value
    }
    platformEnvOverride = platformEnv['PIPELINE_ENV_OVERRIDE'] ?: [:]
    platformPipelineEnvOverride = platformEnvOverride[pipelineName] ?: [:]
    platformPipelineEnvOverride.each { var ->
        envVarMap[var.key] = var.value
    }
    buildTypeEnv.each { var ->
        // This may override the above one if there is an entry defined by the job
        envVarMap[var.key] = var.value
    }

    // Environment that only applies to to Jenkins tweaks.
    // For 3rdParty downloads, we store them in the EBS volume so we can reuse them across node
    // instances. This allow us to scale up and down without having to re-download 3rdParty
    envVarMap['LY_PACKAGE_DOWNLOAD_CACHE_LOCATION'] = "${envVarMap['WORKSPACE']}/3rdParty/downloaded_packages"
    envVarMap['LY_PACKAGE_UNPACK_LOCATION'] = "${envVarMap['WORKSPACE']}/3rdParty/packages"

    return envVarMap
}

def GetEnvStringList(Map envVarMap) {
    def strList = []
    envVarMap.each { var ->
        strList.add("${var.key}=${var.value}")
    }
    return strList
}

def GetCrashArtifactDir() {
    if (env.IS_UNIX) {
        def uname = sh(script: 'uname', returnStdout: true).trim()
        if (uname.startsWith('Darwin')) {
            return '~/Library/Logs/DiagnosticReports/' // MacOS
        }
        else {
            return '/var/lib/apport/coredump/'
        }
    } else {
        return "$LOCALAPPDATA\\CrashDumps"
    }
}

def GetRemoteConfig(repositoryName, repositoryUrl) {
    def theRemoteConfig = [
        name: repositoryName,
        url: repositoryUrl,
        credentialsId: scm.userRemoteConfigs.credentialsId[0]
    ]
    return theRemoteConfig
}

def GetEngineRemoteConfig() {
    return GetRemoteConfig(ENGINE_REPOSITORY_NAME, ENGINE_URL)
}

def GetExtrasRemoteConfig() {
    return GetRemoteConfig(EXTRAS_REPOSITORY_NAME, EXTRAS_URL)
}

def UnInstallGitLFS() {
    PlatformSh('git lfs uninstall', 'Git LFS Uninstall')
}

def InstallAndPullGitLFS() {
    if(fileExists('.lfsconfig')) {
        PlatformSh("git lfs install --force", "LFS config exists. Installing LFS hooks to local repo")
        PlatformSh("git lfs pull", "Pulling new LFS objects")
    }
}

def CheckoutEngineBootstrapScripts(String branchName) {
    checkout([$class: 'GitSCM',
        branches: [[name: "*/${branchName}"]],
        doGenerateSubmoduleConfigurations: false,
        extensions: [
            [$class: 'PruneStaleBranch'],
            [$class: 'AuthorInChangelog'],
            [$class: 'SparseCheckoutPaths', sparseCheckoutPaths: [
                [ $class: 'SparseCheckoutPath', path: 'scripts/build/Jenkins/' ],
                [ $class: 'SparseCheckoutPath', path: 'scripts/build/bootstrap/' ],
                [ $class: 'SparseCheckoutPath', path: 'scripts/build/Platform' ],
                [ $class: 'SparseCheckoutPath', path: 'scripts/build/tools/' ]
            ]],
            // Shallow checkouts break changelog computation. Do not enable.
            [$class: 'CloneOption', noTags: false, reference: '', shallow: false]
        ],
        submoduleCfg: [],
        userRemoteConfigs: scm.userRemoteConfigs
    ])
}

def CheckoutRepo(String branchName, userRemoteConfigs, boolean disableSubmodules = false, boolean setEnvCommit = false) {
    if (fileExists('.git')) {
        // If the repository after checkout is locked, likely we took a snapshot while git was running,
        // to leave the repo in a usable state, garbage collect.
        def indexLockFile = '.git/index.lock'
        if (fileExists(indexLockFile)) {
            PlatformSh('git gc', 'Git GarbageCollect')
        }
        if (fileExists(indexLockFile)) { // if it is still there, remove it
            PlatformRm(indexLockFile)
        }
    }

    def random = new Random()
    def retryAttempt = 0
    retry(5) {
        if (retryAttempt > 0) {
            sleep random.nextInt(60 * retryAttempt)  // Stagger checkouts to prevent HTTP 429 (Too Many Requests) response from CodeCommit
        }
        retryAttempt = retryAttempt + 1
        checkout scm: [
            $class: 'GitSCM',
            branches: [[name: branchName]],
            extensions: [
                [$class: 'PruneStaleBranch'],
                [$class: 'AuthorInChangelog'],
                [$class: 'SubmoduleOption', disableSubmodules: disableSubmodules, recursiveSubmodules: true],
                [$class: 'CheckoutOption', timeout: 60]
            ],
            userRemoteConfigs: userRemoteConfigs
        ]
    }

    if (setEnvCommit) {
        // CHANGE_ID is used by some scripts to identify uniquely the current change (usually metric jobs)
        PlatformSh('git rev-parse HEAD > commitid', 'Getting commit id')
        env.CHANGE_ID = readFile file: 'commitid'
        env.CHANGE_ID = env.CHANGE_ID.trim()
        PlatformRm('commitid')

        // CHANGE_DATE is used by the installer to provide some ability to sort tagged builds in addition to BRANCH_NAME and CHANGE_ID
        commitDateFmt = '%%cI'
        if (env.IS_UNIX) commitDateFmt = '%cI'

        PlatformSh("git show -s --format=${commitDateFmt} ${env.CHANGE_ID} > commitdate", 'Getting commit date', winSlashReplacement=true, winCharReplacement=false)
        env.CHANGE_DATE = readFile file: 'commitdate'
        env.CHANGE_DATE = env.CHANGE_DATE.trim()
        PlatformRm('commitdate')
    }
}

def HandleDriveMount(String snapshot, String repositoryName, String projectName, String pipeline, String branchName, String platform, String buildType, String workspace, boolean recreateVolume = false) {
    unstash name: 'incremental_build_script'

    def pythonCmd = ''
    if(env.IS_UNIX) pythonCmd = 'sudo -E python3 -u '
    else pythonCmd = 'python3 -u '

    if(recreateVolume) {
        PlatformSh("${pythonCmd} ${INCREMENTAL_BUILD_SCRIPT_PATH} --action delete --repository_name ${repositoryName} --project ${projectName} --pipeline ${pipeline} --branch ${branchName} --platform ${platform} --build_type ${buildType}", 'Deleting volume', winSlashReplacement=false)
    }
    PlatformSh("${pythonCmd} ${INCREMENTAL_BUILD_SCRIPT_PATH} --action mount --snapshot ${snapshot} --repository_name ${repositoryName} --project ${projectName} --pipeline ${pipeline} --branch ${branchName} --platform ${platform} --build_type ${buildType}", 'Mounting volume', winSlashReplacement=false)

    if(env.IS_UNIX) {
        sh label: 'Setting volume\'s ownership',
            script: """
            if sudo test ! -d "${workspace}"; then
                sudo mkdir -p ${workspace}
                cd ${workspace}/..
                sudo chown -R lybuilder:root .
            fi
            """
    }
}

def PreBuildCommonSteps(Map pipelineConfig, String snapshot, String repositoryName, String projectName, String pipeline, String branchName, String platform, String buildType, String workspace, boolean mount = true, boolean disableSubmodules = false) {
    echo 'Starting pre-build common steps...'

    if (mount) {
        if(env.RECREATE_VOLUME?.toBoolean()){
            echo 'Starting to recreating drive...'
            HandleDriveMount(snapshot, repositoryName, projectName, pipeline, branchName, platform, buildType, workspace, true)
        } else {
            echo 'Starting to mounting drive...'
            HandleDriveMount(snapshot, repositoryName, projectName, pipeline, branchName, platform, buildType, workspace, false)
        }
    }

    // Cleanup previous repo location, we are currently at the root of the workspace, if we have a .git folder
    // we need to cleanup. Once all branches take this relocation, we can remove this
    if(env.CLEAN_WORKSPACE?.toBoolean() || fileExists("${workspace}/.git")) {
        if(fileExists(workspace)) {
            PlatformRmDir(workspace)
        }
    }

    dir(workspace) {

        // Add folder where we will store the 3rdParty downloads and packages
        dir('3rdParty') {
        }

        //get the engine repo first and get python, set the env.CHANGE_ID and env.CHANGE_DATE only if the repo is the engine repo
        dir(ENGINE_REPOSITORY_NAME) {
            echo "Checkout Engine: ${ENGINE_URL}"
            def setEnvCommit = false
            def the_branch = branchName
            if(ENGINE_COMMIT) {
                //the pr is for the engine repo, so we want to use the passed in branch name and record the change id and change date
                setEnvCommit = true
            } else {
                //this pr is for another repo so we want to use the development branch for the engine and do not set the commit id or change date
                the_branch = ENGINE_DEVELOPMENT_BRANCH
            }

            UnInstallGitLFS() // Prevent git from pulling lfs objects during checkout

            //checkout the engine branch
            CheckoutRepo(the_branch, scm.userRemoteConfigs, disableSubmodules, setEnvCommit)

            // Get python and clean.
            // Always run the clean step, the scripts detect what variables were set, but it also cleans if
            // the NODE_LABEL has changed
            if(env.IS_UNIX) {
                sh label: 'Getting python',
                   script: "${pipelineConfig.PYTHON_DIR}/get_python.sh"
                sh label: "Running ${platform} clean",
                   script: "${pipelineConfig.PYTHON_DIR}/python.sh -u ${pipelineConfig.BUILD_ENTRY_POINT} --platform ${platform} --type clean"
            } else {
                bat label: 'Getting python',
                    script: "${pipelineConfig.PYTHON_DIR}/get_python.bat"
                bat label: "Running ${platform} clean",
                    script: "${pipelineConfig.PYTHON_DIR}/python.cmd -u ${pipelineConfig.BUILD_ENTRY_POINT} --platform ${platform} --type clean"
            }

            InstallAndPullGitLFS()
        }
        dir(EXTRAS_REPOSITORY_NAME) {
            echo "Checkout Extras: ${EXTRAS_URL}"
            def setEnvCommit = false
            def the_branch = branchName
            if(EXTRAS_COMMIT) {
                //the pr is for the engine repo, so we want to use the passed in branch name and record the change id and change date
                setEnvCommit = true
            } else {
                //this pr is for another repo so we want to use the development branch for the engine and do not set the commit id or change date
                the_branch = EXTRAS_DEVELOPMENT_BRANCH
            }

            UnInstallGitLFS() // Prevent git from pulling lfs objects during checkout

            //checkout the engine branch
            CheckoutRepo(the_branch, [GetExtrasRemoteConfig()], disableSubmodules, setEnvCommit)

            InstallAndPullGitLFS()
        }
        //get any other external repos next, set the env.CHANGE_ID and env.CHANGE_DATE only if the repo is the pr repo
        pipelineConfig.EXTERNAL_REPOS.each { repo ->
            dir(repo.REPOSITORY_NAME) {
                echo "Checkout External Repo: ${repo.URL}"
                def setEnvCommit = false
                def the_branch = branchName
                if(!ENGINE_COMMIT && !EXTRAS_COMMIT) {
                    //the pr is for the this repo, so we want to use the passed in branch name and record the change id and change date
                    setEnvCommit = true
                } else {
                    //this pr is for the another repo so we want to use the development branch for the this repo and do not set the commit id or change date
                    the_branch = repo.DEVELOPMENT_BRANCH
                }

                UnInstallGitLFS() // Prevent git from pulling lfs objects during checkout

                //checkout the branch
                CheckoutRepo(the_branch, GetRemoteConfig(repo.REPOSITORY_NAME, repo.URL), disableSubmodules, setEnvCommit)

                InstallAndPullGitLFS()
            }
        }
    }
}

def Build(Map pipelineConfig, String platform, String type, String workspace) {
    timeout(time: env.TIMEOUT, unit: 'MINUTES', activity: true) {
        def command = "${pipelineConfig.PYTHON_DIR}/python"
        def ext = ''
        if(env.IS_UNIX) {
            command += '.sh'
            ext = '.sh'
        }
        else command += '.cmd'
        command += " -u ${pipelineConfig.BUILD_ENTRY_POINT} --platform ${platform} --type ${type}"

        dir(workspace) {
            def extrasAutomatedTestingControlFile = {}
            dir(EXTRAS_REPOSITORY_NAME) {
                echo 'Loading Extras .automatedtesting.json'
                extrasAutomatedTestingControlFile = readJSON file: '.automatedtesting.json'
            }
            dir(ENGINE_REPOSITORY_NAME) {
                //register the engine
                PlatformSh("scripts/o3de${ext} register --this-engine", "Registering this engine, will generate the o3de_manifest")

                //register all the objects specified in this repos .automatedtesting.json
                extrasAutomatedTestingControlFile.REGISTER_ENGINES.each { engineName ->
                    PlatformSh("scripts/o3de${ext} register --engine-path ${workspace}/${EXTRAS_REPOSITORY_NAME}/${engineName} || ver>nul", "Registering engine in ${workspace}/${EXTRAS_REPOSITORY_NAME}/${engineName}")
                }
                extrasAutomatedTestingControlFile.REGISTER_PROJECTS.each { projectName ->
                    PlatformSh("scripts/o3de${ext} register --project-path ${workspace}/${EXTRAS_REPOSITORY_NAME}/${projectName} || ver>nul", "Registering project in ${workspace}/${EXTRAS_REPOSITORY_NAME}/${projectName}")
                }
                extrasAutomatedTestingControlFile.REGISTER_GEMS.each { gemName ->
                    PlatformSh("scripts/o3de${ext} register --gem-path ${workspace}/${EXTRAS_REPOSITORY_NAME}/${gemName} || ver>nul", "Registering gem in ${workspace}/${EXTRAS_REPOSITORY_NAME}/${gemName}")
                }
                extrasAutomatedTestingControlFile.REGISTER_TEMPLATES.each { templateName ->
                    PlatformSh("scripts/o3de${ext} register --template-path ${workspace}/${EXTRAS_REPOSITORY_NAME}/${templateName} || ver>nul", "Registering template in ${workspace}/${EXTRAS_REPOSITORY_NAME}/${templateName}")
                }
                extrasAutomatedTestingControlFile.REGISTER_RESTRICTED.each { restrictedName ->
                    PlatformSh("scripts/o3de${ext} register --restricted-path ${workspace}/${EXTRAS_REPOSITORY_NAME}/${restrictedName} || ver>nul", "Registering restricted in ${workspace}/${EXTRAS_REPOSITORY_NAME}/${restrictedName}")
                }
                //enable all gems specified in the control file
                extrasAutomatedTestingControlFile.ENABLE_GEMS.each { gemName ->
                    PlatformSh("scripts/o3de${ext} enable-gem --gem-path ${workspace}/${EXTRAS_REPOSITORY_NAME}/${gemName} --project-name AutomatedTesting || ver>nul", "Enabling ${workspace}/${EXTRAS_REPOSITORY_NAME}/${gemName} for AutomatedTesting")
                }
            }
            pipelineConfig.EXTERNAL_REPOS.each { repo ->
                //now each of these repos could be either a composite repo or a singular repo
                //if it does not have a .automatedtesting.json control file, which is explicit in what objects to register
                //and which gems to enable, we assume they want to register all objects and enable all gems
                def foundControlFile = false
                def automatedTestingControlFile = {}
                def enginesExist = false
                def projectsExist = false
                def gemsExist = false
                def templatesExist = false
                def restrictedExist = false
                def engineRepo = false
                def projectRepo = false
                def gemRepo = false
                def templateRepo = false
                def restrictedRepo = false

                //see if this repo has supplied its own .automatedtesting.json to control what gets registered
                //and enabled/tested
                dir(repo.REPOSITORY_NAME) {
                    if(fileExists('.automatedtesting.json')) {
                        //There is a control file, so we will do only register and enable the gems it says to
                        foundControlFile = true
                        automatedTestingControlFile = readJSON file: '.automatedtesting.json'
                    } else {
                        //There is no control file so we must determine if this is a composite repo or a singular repo
                        //A standard composite repo has the form
                        //root
                        //  Engines
                        //  Projects
                        //  Gems
                        //  Templates
                        //  Restricted
                        allObjects = true
                        if(fileExists("Engines")) {
                            enginesExist = true
                        }
                        if(fileExists("Projects")) {
                            projectsExist = true
                        }
                        if(fileExists("Gems")) {
                            gemsExist = true
                        }
                        if(fileExists("Templates")) {
                            templatesExist = true
                        }
                        if(fileExists("Restricted")) {
                            restrictedExist = true
                        }

                        //If this is not a standard composite repo, then it wont have any composite dirs, then we know
                        //its a singular object repo, see what kind it is.
                        if(!enginesExist && !projectsExist && !gemsExist && !templatesExist && !restrictedExist)
                        {
                            if(fileExists("engine.json")) {
                                engineRepo = true
                            }
                            if(fileExists("project.json")) {
                                projectRepo = true
                            }
                            if(fileExists("gem.json")) {
                                gemRepo = true
                            }
                            if(fileExists("template.json")) {
                                templateRepo = true
                            }
                            if(fileExists("restricted.json")) {
                                restrictedRepo = true
                            }
                        }
                    }
                }

                dir(ENGINE_REPOSITORY_NAME) {
                    if(foundControlFile) {
                        //register all the objects specified in this repos .automatedtesting.json
                        automatedTestingControlFile.REGISTER_ENGINES.each { engineName ->
                            PlatformSh("scripts/o3de${ext} register --engine-path ${workspace}/${repo.REPOSITORY_NAME}/${engineName} || ver>nul", "Registering engine in ${workspace}/${repo.REPOSITORY_NAME}/${engineName}")
                        }
                        automatedTestingControlFile.REGISTER_PROJECTS.each { projectName ->
                            PlatformSh("scripts/o3de${ext} register --project-path ${workspace}/${repo.REPOSITORY_NAME}/${projectName} || ver>nul", "Registering project in ${workspace}/${repo.REPOSITORY_NAME}/${projectName}")
                        }
                        automatedTestingControlFile.REGISTER_GEMS.each { gemName ->
                            PlatformSh("scripts/o3de${ext} register --gem-path ${workspace}/${repo.REPOSITORY_NAME}/${gemName} || ver>nul", "Registering gem in ${workspace}/${repo.REPOSITORY_NAME}/${gemName}")
                        }
                        automatedTestingControlFile.REGISTER_TEMPLATES.each { templateName ->
                            PlatformSh("scripts/o3de${ext} register --template-path ${workspace}/${repo.REPOSITORY_NAME}/${templateName} || ver>nul", "Registering template in ${workspace}/${repo.REPOSITORY_NAME}/${templateName}")
                        }
                        automatedTestingControlFile.REGISTER_RESTRICTED.each { restrictedName ->
                            PlatformSh("scripts/o3de${ext} register --restricted-path ${workspace}/${repo.REPOSITORY_NAME}/${restrictedName} || ver>nul", "Registering restricted in ${workspace}/${repo.REPOSITORY_NAME}/${restrictedName}")
                        }
                        //enable all gems specified in the control file
                        automatedTestingControlFile.ENABLE_GEMS.each { gemName ->
                            PlatformSh("scripts/o3de${ext} enable-gem --gem-path ${workspace}/${repo.REPOSITORY_NAME}/${gemName} --project-name AutomatedTesting || ver>nul", "Enabling ${gemName} in AutomatedTesting")
                        }
                    } else {
                        //register all the objects in this repo
                        //if it is a composite repo then use the --all-<type>-path to register all of them
                        if(enginesExist) {
                            PlatformSh("scripts/o3de${ext} register --all-engines-path ${workspace}/${repo.REPOSITORY_NAME}/Engines || ver>nul", "Registering all engines in ${workspace}/${repo.REPOSITORY_NAME}/Engines")
                        }
                        if(projectsExist) {
                            PlatformSh("scripts/o3de${ext} register --all-projects-path ${workspace}/${repo.REPOSITORY_NAME}/Projects || ver>nul", "Registering all projects in ${workspace}/${repo.REPOSITORY_NAME}/Projects")
                        }
                        if(gemsExist) {
                            PlatformSh("scripts/o3de${ext} register --all-gems-path ${workspace}/${repo.REPOSITORY_NAME}/Gems || ver>nul", "Registering all gems in ${workspace}/${repo.REPOSITORY_NAME}/Gems")
                        }
                        if(templatesExist) {
                            PlatformSh("scripts/o3de${ext} register --all-templates-path ${workspace}/${repo.REPOSITORY_NAME}/Templates || ver>nul", "Registering all templates in ${workspace}/${repo.REPOSITORY_NAME}/Templates")
                        }
                        if(restrictedExist) {
                            PlatformSh("scripts/o3de${ext} register --all-restricted-path ${workspace}/${repo.REPOSITORY_NAME}/Restricted || ver>nul", "Registering all restricted in ${workspace}/${repo.REPOSITORY_NAME}/Restricted")
                        }
                        //enable all gems in this repo
                        if(gemsExist) {
                            PlatformSh("scripts/o3de${ext} enable-gem --all-gem-paths ${workspace}/${repo.REPOSITORY_NAME}/Gems --project-name AutomatedTesting || ver>nul", "Enabling all gems in AutomatedTesting")
                        }

                        //if its a singular repo register it using the --<type>-path
                        if(engineRepo) {
                            PlatformSh("scripts/o3de${ext} register --engine-path ${workspace}/${repo.REPOSITORY_NAME} || ver>nul", "Registering engine in ${workspace}/${repo.REPOSITORY_NAME}")
                        }
                        if(projectRepo) {
                            PlatformSh("scripts/o3de${ext} register --project-path ${workspace}/${repo.REPOSITORY_NAME} || ver>nul", "Registering project in ${workspace}/${repo.REPOSITORY_NAME}")
                        }
                        if(gemRepo) {
                            PlatformSh("scripts/o3de${ext} register --gem-path ${workspace}/${repo.REPOSITORY_NAME} || ver>nul", "Registering gem in ${workspace}/${repo.REPOSITORY_NAME}")
                        }
                        if(templateRepo) {
                            PlatformSh("scripts/o3de${ext} register --template-path ${workspace}/${repo.REPOSITORY_NAME} || ver>nul", "Registering template in ${workspace}/${repo.REPOSITORY_NAME}")
                        }
                        if(restrictedRepo) {
                            PlatformSh("scripts/o3de${ext} register --restricted-path ${workspace}/${repo.REPOSITORY_NAME} || ver>nul", "Registering restricted in ${workspace}/${repo.REPOSITORY_NAME}")
                        }
                        //if this singular repo is a gem enable it
                        if(gemRepo) {
                            PlatformSh("scripts/o3de${ext} enable-gem --gem-path ${workspace}/${repo.REPOSITORY_NAME} --project-name AutomatedTesting || ver>nul", "Enabling ${gemName} in AutomatedTesting")
                        }
                    }
                }
            }
            dir(ENGINE_REPOSITORY_NAME) {
                //build
                PlatformSh(command, "Running ${platform} ${type}")
            }
        }
    }
}

def TestMetrics(Map pipelineConfig, String workspace, String branchName, String repoName, String buildJobName, String outputDirectory, String configuration) {
    catchError(buildResult: null, stageResult: null) {
        def cmakeBuildDir = [workspace, ENGINE_REPOSITORY_NAME, outputDirectory].join('/')
        def command = "${pipelineConfig.PYTHON_DIR}/python"
        if(env.IS_UNIX) command += '.sh'
        else command += '.cmd'
        dir(workspace){
            dir(ENGINE_REPOSITORY_NAME) {
                checkout scm: [
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    extensions: [
                        [$class: 'AuthorInChangelog'],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'mars']
                    ],
                    userRemoteConfigs: [[url: "${env.MARS_REPO}", name: 'mars', credentialsId: "${env.GITHUB_USER}"]]
                ]
                withCredentials([usernamePassword(credentialsId: "${env.SERVICE_USER}", passwordVariable: 'apitoken', usernameVariable: 'username')]) {
                    command += " -u mars/scripts/python/ctest_test_metric_scraper.py " +
                                  '-e jenkins.creds.user %username% -e jenkins.creds.pass %apitoken% ' +
                                  "-e jenkins.base_url ${env.JENKINS_URL} " +
                                  "${cmakeBuildDir} ${branchName} %BUILD_NUMBER% AR ${configuration} ${repoName} --url ${env.BUILD_URL.replace('%','%%')}"
                    bat label: "Publishing ${buildJobName} Test Metrics",
                        script: command
                }
            }
        }
    }
}

def BenchmarkMetrics(Map pipelineConfig, String workspace, String branchName, String outputDirectory) {
    catchError(buildResult: null, stageResult: null) {
        def cmakeBuildDir = [workspace, ENGINE_REPOSITORY_NAME, outputDirectory].join('/')
        def command = "${pipelineConfig.PYTHON_DIR}/python"
        if(env.IS_UNIX) command += '.sh'
        else command += '.cmd'
        dir(workspace) {
            dir(ENGINE_REPOSITORY_NAME) {
                checkout scm: [
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    extensions: [
                        [$class: 'AuthorInChangelog'],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'mars']
                    ],
                    userRemoteConfigs: [[url: "${env.MARS_REPO}", name: 'mars', credentialsId: "${env.GITHUB_USER}"]]
                ]
                command += " -u mars/scripts/python/benchmark_scraper.py ${cmakeBuildDir} ${branchName}"
                PlatformSh(command, "Publishing Benchmark Metrics")
            }
        }
    }
}

def ExportTestResults(Map options, String platform, String type, String workspace, Map params) {
    catchError(message: "Error exporting tests results (this won't fail the build)", buildResult: 'SUCCESS', stageResult: 'FAILURE') {
        dir(workspace) {
            dir(ENGINE_REPOSITORY_NAME) {
                dir(params.OUTPUT_DIRECTORY) {
                    junit testResults: "Testing/**/*.xml"
                }
            }
        }
    }
}

def ExportTestScreenshots(Map options, String branchName, String platformName, String jobName, String workspace, Map params) {
    catchError(message: "Error exporting test screenshots (this won't fail the build)", buildResult: 'SUCCESS', stageResult: 'FAILURE') {
        dir(workspace){
            dir(ENGINE_REPOSITORY_NAME) {
                def screenshotsFolder = "AutomatedTesting/user/PythonTests/Automated/Screenshots"
                def s3Uploader = "scripts/build/tools/upload_to_s3.py"
                def command = "${options.PYTHON_DIR}/python.cmd -u ${s3Uploader} --base_dir ${screenshotsFolder} " +
                              '--file_regex \\"(.*zip\$)\\" ' +
                              "--bucket ${env.TEST_SCREENSHOT_BUCKET} " +
                              "--search_subdirectories True --key_prefix ${branchName}_${env.BUILD_NUMBER} " +
                              '--extra_args {\\"ACL\\":\\"bucket-owner-full-control\\"}'
                PlatformSh(command, "Uploading test screenshots for ${jobName}")
            }
        }
    }
}

// All files are included by default.
// --include will only re-include files that have been excluded from an --exclude filter.
//See more details at https://docs.aws.amazon.com/cli/latest/reference/s3/#use-of-exclude-and-include-filters
def ArchiveArtifactsOnS3(String artifactsSource, String s3Prefix="", boolean recursive=false, List<String> includes=[], List<String> excludes=[]) {
    if (!fileExists(s3Prefix)) {
        PlatformMkdir(s3Prefix)
    }
    PlatformSh("echo ${env.BUILD_URL} > ${s3Prefix}/build_url.txt")
    // archiveArtifacts is very slow, so we only archive one file and upload the rest artifacts to the same bucket using S3 CLI.
    archiveArtifacts artifacts: "${s3Prefix}/build_url.txt"
    def command = "aws s3 cp ${artifactsSource} s3://${env.JENKINS_ARTIFACTS_S3_BUCKET}/${env.JENKINS_JOB_NAME}/${env.BUILD_NUMBER}/artifacts/${s3Prefix} --only-show-errors "
    excludes.each{ exclude ->
        command += "--exclude \"${exclude}\" "
    }
    includes.each{ include ->
        command += "--include \"${include}\" "
    }
    if (recursive) command += "--recursive "
    PlatformSh(command, "Archiving artifacts to ${env.JENKINS_JOB_NAME}/${env.BUILD_NUMBER}/artifacts/${s3Prefix}", false)
}

def UploadAPLogs(String platformName, String jobName, String workspace, Map params) {
    catchError(message: "Error archiving AssetProcessor logs (this won't fail the build)", buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
        dir(workspace) {
            dir(ENGINE_REPOSITORY_NAME) {
                projects = params.CMAKE_LY_PROJECTS.split(",")
                projects.each{ project ->
                    ArchiveArtifactsOnS3("${project}/user/log", "ap_logs/${platformName}/${jobName}/${project}", true)
                }
            }
        }
    }
}

def UploadTestArtifacts(String workspace, String outputDirectory) {
    catchError(message: "Error archiving test artifacts (this won't fail the build)", buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
        def cmakeBuildDir = [workspace, ENGINE_REPOSITORY_NAME, outputDirectory].join('/')
        echo "Uploading Test Artifacts: ${cmakeBuildDir}/Testing"
        ArchiveArtifactsOnS3("${cmakeBuildDir}/Testing", "test_artifacts", true)
    }
}
def UploadCrashArtifacts(String platform) {
    catchError(message: "Error archiving crash artifacts (this won't fail the build)", buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
        def crashArtifactDir = GetCrashArtifactDir()
        echo "Uploading Crash Artifacts: ${crashArtifactDir}"
        ArchiveArtifactsOnS3("${crashArtifactDir}", "${platform}_crash_artifacts", true)
    }
}

def PostBuildCommonSteps(String workspace, Map params, String projectName, String pipelineName, String branchName, String platform, String buildType, boolean mount = true) {
    echo 'Starting post-build common steps...'
    if (params && params.containsKey('OUTPUT_DIRECTORY')){
        dir(workspace) {
            dir(ENGINE_REPOSITORY_NAME) {
                dir(params.OUTPUT_DIRECTORY) {
                    // Clean up Testing directory
                    PlatformRmDir("Testing")
                    // Recreate test runner xml directories that need to be pre generated to prevent race condition on incremental runs
                    PlatformMkdir("Testing/Pytest")
                    PlatformMkdir("Testing/Gtest")
                }
            }
        }
    }
    
    if (mount) {
        def pythonCmd = ''
        if(env.IS_UNIX) pythonCmd = 'sudo -E python3 -u '
        else pythonCmd = 'python3 -u '

        try {
            timeout(5) {
                if (env.DISCARD_VOLUME?.toBoolean()) {
                    PlatformSh("${pythonCmd} ${INCREMENTAL_BUILD_SCRIPT_PATH} --action delete --repository_name ${env.REPOSITORY_NAME} --project ${projectName} --pipeline ${pipelineName} --branch ${branchName} --platform ${platform} --build_type ${buildType}", 'Deleting volume', winSlashReplacement=false)
                } else {
                    PlatformSh("${pythonCmd} ${INCREMENTAL_BUILD_SCRIPT_PATH} --action unmount", 'Unmounting volume')
                }
            }
        } catch (Exception e) {
            echo "Unmount script error ${e}"
        }
    }
}

def HandleDriveSnapshots(String repositoryName, String projectName, String pipeline, String branchName, String platform, String buildType) {  
    unstash name: 'ebs_snapshot_script'

    catchError(message: "Error snapshotting volume (this won't fail the build)", buildResult: 'UNSTABLE', stageResult: 'FAILURE') {        
        def pythonCmd = 'python3 -u '
        
        mountName = "Name:${repositoryName}_${projectName}_${pipeline}_${branchName}_${platform}_${buildType}"
        mountName = mountName.replace('/', '_').replace('\\', '_')
        PlatformSh("${pythonCmd} ${EBS_SNAPSHOT_SCRIPT_PATH} --action create --tags ${mountName} --execute", "Starting volume snapshots", true)
        PlatformSh("${pythonCmd} ${EBS_SNAPSHOT_SCRIPT_PATH} --action delete --tags ${mountName} --retention ${env.SNAP_RETENTION} --execute", "Cleaning up old snapshots", true)
    }
}

def CreateSetupStage(Map pipelineConfig, String snapshot, String repositoryName, String projectName, String pipelineName, String branchName, String platformName, String jobName, Map environmentVars, boolean onlyMountEBSVolume = false) {
    return {
        stage('Setup') {
            if(onlyMountEBSVolume) {
                HandleDriveMount(snapshot, repositoryName, projectName, pipelineName, branchName, platformName, jobName, environmentVars['WORKSPACE'], false)
            } else {
                PreBuildCommonSteps(pipelineConfig, snapshot, repositoryName, projectName, pipelineName, branchName, platformName, jobName,  environmentVars['WORKSPACE'], environmentVars['MOUNT_VOLUME'], false)
            }
        }
    }
}

def CreateBuildStage(Map pipelineConfig, String platformName, String jobName, Map environmentVars) {
    return {
        stage("${jobName}") {
            Build(pipelineConfig, platformName, jobName, environmentVars['WORKSPACE'])
        }
    }
}

def CreateTestMetricsStage(Map pipelineConfig, String branchName, Map environmentVars, String buildJobName, String outputDirectory, String configuration) {
    return {
        stage("${buildJobName}_metrics") {
            TestMetrics(pipelineConfig, environmentVars['WORKSPACE'], branchName, env.DEFAULT_REPOSITORY_NAME, buildJobName, outputDirectory, configuration)
            BenchmarkMetrics(pipelineConfig, environmentVars['WORKSPACE'], branchName, outputDirectory)
        }
    }
}

def CreateExportTestResultsStage(Map pipelineConfig, String platformName, String jobName, Map environmentVars, Map params) {
    return {
        stage("${jobName}_results") {
            ExportTestResults(pipelineConfig, platformName, jobName, environmentVars['WORKSPACE'], params)
        }
    }
}

def CreateExportTestScreenshotsStage(Map pipelineConfig, String branchName, String platformName, String jobName, Map environmentVars, Map params) {
    return {
        stage("${jobName}_screenshots") {
            ExportTestScreenshots(pipelineConfig, branchName, platformName, jobName, environmentVars['WORKSPACE'], params)
        }
    }
}

def CreateUploadAPLogsStage(String platformName, String jobName, String workspace, Map params) {
    return {
        stage("${jobName}_upload_ap_logs") {
            UploadAPLogs(platformName, jobName, workspace, params)
        }
    }
}

def CreateUploadTestArtifactStage(String jobName, String workspace, String outputDirectory) {
    return {
        stage("${jobName}_upload_test_artifacts") {
            UploadTestArtifacts(workspace, outputDirectory)
        }
    }
}

def CreateUploadCrashArtifactStage(String jobName, String platform) {
    return {
        stage("${jobName}_upload_crash_artifacts") {
            UploadCrashArtifacts(platform)
        }
    }
}

def CreateTeardownStage(Map environmentVars, Map params, String projectName, String pipelineName, String branchName, String platformName, String buildType) {
    return {
        stage('Teardown') {
            PostBuildCommonSteps(environmentVars['WORKSPACE'], params, projectName, pipelineName, branchName, platformName, buildType, environmentVars['MOUNT_VOLUME'])
        }
    }
}

def CreateSnapshotStage(String repositoryName, String projectName, String pipelineName, String branchName, String platformName, String buildType, String jobName) {
    return{
        stage("${jobName}_snapshot_ebs_volume") {
            HandleDriveSnapshots(repositoryName, projectName, pipelineName, branchName, platformName, buildType)
        }
    }
}

def CreateSingleNode(Map pipelineConfig, def platform, def build_job, Map envVars, String branchName, String pipelineName, String repositoryName, String projectName, boolean onlyMountEBSVolume = false) {
    def nodeLabel = envVars['NODE_LABEL']
    return {
        def currentResult = ''
        def currentException = ''
        retry(PIPELINE_RETRY_ATTEMPTS) {
            node("${nodeLabel}") {
                if(isUnix()) { // Has to happen inside a node
                    envVars['IS_UNIX'] = 1
                }
                withEnv(GetEnvStringList(envVars)) {
                    def build_job_name = build_job.key
                    def params = platform.value.build_types[build_job_name].PARAMETERS
                    try {
                        CreateSetupStage(pipelineConfig, snapshot, repositoryName, projectName, pipelineName, branchName, platform.key, build_job.key, envVars, onlyMountEBSVolume).call()

                        if(build_job.value.steps) { // This is a pipe with many steps so create all the build stages
                            pipelineEnvVars = GetBuildEnvVars(platform.value.PIPELINE_ENV ?: EMPTY_JSON, build_job.value.PIPELINE_ENV ?: EMPTY_JSON, pipelineName)
                            build_job.value.steps.each { build_step ->
                                build_job_name = build_step
                                params = platform.value.build_types[build_job_name].PARAMETERS
                                // This addition of maps makes it that the right operand will override entries if they overlap with the left operand
                                envVars = pipelineEnvVars + GetBuildEnvVars(platform.value.PIPELINE_ENV ?: EMPTY_JSON, platform.value.build_types[build_step].PIPELINE_ENV ?: EMPTY_JSON, pipelineName)
                                try {
                                    CreateBuildStage(pipelineConfig,  platform.key, build_step, envVars).call()
                                }
                                catch (Exception e) {
                                    if (envVars['NONBLOCKING_STEP']?.toBoolean()) {
                                        unstable(message: "Build step ${build_step} failed but it's a non-blocking step in build job ${build_job.key}")
                                    } else {
                                        throw e
                                    }
                                }
                            }
                        } else {
                            CreateBuildStage(pipelineConfig,  platform.key, build_job.key, envVars).call()
                        }
                    }
                    catch(Exception e) {
                        if (e instanceof org.jenkinsci.plugins.workflow.steps.FlowInterruptedException) {
                            def causes = e.getCauses().toString()
                            if (causes.contains('RemovedNodeCause')) {
                                error "Node disconnected during build: ${e}"  // Error raised to retry stage on a new node
                            }
                        }
                        if (build_job_name.toLowerCase().contains('asset') && env.IS_UPLOAD_AP_LOGS?.toBoolean()) {
                            CreateUploadAPLogsStage(platform.key, build_job_name, envVars['WORKSPACE'], platform.value.build_types[build_job_name].PARAMETERS).call()
                        }
                        // Upload test artifacts only on builds that failed and ran test suites
                        if (env.IS_UPLOAD_TEST_ARTIFACTS?.toBoolean() && params.containsKey('CTEST_OPTIONS')) {
                            CreateUploadTestArtifactStage(build_job_name, envVars['WORKSPACE'], params.OUTPUT_DIRECTORY).call()
                        }
                        // All other errors will be raised outside the retry block
                        currentResult = envVars['ON_FAILURE_MARK'] ?: 'FAILURE'
                        currentException = e.toString()
                    }
                    finally {
                        if (env.MARS_REPO && params && params.containsKey('TEST_METRICS') && params.TEST_METRICS == 'True') {
                            CreateTestMetricsStage(pipelineConfig, branchName, envVars, build_job_name, params.OUTPUT_DIRECTORY, params.CONFIGURATION).call()
                        }
                        if (params && params.containsKey('TEST_RESULTS') && params.TEST_RESULTS == 'True') {
                            CreateExportTestResultsStage(pipelineConfig, platform.key, build_job_name, envVars, params).call()
                        }
                        if (fileExists(GetCrashArtifactDir())) {
                            CreateUploadCrashArtifactStage(build_job_name, platform.key).call()
                        }
                        if (params && params.containsKey('TEST_SCREENSHOTS') && params.TEST_SCREENSHOTS == 'True' && currentResult == 'FAILURE') {
                            CreateExportTestScreenshotsStage(pipelineConfig, branchName, platform.key, build_job_name, envVars, params).call()
                        }
                        CreateTeardownStage(envVars, params, projectName, pipelineName, branchName, platform.key, build_job.key).call()
                        if (envVars['CREATE_SNAPSHOT']?.toBoolean()) {
                            CreateSnapshotStage(repositoryName, projectName, pipelineName, branchName, platform.key, build_job.key, build_job_name).call()
                        }
                    }
                }
            }
        }
        // https://github.com/jenkinsci/jenkins/blob/master/core/src/main/java/hudson/model/Result.java
        // {SUCCESS,UNSTABLE,FAILURE,NOT_BUILT,ABORTED}
        if (currentResult == 'FAILURE') {
            currentBuild.result = 'FAILURE'
            error "FAILURE: ${currentException}"
        } else if (currentResult == 'UNSTABLE') {
            currentBuild.result = 'UNSTABLE'
            unstable(message: "UNSTABLE: ${currentException}")
        }
    }
}

// Used in CreateBuildJobs() to preprocess the build_job steps to programically create
// Node sections with a set of steps that can run on that node.
class PipeStepJobData {
    String m_nodeLabel = ""
    def m_steps = []

    PipeStepJobData(String label) {
        this.m_nodeLabel = label
    }

    def addStep(def step) {
        this.m_steps.add(step)
    }
}

def CreateBuildJobs(Map pipelineConfig, def platform, def build_job, Map envVars, String branchName, String pipelineName, String repositoryName, String projectName) {
    
    // if this is a pipeline, split jobs based on the NODE_LABEL 
    if(build_job.value.steps) {
        def defaultLabel = envVars['NODE_LABEL']
        def lastNodeLabel = ""
        def jobList = []
        def currentIdx = -1;

        // iterate the steps to build the order of node label + steps sets.
        // Order matters, as it is executed from first to last.
        // example layout.
        // node A
        //  step 1
        //  step 2
        // node B
        //  step 3
        // node C
        //  step 4
        build_job.value.steps.each { build_step ->
            //if node label defined
            if(platform.value.build_types[build_step] && platform.value.build_types[build_step].PIPELINE_ENV &&
               platform.value.build_types[build_step].PIPELINE_ENV['NODE_LABEL']) {
               
               //if the last node label doesn't match the new one, append it.
               if(platform.value.build_types[build_step].PIPELINE_ENV['NODE_LABEL'] != lastNodeLabel) {
                    lastNodeLabel = platform.value.build_types[build_step].PIPELINE_ENV['NODE_LABEL']
                    jobList.add(new PipeStepJobData(lastNodeLabel))
                    currentIdx++
                } 
            }
            //no label define, so it needs to run on the default node label
            else if(lastNodeLabel != defaultLabel) { //if the last node is not the default, append default
                lastNodeLabel = defaultLabel
                jobList.add(new PipeStepJobData(lastNodeLabel))
                currentIdx++
            }
            //add the build_step to the current node
            jobList[currentIdx].addStep(build_step)
        }
        
        return {
            jobList.eachWithIndex{ element, idx ->
                //update the node label + steps to the discovered data
                envVars['NODE_LABEL'] = element.m_nodeLabel
                build_job.value.steps = element.m_steps
                //no any additional nodes just mount the drive, do not handle clean parameters as that will be done by the first node.
                boolean onlyMountEBSVolume = idx != 0;
                //add this node
                CreateSingleNode(pipelineConfig, platform, build_job, envVars, branchName, pipelineName, repositoryName, projectName, onlyMountEBSVolume).call()
            }
        }
    } else {
        return CreateSingleNode(pipelineConfig, platform, build_job, envVars, branchName, pipelineName, repositoryName, projectName)
    }
}

def projectName = ''
def pipelineName = ''
def branchName = ''
def pipelineConfig = {}

// Start Pipeline
try {
    timeout(time: PIPELINE_TIMEOUT, unit: 'MINUTES', activity: true) {
        stage('Setup Pipeline') {
            node('controller') {
                def envVarList = []
                if(isUnix()) {
                    envVarList.add('IS_UNIX=1')
                }
                withEnv(envVarList) {
                    timestamps {
                        repositoryUrl = scm.getUserRemoteConfigs()[0].getUrl()
                        // repositoryName is the full repository name
                        repositoryName = (repositoryUrl =~ /https:\/\/github.com\/(.*)\.git/)[0][1]
                        env.REPOSITORY_NAME = repositoryName
                        (projectName, pipelineName) = GetRunningPipelineName(env.JOB_NAME) // env.JOB_NAME is the name of the job given by Jenkins
                        env.PIPELINE_NAME = pipelineName
                        if(env.BRANCH_NAME) {
                            branchName = env.BRANCH_NAME
                        } else {
                            branchName = scm.branches[0].name // for non-multibranch pipelines
                            env.BRANCH_NAME = branchName // so scripts that read this environment have it (e.g. incremental_build_util.py)                        
                        }
                        if(env.CHANGE_TARGET) {
                            // PR builds
                            if(BUILD_SNAPSHOTS.contains(env.CHANGE_TARGET)) {
                                snapshot = env.CHANGE_TARGET
                                echo "Snapshot for destination branch \"${env.CHANGE_TARGET}\" found."
                            } else { 
                                snapshot = DEFAULT_BUILD_SNAPSHOT
                                echo "Snapshot for destination branch \"${env.CHANGE_TARGET}\" does not exist, defaulting to snapshot \"${snapshot}\""
                            }
                        } else {
                            // Non-PR builds
                            pipelineParameters.add(choice(name: 'SNAPSHOT', choices: BUILD_SNAPSHOTS_WITH_EMPTY, description: 'Selects the build snapshot to use. A more diverted snapshot will cause longer build times, but will not cause build failures.'))
                            snapshot = env.SNAPSHOT
                            echo "Snapshot \"${snapshot}\" selected."
                        }
                        pipelineProperties.add(disableConcurrentBuilds())

                        echo "Running repository: \"${repositoryName}\", pipeline: \"${pipelineName}\", branch: \"${branchName}\", CHANGE_ID: \"${env.CHANGE_ID}\", GIT_COMMMIT: \"${scm.GIT_COMMIT}\"..."

                        CheckoutEngineBootstrapScripts(branchName)

                        // Load configs
                        pipelineConfig = LoadPipelineConfig(pipelineName, branchName)

                        // Add each platform as a parameter that the user can disable if needed
                        if (!IsPullRequest(branchName) || IsPeriodicPipeline(pipelineName)) {
                            pipelineParameters.add(stringParam(defaultValue: '', description: 'Filters and overrides the list of jobs to run for each of the below platforms (comma-separated). Can\'t be used during a pull request.', name: 'JOB_LIST_OVERRIDE'))

                            pipelineConfig.platforms.each { platform ->
                                pipelineParameters.add(booleanParam(defaultValue: true, description: '', name: platform.key))
                            }
                        }
                        // Add additional Jenkins parameters
                        pipelineConfig.platforms.each { platform ->
                            platformEnv = platform.value.PIPELINE_ENV
                            pipelineJenkinsParameters = platformEnv['PIPELINE_JENKINS_PARAMETERS'] ?: [:]
                            jenkinsParametersToAdd = pipelineJenkinsParameters[pipelineName] ?: [:]
                            jenkinsParametersToAdd.each{ jenkinsParameter ->
                                defaultValue = jenkinsParameter['default_value']
                                // Use last run's value as default value so we can save values in different Jenkins environment
                                if (jenkinsParameter['use_last_run_value']?.toBoolean()) {
                                    defaultValue = params."${jenkinsParameter['parameter_name']}" ?: jenkinsParameter['default_value']
                                }
                                switch (jenkinsParameter['parameter_type']) {
                                    case 'string':
                                        pipelineParameters.add(stringParam(defaultValue: defaultValue,
                                                                    description: jenkinsParameter['description'],
                                                                    name: jenkinsParameter['parameter_name']
                                                                    ))
                                        break
                                    case 'boolean':
                                        pipelineParameters.add(booleanParam(defaultValue: defaultValue,
                                                                    description: jenkinsParameter['description'],
                                                                    name: jenkinsParameter['parameter_name']
                                                                    ))
                                        break
                                    case 'password':
                                        pipelineParameters.add(password(defaultValue: defaultValue,
                                                                    description: jenkinsParameter['description'],
                                                                    name: jenkinsParameter['parameter_name']
                                                                    ))
                                        break
                                }
                            }
                        }

                        pipelineProperties.add(parameters(pipelineParameters.unique()))
                        properties(pipelineProperties)

                        // Stash the INCREMENTAL_BUILD_SCRIPT_PATH and EBS_SNAPSHOT_SCRIPT_PATH since all nodes will use it
                        stash name: 'incremental_build_script',
                            includes: INCREMENTAL_BUILD_SCRIPT_PATH
                        if (fileExists(EBS_SNAPSHOT_SCRIPT_PATH)) {
                            stash name: 'ebs_snapshot_script',
                            includes: EBS_SNAPSHOT_SCRIPT_PATH
                        }
                    }
                }
            }
        }

        if(env.BUILD_NUMBER == '1') {
            // Exit pipeline early on the initial build. This allows Jenkins to load the pipeline for the branch and enables users
            // to select build parameters on their first actual build. See https://issues.jenkins.io/browse/JENKINS-41929
            if (!IsPullRequest(branchName)) {
                currentBuild.result = 'SUCCESS'
                return
            }
            else if (IsPeriodicPipeline(pipelineName)) {
                currentBuild.result = 'NOT_BUILT'
                return
            }
        }

        def someBuildHappened = false

        // Build and Post-Build Testing Stage
        def buildConfigs = [:]

        // Platform Builds run on EC2
        pipelineConfig.platforms.each { platform ->
            platform.value.build_types.each { build_job ->
                if (IsJobEnabled(branchName, build_job, pipelineName, platform.key)) {   // User can filter jobs, jobs are tagged by pipeline
                    def envVars = GetBuildEnvVars(platform.value.PIPELINE_ENV ?: EMPTY_JSON, build_job.value.PIPELINE_ENV ?: EMPTY_JSON, pipelineName)
                    envVars['JENKINS_JOB_NAME'] = env.JOB_NAME // Save original Jenkins job name to JENKINS_JOB_NAME
                    envVars['JOB_NAME'] = "${branchName}_${platform.key}_${build_job.key}" // backwards compatibility, some scripts rely on this
                    someBuildHappened = true
                    buildConfigs["${platform.key} [${build_job.key}]"] = CreateBuildJobs(pipelineConfig, platform, build_job, envVars, branchName, pipelineName, repositoryName, projectName)
                }
            }
        }

        timestamps {
            stage('Build') {
                if (params.FAIL_FAST) {
                    echo "Fail fast option enabled"
                    buildConfigs.failFast = true
                }
                parallel buildConfigs // Run parallel builds
            }

            echo 'All builds successful'
        }
        if (!someBuildHappened) {
            currentBuild.result = 'NOT_BUILT'
        }
        if("${currentBuild.currentResult}" == "SUCCESS" && IsPeriodicPipeline(pipelineName) && IsPullRequest(branchName)) {
            currentBuild.result = 'UNSTABLE'
            currentBuild.description = 'Builds succeeded but regular PR run is required to merge the PR.'
        }
    }
}
catch(Exception e) {
    error "Exception: ${e}"
}
finally {
    try {
        node('controller') {
            if("${currentBuild.currentResult}" == "SUCCESS") {
                buildFailure = ""
                emailBody = "${BUILD_URL}\nSuccess!"
            } else {
                buildFailure = tm('${BUILD_FAILURE_ANALYZER}')
                emailBody = "${BUILD_URL}\n${buildFailure}!"
            }
            if(env.POST_AR_BUILD_SNS_TOPIC) {
                message_json = [
                    "build_url": env.BUILD_URL,
                    "build_number": env.BUILD_NUMBER,
                    "repository_name": env.REPOSITORY_NAME,
                    "branch_name": env.BRANCH_NAME,
                    "pipeline_name": GetRunningPipelineName(env.JOB_NAME)[1],
                    "full_pipeline_name": env.JOB_NAME,
                    "build_result": "${currentBuild.currentResult}",
                    "build_failure": buildFailure,
                    "recreate_volume": env.RECREATE_VOLUME,
                    "clean_output_directory": env.CLEAN_OUTPUT_DIRECTORY,
                    "clean_assets": env.CLEAN_ASSETS,
                    "fail_fast": env.FAIL_FAST
                ]
                snsPublish(
                    topicArn: env.POST_AR_BUILD_SNS_TOPIC,
                    subject:'Build Result',
                    message:JsonOutput.toJson(message_json)
                )
            }
            emailext (
                body: "${emailBody}",
                subject: "${currentBuild.currentResult}: ${JOB_NAME} - Build # ${BUILD_NUMBER}",
                recipientProviders: [
                    [$class: 'RequesterRecipientProvider']
                ]
            )
        }
    } catch(Exception e) {
    }
}
