/*
 * Modifications Copyright (c) Contributors to the Open 3D Engine Project. 
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 * 
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */
 
//------------------------------------------------------------------------------
//       Shader code related to lighting and shadowing for TressFX
//------------------------------------------------------------------------------

#pragma once

//==============================================================================
//                    Atom Lighting & Light Types
//==============================================================================
// Include options first
#include <Atom/Features/PBR/LightingOptions.azsli>
#include <HairSurface.azsli>
#include <HairUtilities.azsli>
#include <Atom/Features/SampleBrdfMap.azsli>
#include <Atom/Features/GoboTexture.azsli>
#include <Atom/Features/PBR/Lighting/StandardLightingData.azsli>
#include <Atom/Features/PBR/Lighting/StandardLightingDataEval.azsli>
#include <Atom/Features/LightCulling/LightCullingTileIterator.azsli>

#include <Atom/Features/PBR/LightingUtils.azsli>
#include <Atom/Features/PBR/Microfacet/Brdf.azsli>
#include <Atom/Features/PBR/BackLighting.azsli>
//------------------------------------------------------------------------------
#include <Atom/Features/PBR/Decals.azsli>

#include <HairLightingEquations.azsli>
//===================== Hair Lighting Shader Options ===========================
enum class HairLightingModel {GGX, Marschner, Kajiya};
option HairLightingModel o_hairLightingModel = HairLightingModel::Marschner;

//==============================================================================

#ifndef GetDiffuseLighting
#define GetDiffuseLighting(surface, lightingData, lightIntensity, dirToLight)       GetDiffuseLighting_Hair(surface, lightingData, lightIntensity, dirToLight)
#endif

#ifndef GetSpecularLighting
#define GetSpecularLighting(surface, lightingData, lightIntensity, dirToLight)      GetSpecularLighting_Hair(surface, lightingData, lightIntensity, dirToLight)
#endif

float3 GetSpecularLighting_Hair(Surface surface, LightingData lightingData, const float3 lightIntensity, const float3 dirToLight)
{
    float3 specular = float3(1, 0, 1);  // purple - error color
    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        specular = SpecularGGX(lightingData.dirToCamera, dirToLight, surface.GetSpecularNormal(), surface.GetSpecularF0(), lightingData.GetSpecularNdotV(), surface.roughnessA2, lightingData.multiScatterCompensation);
    }
    else if(o_hairLightingModel == HairLightingModel::Marschner)
    {
        specular = HairMarschnerBSDF(surface, lightingData, dirToLight);
    }
    // [To Do] - add the Kajiya-Kay lighting model option here in order to connect to Atom lighting loop

    return specular * lightIntensity;
}

// TODO: this isn't overload-able with defines yet, but we call it manually anyway
float3 GetBackLighting_Hair(Surface surface, LightingData lightingData, float3 lightIntensity, float3 dirToLight, float shadowRatio)
{
    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        float3 result = float3(0.0, 0.0, 0.0);
        float thickness = 0.0;
        float4 transmissionParams = surface.transmission.transmissionParams;

        // Thin object mode, using thin-film assumption proposed by Jimenez J. et al, 2010, "Real-Time Realistic Skin Translucency"
        // http://www.iryoku.com/translucency/downloads/Real-Time-Realistic-Skin-Translucency.pdf

        result = shadowRatio ?
            float3(0.0, 0.0, 0.0) :
            TransmissionKernel(surface.transmission.thickness * transmissionParams.w, rcp(transmissionParams.xyz)) *
            saturate(dot(-surface.GetDefaultNormal(), dirToLight)) * lightIntensity * shadowRatio;

        return result;
    }
    else // if ((o_hairLightingModel == HairLightingModel::Marschner) || (o_hairLightingModel == HairLightingModel::Kajiya))
    {
        return float3(0.0f, 0.0f, 0.0f);
    }

    return float3(1.0f, 0.0f, 0.0f);
}

//! Simple Lambertian BRDF
float3 HairDiffuseLambertian(float3 albedo, float3 normal, float3 dirToLight)
{
    float NdotL = saturate(dot(normal, dirToLight));
    return albedo * NdotL * INV_PI;
} 

// Replacing the generic Diffuse and Specular methods in StandardLighting.azsli 
// and removing the regular usage of clear coat second lobe energy distribution.
float3 GetDiffuseLighting_Hair(Surface surface, LightingData lightingData, float3 lightIntensity, float3 dirToLight)
{
    float3 diffuse = float3(0, 1, 0);   // Green - error color

    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        // Notice that addition of the response (1-F) here
        diffuse = HairDiffuseLambertian(surface.albedo, surface.GetDiffuseNormal(), dirToLight) * lightingData.diffuseResponse;
    }
    else if (o_hairLightingModel == HairLightingModel::Marschner)
    {
        return float3(0.0f, 0.0f, 0.0f);
    }
    // [To Do] - add the Kajiya-Kay lighting model option here in order to connect to Atom lighting loop

    diffuse *= lightIntensity;   
    return diffuse;
}

void UpdateLightingParameters(
    inout LightingData lightingData, 
    float3 positionWS, float3 normal, float roughnessLinear)
{
    lightingData.dirToCamera = normalize(ViewSrg::m_worldPosition.xyz - positionWS);

    // sample BRDF map (indexed by smoothness values rather than roughness)
    lightingData.NdotV = saturate(dot(normal, lightingData.dirToCamera));

    float2 brdfUV = float2(lightingData.GetSpecularNdotV(), (1.0f - roughnessLinear));

    lightingData.brdf = PassSrg::m_brdfMap.Sample(PassSrg::LinearSampler, brdfUV).rg;
}

void SetNormalAndUpdateLightingParams(
    in float3 tangent, in float3 dirToLight, 
    inout Surface surface, 
    inout LightingData lightingData)
{
    float3 biNormal;
    if (o_hairLightingModel == HairLightingModel::GGX)
    {   // Towards half vector but never cross fully (more weight to camera direction)
        float3 halfDir = normalize( dirToLight + 1.2 * lightingData.dirToCamera);
        biNormal = normalize(cross(tangent, halfDir));
    }
    else
    {   // Face forward towards the camera
        biNormal = normalize(cross(tangent, lightingData.dirToCamera));   
    }

    float3 projectedNormal = cross(biNormal, tangent);
    surface.normal = normalize(projectedNormal);    // the normalization might be redundunt 
    surface.vertexNormal = surface.normal; // [To Do] - support proper vertex normals in the hair shader.

    // Next is important in order to set NdotV and other PBR settings - needs to be set once per light
    UpdateLightingParameters(lightingData, surface.position, surface.GetSpecularNormal(), surface.roughnessLinear);

    // Diffuse and Specular response
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.GetSpecularNdotV(), surface.GetSpecularF0(), surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0f - lightingData.specularResponse;
}

//==============================================================================
#include <Atom/Features/PBR/Lights/LightStructures.azsli>
#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
//==============================================================================

//==============================================================================
//                         Simple Point Light 
//==============================================================================
// Note: We are using the ApplySimplePointLight from the Forward+ - pipeline here, but supply our own SimplePointLightUtil::Apply function
#include "LightTypes/HairSimplePointLight.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassSimplePointLights.azsli>

//==============================================================================
//                           Simple Spot Light 
//==============================================================================
// Note: We are using the ApplySimplePointLight from the Forward+ - pipeline here, but supply our own SimplePointLightUtil::Apply function
#include "LightTypes/HairSimpleSpotLight.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassSimpleSpotLights.azsli>

//==============================================================================
//                              Point Light 
//==============================================================================
// Note: We are using the ApplyPointLight from the Forward+ - pipeline here, but supply our own PointLightUtil::Apply function
#include "LightTypes/HairPointLight.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassPointLights.azsli>

//==============================================================================
//                             Disk Lights
//==============================================================================
// Note: We are using the ApplyDiskLight from the Forward+ - pipeline here, but supply our own DiskLightUtil::Apply function
#include "LightTypes/HairDiskLight.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassDiskLights.azsli>

//==============================================================================
//                            Directional Lights
//==============================================================================
// Note: We are using the ApplyDiskLight from the Forward+ - pipeline here, but supply our own DiskLightUtil::Apply function
#include "LightTypes/HairDirectionalLight.azsli"
#include <Atom/Features/Pipeline/Forward/ForwardPassDirectionalLights.azsli>

//==============================================================================
//                         IBL - GI and Reflections
//==============================================================================
// Adding diffuse contribution from IBL to the hair - this part still requires 
// multiple passes and improvements for both diffuse and specular IBL components.
// The immediate things to improve:
// - Virtual direction to 'light'
// - Absorption function based on hair accumulated thickness (back to front) and 
//      reverse thickness (front to back)
// - Diffuse contribution elements / scaling
float3 ApplyIblDiffuse(Surface surface, LightingData lightingData)
{
    float3 irradianceDir = MultiplyVectorQuaternion(surface.GetDiffuseNormal(), SceneSrg::m_iblOrientation);
    float3 diffuseSample = SceneSrg::m_diffuseEnvMap.Sample(SceneSrg::m_samplerEnv, GetCubemapCoords(irradianceDir)).rgb;

//    float3 diffuseLighting = HairDiffuseLambertian(surface.albedo, surface.GetDiffuseNormal(), lightingData.dirToCamera) * lightingData.diffuseResponse * diffuseSample;
//    float3 diffuseLighting = GetDiffuseLighting(surface, lightingData, diffuseSample, surface.GetDiffuseNormal());

    // Notice the multiplication with inverse thickness used as a measure of occlusion
    return lightingData.diffuseResponse * surface.albedo * diffuseSample * (1.0f - surface.thickness);
}

float3 ApplyIblSpecular(Surface surface, LightingData lightingData)
{
    float3 reflectDir = reflect(-lightingData.dirToCamera, surface.GetSpecularNormal());
    reflectDir = MultiplyVectorQuaternion(reflectDir, SceneSrg::m_iblOrientation);    

    // global
    float3 specularSample = SceneSrg::m_specularEnvMap.SampleLevel(
        SceneSrg::m_samplerEnv, GetCubemapCoords(reflectDir), 
        GetRoughnessMip(surface.roughnessLinear)).rgb;

    float3 specularLighting = GetSpecularLighting(surface, lightingData, specularSample, reflectDir);
    return specularLighting;
}

// Remark: IBL is still WIP and this part will change in the near future
void ApplyIBL(Surface surface, inout LightingData lightingData)
{
//    float3 normal = normalize(float3(surface.tangent.z, -surface.tangent.x, surface.tangent.y));
//    SetNormalAndUpdateLightingParams(surface.tangent, normal, surface, lightingData);
    SetNormalAndUpdateLightingParams(surface.tangent, lightingData.dirToCamera, surface, lightingData);

    float3 iblDiffuse = ApplyIblDiffuse(surface, lightingData);
    float3 iblSpecular = ApplyIblSpecular(surface, lightingData);

    // Adjust IBL lighting by exposure.
    float iblExposureFactor = pow(2.0, SceneSrg::m_iblExposure);
    lightingData.diffuseLighting += (iblDiffuse * iblExposureFactor * lightingData.diffuseAmbientOcclusion);
    lightingData.specularLighting += (iblSpecular * iblExposureFactor);
}


//==============================================================================
//                         
//                       Light Types Application
// 
//==============================================================================
// copyied from ApplyDirectLighting_ForwardPass, but modified since we don't support all light types for hair
void ApplyDirectLighting_Hair(Surface surface, inout LightingData lightingData, float4 screenUv, inout LightCullingTileIterator tileIterator)
{
    // Note: we currently don't support light assignment, but if we do, we also need to apply the decals, or the assigned light sequence
    // is out of order
    // ApplyDecals(lightingData.tileIterator, surface);

    if( IsDirectLightingEnabled() )
    {
        if (o_enableDirectionalLights)
        {
            ApplyDirectionalLights(surface, lightingData, screenUv);
        }
        if (o_enablePunctualLights)
        {
            ApplySimplePointLights(surface, lightingData, tileIterator);
            ApplySimpleSpotLights(surface, lightingData, tileIterator);
        }
        if (o_enableAreaLights)
        {
            ApplyPointLights(surface, lightingData, tileIterator);
            ApplyDiskLights(surface, lightingData, tileIterator);
            // These light-types aren't supported for hair, but as long as they are at the end, this doesn't matter for the assigned light sequence
            //ApplyCapsuleLights(surface, lightingData, tileIterator);
            //ApplyQuadLights(surface, lightingData, tileIterator);
            //ApplyPolygonLights(surface, lightingData, tileIterator);
        }
        if (o_enableIBL)
        {
            ApplyIBL(surface, lightingData); 
        }
    }
    else if(IsDebuggingEnabled_PLACEHOLDER() && GetRenderDebugViewMode() == RenderDebugViewMode::CascadeShadows)
    {
        if (o_enableDirectionalLights)
        {
            ApplyDirectionalLights(surface, lightingData, screenUv);
        }
    }
    else if( UseDebugLight() )
    {
        real3 lightIntensity = real3(SceneSrg::m_debugLightingIntensity);
        real3 lightDirection = real3(SceneSrg::m_debugLightingDirection);

        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, lightDirection);
        lightingData.specularLighting += GetSpecularLighting(surface, lightingData, lightIntensity, lightDirection);
    }
}
