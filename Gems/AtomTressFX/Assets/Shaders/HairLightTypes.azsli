/*
 * Modifications Copyright (c) Contributors to the Open 3D Engine Project. 
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 * 
 * SPDX-License-Identifier: (Apache-2.0 OR MIT) AND MIT
 *
 */
 
//------------------------------------------------------------------------------
//       Shader code related to lighting and shadowing for TressFX
//------------------------------------------------------------------------------

#pragma once

//==============================================================================
//                    Atom Lighting & Light Types
//==============================================================================
// Include options first
#include <Atom/Features/PBR/LightingOptions.azsli>
#include <HairSurface.azsli>
#include <HairUtilities.azsli>
#include <Atom/Features/PBR/Lighting/LightingData.azsli>

#include <Atom/Features/PBR/LightingUtils.azsli>
#include <Atom/Features/PBR/Microfacet/Brdf.azsli>
#include <Atom/Features/PBR/BackLighting.azsli>
//------------------------------------------------------------------------------
#include <Atom/Features/PBR/Decals.azsli>

#include <HairLightingEquations.azsli>
//===================== Hair Lighting Shader Options ===========================
enum class HairLightingModel {GGX, Marschner, Kajiya};
option HairLightingModel o_hairLightingModel = HairLightingModel::Marschner;

//==============================================================================
float3 GetSpecularLighting(Surface surface, LightingData lightingData, const float3 lightIntensity, const float3 dirToLight)
{
    float3 specular = float3(1, 0, 1);  // purple - error color
    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        specular = SpecularGGX(lightingData.dirToCamera, dirToLight, surface.normal, surface.specularF0, lightingData.NdotV, surface.roughnessA2, lightingData.multiScatterCompensation);
    }
    else if(o_hairLightingModel == HairLightingModel::Marschner)
    {
        specular = HairMarschnerBSDF(surface, lightingData, dirToLight);
    }

    return specular * lightIntensity;
}

float3 GetHairBackLighting(Surface surface, LightingData lightingData, float3 lightIntensity, float3 dirToLight, float shadowRatio)
{
    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        float3 result = float3(0.0, 0.0, 0.0);
        float thickness = 0.0;
        float4 transmissionParams = surface.transmission.transmissionParams;

        // Thin object mode, using thin-film assumption proposed by Jimenez J. et al, 2010, "Real-Time Realistic Skin Translucency"
        // http://www.iryoku.com/translucency/downloads/Real-Time-Realistic-Skin-Translucency.pdf

        result = shadowRatio ?
            float3(0.0, 0.0, 0.0) :
            TransmissionKernel(surface.transmission.thickness * transmissionParams.w, rcp(transmissionParams.xyz)) *
            saturate(dot(-surface.normal, dirToLight)) * lightIntensity * shadowRatio;

        return result;
    }
    else // if ((o_hairLightingModel == HairLightingModel::Marschner) || (o_hairLightingModel == HairLightingModel::Kajiya))
    {
        return float3(0.0f, 0.0f, 0.0f);
    }

    return float3(1.0f, 0.0f, 0.0f);
}

//! Simple Lambertian BRDF
float3 HairDiffuseLambertian(float3 albedo, float3 normal, float3 dirToLight)
{
    float NdotL = saturate(dot(normal, dirToLight));
    return albedo * NdotL * INV_PI;
} 

// Replacing the generic Diffuse and Specular methods in StandardLighting.azsli 
// and removing the regular usage of clear coat second lobe energy distribution.
float3 GetDiffuseLighting(Surface surface, LightingData lightingData, float3 lightIntensity, float3 dirToLight)
{
    float3 diffuse = float3(0, 1, 0);   // Green - error color

    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        // Notice that addition of the response (1-F) here
        diffuse = HairDiffuseLambertian(surface.albedo, surface.normal, dirToLight) * lightingData.diffuseResponse;
    }
    else if (o_hairLightingModel == HairLightingModel::Marschner)
    {
        return float3(0.0f, 0.0f, 0.0f);
    }

    diffuse *= lightIntensity;   
    return diffuse;
}

void UpdateLightingParameters(
    inout LightingData lightingData, 
    float3 positionWS, float3 normal, float roughnessLinear)
{
    lightingData.dirToCamera = normalize(ViewSrg::m_worldPosition.xyz - positionWS);

    // sample BRDF map (indexed by smoothness values rather than roughness)
    lightingData.NdotV = saturate(dot(normal, lightingData.dirToCamera));

    float2 brdfUV = float2(lightingData.NdotV, (1.0f - roughnessLinear));

    lightingData.brdf = PassSrg::m_brdfMap.Sample(PassSrg::LinearSampler, brdfUV).rg;
}

//==============================================================================
void SetNormal(
    in float3 tangent, in float3 dirToLight, 
    inout Surface surface, 
    inout LightingData lightingData)
{
    // Direct towards close to half vector by never cross fully (more weight to camera direction)
    float3 biNormal;
    if (o_hairLightingModel == HairLightingModel::GGX)
    {
        float3 halfDir = normalize( dirToLight + 1.2 * lightingData.dirToCamera);
        biNormal = normalize(cross(tangent, halfDir));
    }
    else
    {
        biNormal = normalize(cross(tangent, lightingData.dirToCamera));   // Original - simple face forward
    }

    float3 projectedNormal = cross(biNormal, tangent);
    surface.normal = normalize(projectedNormal);    // the normalization might be redundunt 

    // Next is important in order to set NdotV and other PBR settings - needs ot be set once per light
    UpdateLightingParameters(lightingData, surface.position, surface.normal, surface.roughnessLinear);

    // Diffuse and Specular response
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0f - lightingData.specularResponse;
}

//==============================================================================
#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
//==============================================================================


//==============================================================================
//                         Simple Point Light 
//==============================================================================
void ApplySimplePointLight(ViewSrg::SimplePointLight light, Surface surface, inout LightingData lightingData)
{  
    float3 posToLight = light.m_position - surface.position;
    float d2 = dot(posToLight, posToLight); // light distance squared
    float falloff = d2 * light.m_invAttenuationRadiusSquared;

    // Only calculate shading if light is in range
    if (falloff < 1.0f)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Standard quadratic falloff
        d2 = max(0.001 * 0.001, d2); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / d2) * radiusAttenuation;

        float3 dirToLight = normalize(posToLight);
        SetNormal(surface.tangent, dirToLight, surface, lightingData);

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, dirToLight);

        // Specular contribution
        lightingData.specularLighting += GetSpecularLighting(surface, lightingData, lightIntensity, dirToLight);
    }
}

void ApplyCulledSimplePointLights(Surface surface, inout LightingData lightingData)
{
    lightingData.tileIterator.LoadAdvance();

    int lightCount = 0;
    while( !lightingData.tileIterator.IsDone() && lightCount<1) 
    { 
        uint currLightIndex = lightingData.tileIterator.GetValue(); 
        lightingData.tileIterator.LoadAdvance();

        ViewSrg::SimplePointLight light = ViewSrg::m_simplePointLights[currLightIndex];
        ApplySimplePointLight(light, surface, lightingData);
        ++lightCount;
    }
}

void ApplyAllSimplePointLights(Surface surface, inout LightingData lightingData)
{
    for (int l = 0; l < ViewSrg::m_simplePointLightCount; ++l)
    {
        ViewSrg::SimplePointLight light = ViewSrg::m_simplePointLights[l];
        ApplySimplePointLight(light, surface, lightingData);
    }
}

//==============================================================================
//                           Simple Spot Light 
//==============================================================================
void ApplySimpleSpotLight(ViewSrg::SimpleSpotLight light, Surface surface, inout LightingData lightingData)
{
    float3 posToLight = light.m_position - surface.position;
    float3 dirToLight = normalize(posToLight);
   float dotWithDirection = dot(dirToLight, -normalize(light.m_direction));

    // If outside the outer cone angle return.
    if (dotWithDirection < light.m_cosOuterConeAngle)
    {
        return;
    }

    float d2 = dot(posToLight, posToLight); // light distance squared
    float falloff = d2 * light.m_invAttenuationRadiusSquared;

    // Only calculate shading if light is in range
    if (falloff < 1.0f)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Standard quadratic falloff
        d2 = max(0.001 * 0.001, d2); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / d2) * radiusAttenuation;

        if (dotWithDirection < light.m_cosInnerConeAngle) // in penumbra
        {   
            // Normalize into 0.0 - 1.0 space.
            float penumbraMask = (dotWithDirection - light.m_cosOuterConeAngle) / (light.m_cosInnerConeAngle - light.m_cosOuterConeAngle);

            // Apply smoothstep
            penumbraMask = penumbraMask * penumbraMask * (3.0 - 2.0 * penumbraMask);

            lightIntensity *= penumbraMask;
        }

        SetNormal(surface.tangent, dirToLight, surface, lightingData);

        // Tranmission contribution
        lightingData.translucentBackLighting += GetHairBackLighting(surface, lightingData, lightIntensity, dirToLight, 1.0);

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, dirToLight);

        // Specular contribution
        lightingData.specularLighting += GetSpecularLighting(surface, lightingData, lightIntensity, dirToLight);
    }
}

void ApplyAllSimpleSpotLights(Surface surface, inout LightingData lightingData)
{
    for (int l = 0; l < ViewSrg::m_simpleSpotLightCount; ++l)
    {
        ViewSrg::SimpleSpotLight light = ViewSrg::m_simpleSpotLights[l];
        ApplySimpleSpotLight(light, surface, lightingData);
    }
}
//==============================================================================
//                              Point Light 
//==============================================================================
void ApplyPointLight(ViewSrg::PointLight light, Surface surface, inout LightingData lightingData)
{
    float3 posToLight = light.m_position - surface.position;
    float d2 = dot(posToLight, posToLight); // light distance squared
    float falloff = d2 * light.m_invAttenuationRadiusSquared;

    // Only calculate shading if light is in range
    if (falloff < 1.0f)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Standard quadratic falloff
        d2 = max(0.001 * 0.001, d2); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / d2) * radiusAttenuation;

        float3 dirToLight = normalize(posToLight);
        SetNormal(surface.tangent, dirToLight, surface, lightingData);

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, dirToLight);

        // Tranmission contribution
        lightingData.translucentBackLighting += GetHairBackLighting(surface, lightingData, lightIntensity, dirToLight, 1.0);

        // Adjust the light direcion for specular based on bulb size

        // Calculate the reflection off the normal from the view direction
        float3 reflectionDir = reflect(-lightingData.dirToCamera, surface.normal);

        // Calculate a vector from the reflection vector to the light
        float3 reflectionPosToLight = posToLight - dot(posToLight, reflectionDir) * reflectionDir;

        // Adjust the direction to light based on the bulb size
        posToLight -= reflectionPosToLight * saturate(light.m_bulbRadius / length(reflectionPosToLight));

        // Adjust the intensity of the light based on the bulb size to conserve energy
        float sphereIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, light.m_bulbRadius, d2);

        // Specular contribution
        lightingData.specularLighting += sphereIntensityNormalization * GetSpecularLighting(surface, lightingData, lightIntensity, normalize(posToLight));
    }
}

void ApplyAllPointLights(Surface surface, inout LightingData lightingData)
{
    for (int l = 0; l < ViewSrg::m_pointLightCount; ++l)
    {
        ViewSrg::PointLight light = ViewSrg::m_pointLights[l];
        ApplyPointLight(light, surface, lightingData);
    }
}

//==============================================================================
//                             Disk Lights
//==============================================================================
#include <Atom/Features/PBR/Lights/DiskLight.azsli>

void TestApplyDiskLight(ViewSrg::DiskLight light, Surface surface, inout LightingData lightingData)
{
    float3 posToLight = light.m_position - surface.position;
    float distanceToLight2 = dot(posToLight, posToLight); // light distance squared
    float falloff = distanceToLight2 * light.m_invAttenuationRadiusSquared;

    float3 posToLightDir = normalize(posToLight);

    // Reduce the brightness based on how much the disk is facing this pixel.
    float angleFalloff = dot(posToLightDir, -light.m_direction);

    // Only calculate shading if light is in range
    if (falloff < 1.0f && angleFalloff > 0.0f)
    {
        bool useConeAngle = light.m_flags & DiskLightFlag::UseConeAngle;
        float3 dirToConeTip;
        float dotWithDirection;

        if (useConeAngle)
        {
            float3 coneTipPosition = light.m_position + light.m_bulbPositionOffset * -light.m_direction;
            dirToConeTip = normalize(coneTipPosition - surface.position);
            dotWithDirection = dot(dirToConeTip, -normalize(light.m_direction));

            // If outside the outer cone angle return.
            if (dotWithDirection < light.m_cosOuterConeAngle)
            {
                return;
            }
        }

        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Find the distance to the closest point on the disk
        float distanceToPlane = dot(posToLight, -light.m_direction);
        float distanceToPlane2 = distanceToPlane * distanceToPlane;
        float pointOnPlaneToLightDistance = sqrt(distanceToLight2 - distanceToPlane2); // pythagorean theorem 
        float pointOnPlaneToDiskDistance = max(pointOnPlaneToLightDistance - light.m_diskRadius, 0.0f); 
        float distanceToDisk2 = pointOnPlaneToDiskDistance * pointOnPlaneToDiskDistance + distanceToPlane2;

        // Update the light direction based on the edges of the disk as visible from this point instead of the center.
        float3 pointOnPlane = -light.m_direction * distanceToPlane;
        float3 pointOnPlaneToLightDir = normalize(posToLight - pointOnPlane);
        float3 nearSideDir = normalize(pointOnPlane + pointOnPlaneToLightDir * (pointOnPlaneToLightDistance - light.m_diskRadius));
        float3 farSideDir = normalize(pointOnPlane + pointOnPlaneToLightDir * (pointOnPlaneToLightDistance + light.m_diskRadius));
        posToLightDir = normalize((nearSideDir + farSideDir) * 0.5);

        // Standard quadratic falloff
        distanceToDisk2 = max(0.001 * 0.001, distanceToDisk2); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / distanceToDisk2) * radiusAttenuation * angleFalloff;

        // Adjust brightness based on the disk size relative to its distance.
        // The larger the disk is relative to the surface point, the dimmer it becomes.
        // 0 radius disks are unaffected.
        lightIntensity /= ((light.m_diskRadius / distanceToPlane) + 1.0);

        // shadow
        float litRatio = 1.0;

        // How much is back face shadowed, it's set to the reverse of litRatio to share the same default value with thickness, which should be 0 if no shadow map available
        float backShadowRatio = 0.0;
        if (o_enableShadows)
        {
            litRatio = ProjectedShadow::GetVisibility(
                light.m_shadowIndex,
                light.m_position,
                surface.position,
                -dirToConeTip,
                surface.normal);

            // Use backShadowRatio to carry thickness from shadow map for thick mode
            backShadowRatio = 1.0 - litRatio;
            if (o_transmission_mode == TransmissionMode::ThickObject)
            {
                backShadowRatio = ProjectedShadow::GetThickness(
                    light.m_shadowIndex,
                    surface.position);
            }
        }

        if (useConeAngle && dotWithDirection < light.m_cosInnerConeAngle) // in penumbra
        {   
            // Normalize into 0.0 - 1.0 space.
            float penumbraMask = (dotWithDirection - light.m_cosOuterConeAngle) / (light.m_cosInnerConeAngle - light.m_cosOuterConeAngle);

            // Apply smoothstep
            penumbraMask = penumbraMask * penumbraMask * (3.0 - 2.0 * penumbraMask);

            lightIntensity *= penumbraMask;
        }

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, posToLightDir) * litRatio;

        // Tranmission contribution
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, lightIntensity, posToLightDir, 0.0) * litRatio;

        // Adjust the light direction for specular based on disk size

        // Calculate the reflection off the normal from the view direction
        float3 reflectionDir = reflect(-lightingData.dirToCamera, surface.normal);
        float reflectionDotLight = dot(reflectionDir, -light.m_direction);

        // Let 'Intersection' denote the point where the reflection ray intersects the diskLight plane
        // As such, posToIntersection denotes the vector from pos to the intersection of the reflection ray and the disk plane:
        float3 posToIntersection;

        if (reflectionDotLight >= 0.0001)
        {
            // Reflection going towards the light
            posToIntersection = reflectionDir * distanceToPlane / reflectionDotLight;
        }
        else
        {
            // Reflection going away from the light. Choose a point far off and project it on the plane,
            // then treat that as the reflection plane intersection.
            float3 posToFarOffPoint = reflectionDir * distanceToPlane * 10000.0;
            float3 lightToFarOffPoint = posToFarOffPoint - posToLight;
            float3 intersectionToFarOffPoint = dot(lightToFarOffPoint, light.m_direction) * light.m_direction;
            posToIntersection = posToFarOffPoint - intersectionToFarOffPoint;
        }

        // Calculate a vector from the reflection vector to the light
        float3 intersectionToLight = posToLight - posToIntersection;

        // Adjust the direction to light based on the bulb size
        posToLight -= intersectionToLight * saturate(light.m_diskRadius / length(intersectionToLight));

        // Adjust the intensity of the light based on the bulb size to conserve energy
        float diskIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, light.m_diskRadius, distanceToLight2);

        // Specular contribution
        lightingData.specularLighting += diskIntensityNormalization * GetSpecularLighting(surface, lightingData, lightIntensity, normalize(posToLight)) * litRatio;
    }
}


void ApplyAllDiskLights(Surface surface, inout LightingData lightingData)
{    
    SetNormal(surface.tangent, lightingData.dirToCamera, surface, lightingData);
    for (int l = 0; l < ViewSrg::m_diskLightCount; ++l)
    {
        ViewSrg::DiskLight light = ViewSrg::m_diskLights[l];
        TestApplyDiskLight(light, surface, lightingData);
    }
}

//==============================================================================
//                            Directional Lights
//==============================================================================
void ApplyDirectionalLights(Surface surface, inout LightingData lightingData)
{
    DirectionalLightShadow::DebugInfo debugInfo = {0, false};

    // Shadowed check
    const uint shadowIndex = ViewSrg::m_shadowIndexDirectionalLight;
    float litRatio = 1.0f;
    float backShadowRatio = 0.0f;

    SetNormal(surface.tangent, -lightingData.dirToCamera, surface, lightingData);

    if (o_enableShadows && shadowIndex <  SceneSrg::m_directionalLightCount)
    {
        litRatio = DirectionalLightShadow::GetVisibility(
            shadowIndex,
            lightingData.shadowCoords,
            surface.normal,
            debugInfo);

//        if (o_transmission_mode == TransmissionMode::ThickObject)
//        {
//            backShadowRatio = DirectionalLightShadow::GetThickness(shadowIndex, lightingData.shadowCoords);
//        }
    }

    // Add the lighting contribution for each directional light
    for (int index = 0; index < SceneSrg::m_directionalLightCount; index++)
    {
        SceneSrg::DirectionalLight light = SceneSrg::m_directionalLights[index];
        float3 dirToLight = normalize(-light.m_direction);

        // Adjust the direction of the light based on its angular diameter.
        float3 reflectionDir = reflect(-lightingData.dirToCamera, surface.normal);
        float3 lightDirToReflectionDir = reflectionDir - dirToLight;
        float lightDirToReflectionDirLen = length(lightDirToReflectionDir);
        lightDirToReflectionDir = lightDirToReflectionDir / lightDirToReflectionDirLen; // normalize the length
        lightDirToReflectionDirLen = min(light.m_angularRadius, lightDirToReflectionDirLen);
        dirToLight += lightDirToReflectionDir * lightDirToReflectionDirLen;
        dirToLight = normalize(dirToLight);

        float currentLitRatio = 1.0f;
        float currentBackShadowRatio = 1.0f;
        if (o_enableShadows)
        {
            currentLitRatio = (index == shadowIndex) ? litRatio : 1.0f;

            currentBackShadowRatio = 1.0 - currentLitRatio;
            if (o_transmission_mode == TransmissionMode::ThickObject)
            {
                currentBackShadowRatio = (index == shadowIndex) ?  backShadowRatio : 0.;
            }
        }

        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, light.m_rgbIntensityLux, dirToLight) * currentLitRatio;
        lightingData.specularLighting += GetSpecularLighting(surface, lightingData, light.m_rgbIntensityLux, dirToLight) * currentLitRatio;
        lightingData.translucentBackLighting += GetHairBackLighting(surface, lightingData, light.m_rgbIntensityLux, dirToLight, currentBackShadowRatio);
    }
}

//==============================================================================
//                         IBL - GI and Reflections
//==============================================================================
// Adding diffuse contribution from IBL to the hair - this part still requires 
// multiple passes and improvements for both diffuse and specular IBL components.
// The immediate things to improve:
// - Virtual direction to 'light'
// - Absorption function based on hair accunulated thickness (back to front) and 
//      reverse thickness (front to back)
// - Diffuse contribution elements / scaling
float3 ApplyIblDiffuse(Surface surface, LightingData lightingData)
{
    float3 irradianceDir = MultiplyVectorQuaternion(surface.normal, SceneSrg::m_iblOrientation);
    float3 diffuseSample = SceneSrg::m_diffuseEnvMap.Sample(SceneSrg::m_samplerEnv, GetCubemapCoords(irradianceDir)).rgb;

//    float3 diffuseLighting = HairDiffuseLambertian(surface.albedo, surface.normal, lightingData.dirToCamera) * lightingData.diffuseResponse * diffuseSample;
//    float3 diffuseLighting = GetDiffuseLighting(surface, lightingData, diffuseSample, surface.normal);

    // Notice the multiplication with inverse thickness tat is used as measure of occlusion
    return lightingData.diffuseResponse * surface.albedo * diffuseSample * (1.0f - surface.thickness);
}

float3 ApplyIblSpecular(Surface surface, LightingData lightingData)
{
    float3 reflectDir = reflect(-lightingData.dirToCamera, surface.normal);
    reflectDir = MultiplyVectorQuaternion(reflectDir, SceneSrg::m_iblOrientation);    

    // global
    float3 specularSample = SceneSrg::m_specularEnvMap.SampleLevel(
        SceneSrg::m_samplerEnv, GetCubemapCoords(reflectDir), 
        GetRoughnessMip(surface.roughnessLinear)).rgb;

    float3 specularLighting = GetSpecularLighting(surface, lightingData, specularSample, reflectDir);
    return specularLighting;
}

void ApplyIBL(Surface surface, inout LightingData lightingData)
{
//    float3 normal = normalize(float3(surface.tangent.z, -surface.tangent.x, surface.tangent.y));
//    SetNormal(surface.tangent, normal, surface, lightingData);
    SetNormal(surface.tangent, lightingData.dirToCamera, surface, lightingData);

    float3 iblDiffuse = ApplyIblDiffuse(surface, lightingData);
    float3 iblSpecular = ApplyIblSpecular(surface, lightingData);

    // Adjust IBL lighting by exposure.
    float iblExposureFactor = pow(2.0, SceneSrg::m_iblExposure);
    lightingData.diffuseLighting += (iblDiffuse * iblExposureFactor * lightingData.diffuseAmbientOcclusion);
    lightingData.specularLighting += (iblSpecular * iblExposureFactor);
}


//==============================================================================
//                         
//                       Light Types Application
// 
//==============================================================================
void ApplyLighting(inout Surface surface, inout LightingData lightingData)
{
    // Shadow coordinates generation for the directional light
    const uint shadowIndex = ViewSrg::m_shadowIndexDirectionalLight;
    if (o_enableShadows && shadowIndex < SceneSrg::m_directionalLightCount)
    {
        DirectionalLightShadow::GetShadowCoords(shadowIndex, surface.position, lightingData.shadowCoords);
    }

    // Light loops application.
    // If culling is used, the order of the calls must match the light types list order 
//    ApplyDecals(lightingData.tileIterator, surface);

    if (o_enableDirectionalLights)
    {
        ApplyDirectionalLights(surface, lightingData);
    }

    if (o_enablePunctualLights)
    {
        ApplyAllSimplePointLights(surface, lightingData);
        ApplyAllSimpleSpotLights(surface, lightingData);
    }

    if (o_enableAreaLights)
    {
        ApplyAllPointLights(surface, lightingData);
        ApplyAllDiskLights(surface, lightingData);
    }

    if (o_enableIBL)
    {
        ApplyIBL(surface, lightingData); 
    }
}
