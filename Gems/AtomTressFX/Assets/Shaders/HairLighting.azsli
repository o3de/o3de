//------------------------------------------------------------------------------
// Shader code related to lighting and shadowing for TressFX
//------------------------------------------------------------------------------
//
// Copyright (c) 2019 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#pragma once

#include <HairUtilities.azsli>
//------------------------------------------------------------------------------
struct HairShadeParams
{
    float3 m_color;
    float m_hairShadowAlpha;
    float m_fiberRadius;
    float m_fiberSpacing;
    float m_Ka;
    float m_Kd;
    float m_Ks1;
    float m_Ex1;
    float m_Ks2;
    float m_Ex2;
};

// Returns a float3 which is the scale for diffuse, spec term, and colored spec term.
//
// The diffuse term is from Kajiya.
// 
// The spec term is what Marschner calls "R", reflecting directly off the surface of the hair, 
// taking the color of the light like a dielectric specular term.  This highlight is shifted 
// towards the root of the hair.
//
// The colored spec term is caused by light passing through the hair, bouncing off the back, and 
// coming back out.  It therefore picks up the color of the light.  
// Marschner refers to this term as the "TRT" term.  This highlight is shifted towards the 
// tip of the hair.
//
// vEyeDir, vLightDir and vTangentDir are all pointing out.
// coneAngleRadians explained below.
//
// 
// hair has a tiled-conical shape along its lenght.  Sort of like the following.
// 
// \    /
//  \  /
// \    /
//  \  /  
//
// The angle of the cone is the last argument, in radians.  
// It's typically in the range of 5 to 10 degrees
// [To Do] Adi: research hair lighting model and bring up to date approach
float3 ComputeDiffuseSpecFactors(
    float3 vEyeDir, float3 vLightDir, float3 vTangentDir, HairShadeParams params, 
    float coneAngleRadians = 10 * AMD_PI / 180)
{
    // in Kajiya's model: diffuse component: sin(t, l)
    float cosTL = (dot(vTangentDir, vLightDir));
    float sinTL = sqrt(1 - cosTL * cosTL);
    // [To Do] Adi: if below horizon the sine will still be positive - need to correct this case 
    float diffuse = sinTL; // here sinTL is apparently larger than 0

    float cosTRL = -cosTL;
    float sinTRL = sinTL;
    float cosTE = (dot(vTangentDir, vEyeDir));
    float sinTE = sqrt(1 - cosTE * cosTE);

    // primary highlight: reflected direction shift towards root (2 * coneAngleRadians)
    float cosTRL_root = cosTRL * cos(2 * coneAngleRadians) - sinTRL * sin(2 * coneAngleRadians);
    float sinTRL_root = sqrt(1 - cosTRL_root * cosTRL_root);
    float specular_root = max(0, cosTRL_root * cosTE + sinTRL_root * sinTE);

    // secondary highlight: reflected direction shifted toward tip (3*coneAngleRadians)
    float cosTRL_tip = cosTRL * cos(-3 * coneAngleRadians) - sinTRL * sin(-3 * coneAngleRadians);
    float sinTRL_tip = sqrt(1 - cosTRL_tip * cosTRL_tip);
    float specular_tip = max(0, cosTRL_tip * cosTE + sinTRL_tip * sinTE);

    return float3( 
        params.m_Kd * diffuse, 
        params.m_Ks1 * pow(specular_root, params.m_Ex1), 
        params.m_Ks2 * pow(specular_tip, params.m_Ex2));
}

float LinearizeDepth(float depthNDC, float fNear, float fFar)
{
    return fNear * fFar / (fFar - depthNDC * (fFar - fNear));
}

/*
// fDepthDistanceWS is the world space distance between the point on the surface and the point in the shadow map.
// fFiberSpacing is the assumed, average, world space distance between hair fibers.
// fFiberRadius in the assumed average hair radius.
// fHairAlpha is the alpha value for the hair (in terms of translucency, not coverage.)
// Output is a number between 0 (totally shadowed) and 1 (lets everything through)
float ComputeShadowAttenuation(float fDepthDistanceWS, float fFiberSpacing, float fFiberRadius, float fHairAlpha)
{
    float numFibers = fDepthDistanceWS / (fFiberSpacing * fFiberRadius);	// fiberSpacing + fiberRadius is total distance from 1 fiber to another

    // if occluded by hair, there is at least one fiber
    [flatten] if (fDepthDistanceWS > 1e-5)
        numFibers = max(numFibers, 1);

    return pow(abs(1 - fHairAlpha), numFibers);
}

float ComputeLightShadow(int lightIndex, float3 vPositionWS, in HairShadeParams params)
{
    if (LightData[lightIndex].ShadowMapIndex < 0)
        return 1.f;
    
    float4 shadowTexCoord = MatrixMult( LightData[lightIndex].ShadowProjection, float4(vPositionWS, 1.f) );
    shadowTexCoord.xyz /= shadowTexCoord.w;

    // remember we are splitting the shadow map in 4 quarters 
    // and at this point, everything's in -1 to 1
    // So bring back to 0 -> 0.5 and flip the Y coordinate
    shadowTexCoord.x = (1.0 + shadowTexCoord.x) * 0.25;
    shadowTexCoord.y = (1.0 - shadowTexCoord.y) * 0.25;

    // Bias the depth value (note, we need better depth bias settings)
    shadowTexCoord.z -= LightData[lightIndex].ShadowParams.x;

    float LinearZ = LinearizeDepth(shadowTexCoord.z, LightData[lightIndex].ShadowParams.y, LightData[lightIndex].ShadowParams.z);

    if ((shadowTexCoord.y < 0) || (shadowTexCoord.y > .5)) return 1.f;
    if ((shadowTexCoord.x < 0) || (shadowTexCoord.x > .5)) return 1.f;

    // offsets of the center of the shadow map atlas
    float offsetsX[4] = { 0.0, 1.0, 0.0, 1.0 };
    float offsetsY[4] = { 0.0, 0.0, 1.0, 1.0 };
    shadowTexCoord.x += offsetsX[LightData[lightIndex].ShadowMapIndex] * .5;
    shadowTexCoord.y += offsetsY[LightData[lightIndex].ShadowMapIndex] * .5;

    // Sample shadow map
    float shadow = 0.0;

    static const int kernelLevel = 2;
    static const int kernelWidth = 2 * kernelLevel + 1;
    [unroll] for (int i = -kernelLevel; i <= kernelLevel; i++)
    {
        [unroll] for (int j = -kernelLevel; j <= kernelLevel; j++)
        {
            float distToLight = ShadowTexture.Sample(LinearWrapSampler, shadowTexCoord.xy, int2(i, j)).r;
            float LinearSample = LinearizeDepth(distToLight, LightData[lightIndex].ShadowParams.y, LightData[lightIndex].ShadowParams.z);
            bool isLit = UseDepthApproximation ? LinearZ < LinearSample : shadowTexCoord.z < distToLight;

            if (isLit)
                shadow += 1.f;
            else
            {
                shadow += UseDepthApproximation ? ComputeShadowAttenuation(LinearZ - LinearSample, params.m_fiberSpacing, params.m_fiberRadius, params.m_hairShadowAlpha) : 0.f;
            }
        }
    }

    // Average the values according to number of samples
    shadow /= (kernelWidth * kernelWidth);
    
    return shadow;
}
*/
float3 AccumulateHairLight(float3 vTangent, float3 vPositionWS, float3 vViewDirWS, in HairShadeParams params, float3 vNDC)
{
    // Initialize information needed for all lights
    float3 V = normalize(vViewDirWS);
    float3 T = normalize(vTangent);

    float3 color = float3(0.0, 0.0, 0.0);

    float3 lightPosWSVec[2] = {
        float3(4, -1, 2),
        g_vEye.xyz // + float3(0,0,0.2)    // camera light located a bit above the camera.
    };

    // Right now we fake two lights - one is fixed and the other one 
    // is at to the camera and moving with it.
    for (int l = 0; l < 2; l++)
    {
        float3 lightPosWS = lightPosWSVec[l];
        float3 LightVector = normalize( vPositionWS - lightPosWS );
        float3 lightColor = float3(1.0, 1.0, 1.0);
        float lightIntensity = 0.5;

        // [To Do] Adi: first render - simply output the hair color
    //    return params.m_color;
    /*
        float LightIntensity;

        // Start with non-shadowed lights
        uint lightCount = min(NumLights, AMD_TRESSFX_MAX_LIGHTS);
        for (uint i = 0; i < lightCount; i++)
        {
            GetLightParams(vPositionWS, i, LightVector, LightIntensity, params);

            if (LightIntensity)
            {
                // Compute shadow term (if we've got one)
                float fShadowTerm = ComputeLightShadow(i, vPositionWS, params);

                if (fShadowTerm > 0.f)
                {
    */
                    float3 L = LightVector;
                    float3 LightColor = lightColor; 
    // [To Do] Adi: put this back               float3 LightColor =  LightData[i].LightColor;

                    float3 reflection = ComputeDiffuseSpecFactors(V, L, T, params);
                    float3 ReflectedLight = reflection.x * LightColor * params.m_color;
                    ReflectedLight += reflection.y * LightColor;
                    ReflectedLight += reflection.z * LightColor * params.m_color;

                    ReflectedLight *= lightIntensity;
    // [To Do] Adi: put this back                ReflectedLight *= fShadowTerm * LightIntensity;

                    color += max(float3(0, 0, 0), ReflectedLight);

    //            }
     //       }
     //   }
    }



 //               return params.m_color;  // OK
                return color;
}

float3 SimplifiedHairLighting(float3 vTangent, float3 vPositionWS, float3 vViewDirWS, in HairShadeParams params, float3 vNDC)
{
    // Initialize information needed for all lights
    float3 V = normalize(vViewDirWS);
    float3 T = normalize(vTangent);

    float3 accumulatedHairColor = float3(0.0, 0.0, 0.0);

    float4 lightPosWSVec[2] = {
        float4(-.5, 0, 0.5, .75),
        float4(.5, 0, 0.5, .75),
    };

    float3 lightColorVec[2] = {
        float3(1,1,1),
        float3(1,1,1)
    };

    // Right now we fake two lights - one is fixed and the other one 
    // is at to the camera and moving with it.
    for (int l = 0; l < 2; l++)
    {
        float3 lightPosWS = lightPosWSVec[l].xyz;
        float3 LightVector = normalize( vPositionWS - lightPosWS );
        float lightIntensity = lightPosWSVec[l].w;
        float3 LightColor = lightColorVec[l]; 

        float3 L = LightVector;

        float3 lightSurfaceCoeffs = ComputeDiffuseSpecFactors(V, L, T, params);
        float3 diffuseCompoenent = lightSurfaceCoeffs.x * params.m_color;
        float3 specularAtPos = lightSurfaceCoeffs.y;
        float3 specularAtBase = lightSurfaceCoeffs.z* params.m_color;  // [To Do] Adi: why is specualr taking the base color?
        float3 curHairColor = (diffuseCompoenent + specularAtPos + specularAtBase) * lightIntensity * LightColor;
 
        accumulatedHairColor += saturate(curHairColor);
    }
    return accumulatedHairColor;
}

//==============================================================================
//                             Atom Lighting
//==============================================================================
#include <Atom/Features/Shadow/DirectionalLightShadow.azsli>
#include <HairLightTypes.azsli>
//------------------------------------------------------------------------------

float3 CalculateLighting( 
    float4 screenCoords,    // XY - screen coords 0..max pix res, Z - depth 0..1
    float3 vPositionWS, float3 vViewDirWS, float3 vTangent, 
    float thickness, in HairShadeParams material )
{    
    //-------- Surface init --------
    Surface surface;

    const float specularF0Factor = 0.04f; // set this to 0.04?!

    surface.position = vPositionWS;
    surface.tangent = vTangent;         // Redundant - will be calculated per light
    surface.normal = float3(0, 0, 0);   // Will fail lights that did not initialize properly. 
    surface.roughnessLinear = material.m_Ex1;// 0.50f;
    surface.cuticleTilt = material.m_Ks1;// 0.08715;
    surface.thickness = thickness;
    surface.CalculateRoughnessA();
    surface.SetAlbedoAndSpecularF0(material.m_color, specularF0Factor);

    // The trasmission / back lighting does not seem to work!
    surface.transmission.InitializeToZero();    // Assuming thin layer
    surface.transmission.tint = material.m_color;
    surface.transmission.thickness = 0.001;     // 1 mm settings
    surface.transmission.transmissionParams = float4(1.0, 1.0, 1.0, 32.0);  // for thin surface XYZ are partials * W that is the exponent mult

    //------- LightingData init -------
    LightingData lightingData;

    float4 screenPositionForLighting = mul(ViewSrg::m_viewProjectionMatrix, float4(vPositionWS, 1.0));
    uint2 dimensions;
    PassSrg::m_linearDepth.GetDimensions(dimensions.x, dimensions.y);
    screenPositionForLighting.y = 1.0 - screenPositionForLighting.y;
    screenPositionForLighting.xy = (screenPositionForLighting.xy * 0.5 + 0.5) * dimensions;
//    screenPositionForLighting.xyz = screenPosNDC; // no go

    // Light iterator
    // screenPositionForLighting.xy in the iterator init should be in XY pixel location on screen (based on LightCullingShared)
    // screenPositionForLighting.z should be depth 0..1 (or reverse Z in our case).
    uint tileWidth, tileHeight;     // GOOD acording to RenderDoc dimensions
    uint2 tileId;
    uint bin;

//    lightingData.tileIterator.TestInit(
//        screenPositionForLighting, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData,
//        tileWidth, tileHeight, tileId, bin
//    );

    lightingData.tileIterator.TestInit(
        screenCoords, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData,
        tileWidth, tileHeight, tileId, bin
    );
//    lightingData.tileIterator.Init(screenCoords, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
//    lightingData.tileIterator.Init(screenPositionForLighting, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData); // DOES NOT work!! requires pixels coords

    // The normal assignment will be overriden afterwards per light
    lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);

    // Remark: all indices were checked out ok with the exception of the bin 
    // that seems to always be 0.  Need to verify that we are running on the correct 
    // light array.
//    return float3(tileWidth / 103.0, 0, 0);
//    return float3(0, tileHeight/75.0, 0);
//    return float3(float(tileId.x) / float(tileWidth), 0, 0);
//    return float3(0, float(tileId.y) / float(tileHeight), 0);
//    return float3(float(tileId.x) / float(tileWidth), float(tileId.y) / float(tileHeight), 0);
//    return float3(0, float(bin), 0);
//    return float3(0, float(bin) / NVLC_MAX_BINS, 0);

    ApplyLighting(surface, lightingData);

    return lightingData.diffuseLighting + lightingData.specularLighting;// + lightingData.translucentBackLighting;
}

float3 TressFXShading(float2 pixelCoord, float depth, float3 vTangentCoverage, float3 baseColor, float thickness, int shaderParamIndex)
{
    float3 vNDC;    // normalized device / screen coordinates: [-1..1, -1..1, 0..1]
    float3 vPositionWS = ScreenPosToWorldPos(PassSrg::m_linearDepth, pixelCoord, depth, vNDC);

    // [To Do] Adi: the follwing two lines are a hack to make the tile lighting work for now
    #define _BIG_HACK_FOR_TESTING_ 1//32
    float4 screenCoords = float4( _BIG_HACK_FOR_TESTING_ * pixelCoord, depth, depth);   // screen space position - XY in pixels - ZW are depth 0..1

    float3 vViewDirWS = g_vEye - vPositionWS;

    // Need to expand the tangent that was compressed to store in the buffer
    float3 vTangent = normalize(vTangentCoverage.xyz * 2.f - 1.f);

    //---- TressFX original lighting params setting ----
    HairShadeParams params;
    params.m_color = baseColor;
    params.m_hairShadowAlpha = HairParams[shaderParamIndex].m_shadowAlpha;
    params.m_fiberRadius = HairParams[shaderParamIndex].m_fiberRadius;
    params.m_fiberSpacing = HairParams[shaderParamIndex].m_fiberSpacing;

    params.m_Ka = HairParams[shaderParamIndex].m_matKValue.x;
    params.m_Kd = HairParams[shaderParamIndex].m_matKValue.y;
    params.m_Ks1 = HairParams[shaderParamIndex].m_matKValue.z;
    params.m_Ex1 = HairParams[shaderParamIndex].m_matKValue.w;
    params.m_Ks2 = HairParams[shaderParamIndex].m_hairKs2;
    params.m_Ex2 = HairParams[shaderParamIndex].m_hairEx2;
    //---------------------------------------------------

    return CalculateLighting(screenCoords, vPositionWS, vViewDirWS, vTangent, thickness, params);
    return SimplifiedHairLighting(vTangent, vPositionWS, vViewDirWS, params, vNDC);    
    return AccumulateHairLight(vTangent, vPositionWS, vViewDirWS, params, vNDC);
}
