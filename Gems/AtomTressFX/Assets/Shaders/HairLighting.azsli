/*
 * Modifications Copyright (c) Contributors to the Open 3D Engine Project. 
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 * 
 * SPDX-License-Identifier: (Apache-2.0 OR MIT) AND MIT
 *
 */
 
//------------------------------------------------------------------------------
// Shader code related to lighting and shadowing for TressFX
//------------------------------------------------------------------------------
//
// Copyright (c) 2019 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#pragma once

#include <HairUtilities.azsli>
//------------------------------------------------------------------------------
struct HairShadeParams
{
    float3 m_color;
    float m_hairShadowAlpha;
    float m_fiberRadius;
    float m_fiberSpacing;

    // Original TressFX Kajiya lighting model parameters
    float m_Ka;
    float m_Kd;
    float m_Ks1;
    float m_Ex1;
    float m_Ks2;
    float m_Ex2;

    // MArschner lighting model parameters
    float m_cuticleTilt;
    float m_roughness;
};

// Returns a float3 which is the scale for diffuse, spec term, and colored spec term.
//
// The diffuse term is from Kajiya.
// 
// The spec term is what Marschner calls "R", reflecting directly off the surface of the hair, 
// taking the color of the light like a dielectric specular term.  This highlight is shifted 
// towards the root of the hair.
//
// The colored spec term is caused by light passing through the hair, bouncing off the back, and 
// coming back out.  It therefore picks up the color of the light.  
// Marschner refers to this term as the "TRT" term.  This highlight is shifted towards the 
// tip of the hair.
//
// vEyeDir, vLightDir and vTangentDir are all pointing out.
// coneAngleRadians explained below.
//
// 
// hair has a tiled-conical shape along its lenght.  Sort of like the following.
// 
// \    /
//  \  /
// \    /
//  \  /  
//
// The angle of the cone is the last argument, in radians.  
// It's typically in the range of 5 to 10 degrees
float3 ComputeDiffuseSpecFactors(
    float3 vEyeDir, float3 vLightDir, float3 vTangentDir, HairShadeParams params, 
    float coneAngleRadians = 10 * AMD_PI / 180)
{
    // in Kajiya's model: diffuse component: sin(t, l)
    float cosTL = (dot(vTangentDir, vLightDir));
    float sinTL = sqrt(1 - cosTL * cosTL);
    float diffuse = sinTL;

    float cosTRL = -cosTL;
    float sinTRL = sinTL;
    float cosTE = (dot(vTangentDir, vEyeDir));
    float sinTE = sqrt(1 - cosTE * cosTE);

    // primary highlight: reflected direction shift towards root (2 * coneAngleRadians)
    float cosTRL_root = cosTRL * cos(2 * coneAngleRadians) - sinTRL * sin(2 * coneAngleRadians);
    float sinTRL_root = sqrt(1 - cosTRL_root * cosTRL_root);
    float specular_root = max(0, cosTRL_root * cosTE + sinTRL_root * sinTE);

    // secondary highlight: reflected direction shifted toward tip (3*coneAngleRadians)
    float cosTRL_tip = cosTRL * cos(-3 * coneAngleRadians) - sinTRL * sin(-3 * coneAngleRadians);
    float sinTRL_tip = sqrt(1 - cosTRL_tip * cosTRL_tip);
    float specular_tip = max(0, cosTRL_tip * cosTE + sinTRL_tip * sinTE);

    return float3( 
        params.m_Kd * diffuse, 
        params.m_Ks1 * pow(specular_root, params.m_Ex1), 
        params.m_Ks2 * pow(specular_tip, params.m_Ex2));
}

float LinearizeDepth(float depthNDC, float fNear, float fFar)
{
    return fNear * fFar / (fFar - depthNDC * (fFar - fNear));
}

/*
// fDepthDistanceWS is the world space distance between the point on the surface and the point in the shadow map.
// fFiberSpacing is the assumed, average, world space distance between hair fibers.
// fFiberRadius in the assumed average hair radius.
// fHairAlpha is the alpha value for the hair (in terms of translucency, not coverage.)
// Output is a number between 0 (totally shadowed) and 1 (lets everything through)
float ComputeShadowAttenuation(float fDepthDistanceWS, float fFiberSpacing, float fFiberRadius, float fHairAlpha)
{
    float numFibers = fDepthDistanceWS / (fFiberSpacing * fFiberRadius);	// fiberSpacing + fiberRadius is total distance from 1 fiber to another

    // if occluded by hair, there is at least one fiber
    [flatten] if (fDepthDistanceWS > 1e-5)
        numFibers = max(numFibers, 1);

    return pow(abs(1 - fHairAlpha), numFibers);
}

float ComputeLightShadow(int lightIndex, float3 vPositionWS, in HairShadeParams params)
{
    if (LightData[lightIndex].ShadowMapIndex < 0)
        return 1.f;
    
    float4 shadowTexCoord = MatrixMult( LightData[lightIndex].ShadowProjection, float4(vPositionWS, 1.f) );
    shadowTexCoord.xyz /= shadowTexCoord.w;

    // remember we are splitting the shadow map in 4 quarters 
    // and at this point, everything's in -1 to 1
    // So bring back to 0 -> 0.5 and flip the Y coordinate
    shadowTexCoord.x = (1.0 + shadowTexCoord.x) * 0.25;
    shadowTexCoord.y = (1.0 - shadowTexCoord.y) * 0.25;

    // Bias the depth value (note, we need better depth bias settings)
    shadowTexCoord.z -= LightData[lightIndex].ShadowParams.x;

    float LinearZ = LinearizeDepth(shadowTexCoord.z, LightData[lightIndex].ShadowParams.y, LightData[lightIndex].ShadowParams.z);

    if ((shadowTexCoord.y < 0) || (shadowTexCoord.y > .5)) return 1.f;
    if ((shadowTexCoord.x < 0) || (shadowTexCoord.x > .5)) return 1.f;

    // offsets of the center of the shadow map atlas
    float offsetsX[4] = { 0.0, 1.0, 0.0, 1.0 };
    float offsetsY[4] = { 0.0, 0.0, 1.0, 1.0 };
    shadowTexCoord.x += offsetsX[LightData[lightIndex].ShadowMapIndex] * .5;
    shadowTexCoord.y += offsetsY[LightData[lightIndex].ShadowMapIndex] * .5;

    // Sample shadow map
    float shadow = 0.0;

    static const int kernelLevel = 2;
    static const int kernelWidth = 2 * kernelLevel + 1;
    [unroll] for (int i = -kernelLevel; i <= kernelLevel; i++)
    {
        [unroll] for (int j = -kernelLevel; j <= kernelLevel; j++)
        {
            float distToLight = ShadowTexture.Sample(LinearWrapSampler, shadowTexCoord.xy, int2(i, j)).r;
            float LinearSample = LinearizeDepth(distToLight, LightData[lightIndex].ShadowParams.y, LightData[lightIndex].ShadowParams.z);
            bool isLit = UseDepthApproximation ? LinearZ < LinearSample : shadowTexCoord.z < distToLight;

            if (isLit)
                shadow += 1.f;
            else
            {
                shadow += UseDepthApproximation ? ComputeShadowAttenuation(LinearZ - LinearSample, params.m_fiberSpacing, params.m_fiberRadius, params.m_hairShadowAlpha) : 0.f;
            }
        }
    }

    // Average the values according to number of samples
    shadow /= (kernelWidth * kernelWidth);
    
    return shadow;
}
*/

#define DEMO_NUMBER_OF_LIGHTS 3
#define DEMO_NUMBER_OF_LIGHTS 3
float3 SimplifiedHairLighting(float3 vTangent, float3 vPositionWS, float3 vViewDirWS, in HairShadeParams params, float3 vNDC)
{
    // Initialize information needed for all lights
    float3 V = normalize(vViewDirWS);
    float3 T = normalize(vTangent);

    float3 accumulatedHairColor = float3(0.0, 0.0, 0.0);

    float4 lightPosWSVec[DEMO_NUMBER_OF_LIGHTS] = {
        float4(3, 0, 3, 1.5f),  // Sun
        float4(-.5, 0, 0.5, .5f),
        float4(.5, 0, 0.5, .5f),
    };

    float3 lightColorVec[DEMO_NUMBER_OF_LIGHTS] = {
        float3(1,1,.95f),        // Sun
        float3(1,1,1),
        float3(1,1,1)
    };

    // Fake static lights not connected to Atom
    // [To Do] - connect to Atom lighting ala HairLightTypes loop
    for (int l = 0; l < DEMO_NUMBER_OF_LIGHTS ; l++)
    {
        float3 lightPosWS = lightPosWSVec[l].xyz;
        float3 LightVector = normalize( vPositionWS - lightPosWS );
        float lightIntensity = lightPosWSVec[l].w;
        float3 LightColor = lightColorVec[l]; 
        float3 L = LightVector;

//        float shadowTerm = ComputeLightShadow(l, vPositionWS, params);
//        if (shadowTerm <= 0.f)
//              continue;

        float3 lightSurfaceCoeffs = ComputeDiffuseSpecFactors(V, L, T, params);

        // The diffuse coefficient here is a rough approximation as per the Kajiya model 
        float3 diffuseCompoenent = lightSurfaceCoeffs.x * params.m_color;

        // This is the approximation to Marschner R but azimuthal only
        float3 specularAtPos = lightSurfaceCoeffs.y;    

        // This is the approximation to Marschner TRT but azimuthal only
        // Notice the base color gather due to the trsmittance within the hair
        float3 specularAtBase = lightSurfaceCoeffs.z * params.m_color;

        // Final result
        float3 lightContribution = (diffuseCompoenent + specularAtPos + specularAtBase) * lightIntensity * LightColor; // * shadowTerm;
 
        accumulatedHairColor += max(float3(0, 0, 0), lightContribution );
    }
    return accumulatedHairColor;
}

//==============================================================================
//                             Atom Lighting
//==============================================================================
#include <Atom/Features/Shadow/DirectionalLightShadow.azsli>
#include <HairLightTypes.azsli>
//------------------------------------------------------------------------------

float3 CalculateLighting( 
    float4 screenCoords,    // XY - screen coords 0..max pix res, Z - depth 0..1
    float3 vPositionWS, float3 vViewDirWS, float3 vTangent, 
    float thickness, in HairShadeParams material )
{    
    //-------- Surface init --------
    Surface surface;

    const float specularF0Factor = 0.04f; // set this to 0.04?!

    surface.position = vPositionWS;
    surface.tangent = vTangent;         // Redundant - will be calculated per light
    surface.normal = float3(0, 0, 0);   // Will fail lights that did not initialize properly. 
    surface.roughnessLinear = material.m_roughness;
    surface.cuticleTilt = material.m_cuticleTilt;
    surface.thickness = thickness;
    surface.CalculateRoughnessA();
    surface.SetAlbedoAndSpecularF0( material.m_color, specularF0Factor);

    // The trasmission / back lighting does not seem to work!
    surface.transmission.InitializeToZero();    // Assuming thin layer
    surface.transmission.tint = material.m_color;
    surface.transmission.thickness = 0.001;     // 1 mm settings
    surface.transmission.transmissionParams = float4(1.0, 1.0, 1.0, 32.0);  // for thin surface XYZ are partials * W that is the exponent mult

    //------- LightingData init -------
    LightingData lightingData;

    float4 screenPositionForLighting = mul(ViewSrg::m_viewProjectionMatrix, float4(vPositionWS, 1.0));
    uint2 dimensions;
    PassSrg::m_linearDepth.GetDimensions(dimensions.x, dimensions.y);
    screenPositionForLighting.y = 1.0 - screenPositionForLighting.y;
    screenPositionForLighting.xy = (screenPositionForLighting.xy * 0.5 + 0.5) * dimensions;
//    screenPositionForLighting.xyz = screenPosNDC; // no go

    // Light iterator
    // screenPositionForLighting.xy in the iterator init should be in XY pixel location on screen (based on LightCullingShared)
    // screenPositionForLighting.z should be depth 0..1 (or reverse Z in our case).
    uint tileWidth, tileHeight;     // GOOD acording to RenderDoc dimensions
    uint2 tileId;
    uint bin;

//    lightingData.tileIterator.TestInit(
//        screenPositionForLighting, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData,
//        tileWidth, tileHeight, tileId, bin
//    );

    lightingData.tileIterator.TestInit(
        screenCoords, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData,
        tileWidth, tileHeight, tileId, bin
    );
//    lightingData.tileIterator.Init(screenCoords, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
//    lightingData.tileIterator.Init(screenPositionForLighting, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData); // DOES NOT work!! requires pixels coords

    // The normal assignment will be overriden afterwards per light
    lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);

    // Remark: all indices were checked out ok with the exception of the bin 
    // that seems to always be 0.  Need to verify that we are running on the correct 
    // light array.
//    return float3(tileWidth / 103.0, 0, 0);
//    return float3(0, tileHeight/75.0, 0);
//    return float3(float(tileId.x) / float(tileWidth), 0, 0);
//    return float3(0, float(tileId.y) / float(tileHeight), 0);
//    return float3(float(tileId.x) / float(tileWidth), float(tileId.y) / float(tileHeight), 0);
//    return float3(0, float(bin), 0);
//    return float3(0, float(bin) / NVLC_MAX_BINS, 0);

    ApplyLighting(surface, lightingData);

    return lightingData.diffuseLighting + lightingData.specularLighting;// + lightingData.translucentBackLighting;
}

float3 TressFXShading(float2 pixelCoord, float depth, float3 vTangentCoverage, float3 baseColor, float thickness, int shaderParamIndex)
{
    float3 vNDC;    // normalized device / screen coordinates: [-1..1, -1..1, 0..1]
    float3 vPositionWS = ScreenPosToWorldPos(PassSrg::m_linearDepth, pixelCoord, depth, vNDC);

    // [To Do] the follwing two lines are a hack to make the tile lighting work for now
    #define _BIG_HACK_FOR_TESTING_ 1//32
    float4 screenCoords = float4( _BIG_HACK_FOR_TESTING_ * pixelCoord, depth, depth);   // screen space position - XY in pixels - ZW are depth 0..1

    float3 vViewDirWS = g_vEye - vPositionWS;

    // Need to expand the tangent that was compressed to store in the buffer
    float3 vTangent = normalize(vTangentCoverage.xyz * 2.f - 1.f);

    //---- TressFX original lighting params setting ----
    HairShadeParams params;
    params.m_color = baseColor;
    params.m_hairShadowAlpha = HairParams[shaderParamIndex].m_shadowAlpha;
    params.m_fiberRadius = HairParams[shaderParamIndex].m_fiberRadius;
    params.m_fiberSpacing = HairParams[shaderParamIndex].m_fiberSpacing;

    params.m_Ka = HairParams[shaderParamIndex].m_matKValue.x;
    params.m_Kd = HairParams[shaderParamIndex].m_matKValue.y;
    params.m_Ks1 = HairParams[shaderParamIndex].m_matKValue.z;
    params.m_Ex1 = HairParams[shaderParamIndex].m_matKValue.w;
    params.m_Ks2 = HairParams[shaderParamIndex].m_hairKs2;
    params.m_Ex2 = HairParams[shaderParamIndex].m_hairEx2;

    params.m_cuticleTilt = HairParams[shaderParamIndex].m_cuticleTilt;
    params.m_roughness = HairParams[shaderParamIndex].m_roughness;
    //---------------------------------------------------

    float3 accumulatedLight = float3(0, 0, 1);
    if (o_hairLightingModel == HairLightingModel::Kajiya)
    {
        accumulatedLight = SimplifiedHairLighting(vTangent, vPositionWS, vViewDirWS, params, vNDC);    
//        accumulatedLight = AccumulateHairLight(vTangent, vPositionWS, vViewDirWS, params, vNDC);
    }
    else
    {
        accumulatedLight = CalculateLighting(screenCoords, vPositionWS, vViewDirWS, vTangent, thickness, params);
    }
    return accumulatedLight;
}
