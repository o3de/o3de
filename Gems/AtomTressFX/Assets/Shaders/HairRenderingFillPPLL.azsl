//---------------------------------------------------------------------------------------
// Shader code related to per-pixel linked lists.
//-------------------------------------------------------------------------------------
//
// Copyright (c) 2019 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

#include <HairStrands.azsli>

//! Hair input structure to Pixel shaders
struct PS_INPUT_HAIR
{
    float4 Position    : SV_POSITION;
    float4 Tangent     : Tangent;
    float4 p0p1        : TEXCOORD0;
    float4 StrandColor : TEXCOORD1;
};

//////////////////////////////////////////////////////////////
//! Hair Render VS 
PS_INPUT_HAIR RenderHairVS(uint vertexId : SV_VertexID)
{
    TressFXVertex tressfxVert = GetExpandedTressFXVert(vertexId, g_vEye.xyz, g_vViewport.zw, g_mVP);

//    tressfxVert.Position = float4(
//        (vertexId / 3) * 0.1 + (vertexId % 2) * 0.1,
//        ((vertexId / 2) % 2) * 0.1,
//        saturate((vertexId / 3) * 0.01),
//        1.0
//    );

    PS_INPUT_HAIR Output;

    Output.Position = tressfxVert.Position;
    Output.Tangent = tressfxVert.Tangent;
    Output.p0p1 = tressfxVert.p0p1;
    Output.StrandColor = tressfxVert.StrandColor;

    return Output;
}

// Allocate a new fragment location in fragment color, depth, and link buffers
int AllocateFragment(int2 vScreenAddress)
{
    uint newAddress;
    InterlockedAdd(LinkedListCounter[0], 1, newAddress);

    if (newAddress < 0 || newAddress >= NodePoolSize)
        newAddress = FRAGMENT_LIST_NULL;
    return newAddress;
}

// Insert a new fragment at the head of the list. The old list head becomes the
// the second fragment in the list and so on. Return the address of the *old* head.
int MakeFragmentLink(int2 vScreenAddress, int nNewHeadAddress)
{
    int nOldHeadAddress;
    InterlockedExchange(RWFragmentListHead[vScreenAddress], nNewHeadAddress, nOldHeadAddress);
    return nOldHeadAddress;
}

// Write fragment attributes to list location. 
void WriteFragmentAttributes(int nAddress, int nPreviousLink, float4 vData, float3 vColor3, float fDepth)
{
    PPLL_STRUCT element;
    element.data = PackFloat4IntoUint(vData);
    element.color = PackFloat3ByteIntoUint(vColor3, RenderParamsIndex);
    element.depth = asuint(saturate(fDepth));
    element.uNext = nPreviousLink;
    LinkedListUAV[nAddress] = element;
}


struct PSOutput
{
    float4 m_color : SV_Target0;
//    float m_depth : SV_Depth;
};


//////////////////////////////////////////////////////////////
// PPLL Fill PS
// First pass of PPLL implementation
// Builds up the linked list of hair fragments
[earlydepthstencil]
//PSOutput PPLLFillPS(PS_INPUT_HAIR input)
void PPLLFillPS(PS_INPUT_HAIR input)
{
    PSOutput pixelOut;

    // Strand Color read in is either the BaseMatColor, or BaseMatColor modulated with a color read from texture on vertex shader for base color;
    //along with modulation by the tip color  
    float4 strandColor = float4(input.StrandColor.rgb, MatBaseColor.a);

    // Grab the uv in case we need it
    float2 uv = float2(input.Tangent.w, input.StrandColor.w);

    // Apply StrandUVTiling
    // strandUV.y = (uv.y * StrandUVTilingFactor) % 1.f
    float2 strandUV = float2(uv.x, (uv.y * StrandUVTilingFactor) - floor(uv.y * StrandUVTilingFactor));

    // If we are supporting strand UV texturing, further blend in the texture color/alpha
    // Do this while computing NDC and coverage to hide latency from texture lookup
    if (EnableStrandUV)
    {
        strandColor.rgb *= StrandAlbedoTexture.Sample(LinearWrapSampler, strandUV).rgb;
    }

    float3 vNDC = ScreenPosToNDC(input.Position.xyz, g_vViewport);

    //////////////////////////////////////////////////////////////////////
    float coverage = 1.0;  
    // [To Do] Adi: adibugbug - put back once View CB calc checks out   ComputeCoverage(input.p0p1.xy, input.p0p1.zw, vNDC.xy, g_vViewport.zw - g_vViewport.xy);
//    float coverage = ComputeCoverage(input.p0p1.xy, input.p0p1.zw, vNDC.xy, float2(1600,1600));
//    float coverage = ComputeCoverage(input.p0p1.xy, input.p0p1.zw, vNDC.xy, g_vViewport.zw - g_vViewport.xy);
    /// //////////////////////////////////////////////////////////////////

    float3 vPositionWS = NDCToWorld(vNDC, ViewSrg::m_viewProjectionInverseMatrix);
    float alpha = coverage;

    // Update the alpha to have proper value (accounting for coverage, base alpha, and strand alpha)
    alpha *= strandColor.w;

    // Early out
    if (alpha < 1.f / 255.f)
    {
        discard;
    }

    // Get the screen address
    int2 vScreenAddress = int2(input.Position.xy);

    // Allocate a new fragment
    int nNewFragmentAddress = AllocateFragment(vScreenAddress);

    int nOldFragmentAddress = MakeFragmentLink(vScreenAddress, nNewFragmentAddress);
    WriteFragmentAttributes(nNewFragmentAddress, nOldFragmentAddress, 
        float4(input.Tangent.xyz * 0.5 + float3(0.5, 0.5, 0.5), alpha), 
        strandColor.xyz, 
        input.Position.z
    );

//    pixelOut.m_depth = input.Position.z;
//    pixelOut.m_color = float4(input.Position.z, input.Position.z, input.Position.z, 1);// .2);
//    pixelOut.m_color = float4(1, 0, 1, 0.5 + 0.5 * alpha);// .001);
//    discard;

//    return pixelOut;
}
