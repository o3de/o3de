
/*
 * Copyright (c) Contributors to the Open 3D Engine Project. For complete copyright and license terms please see the LICENSE at the root of this distribution.
 * 
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <Atom/Features/SrgSemantics.azsli>
#include <viewsrg.srgi>

struct VertexInput
{
    float2 Position : POSITION;
    float2 UV : UV;
};

struct VertexOutput
{
    float4 Position : SV_Position;
    float2 UV : UV;
};

ShaderResourceGroup ObjectSrg : SRG_PerObject
{
    Texture2D<float4> HeightmapImage;
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };
    
    row_major float3x4 m_modelToWorld;
    float m_heightScale;
    float2 m_uvMin;
    float2 m_uvMax;
}

float4x4 GetObject_WorldMatrix()
{
    float4x4 modelToWorld = float4x4(
        float4(1, 0, 0, 0),
        float4(0, 1, 0, 0),
        float4(0, 0, 1, 0),
        float4(0, 0, 0, 1));

    modelToWorld[0] = ObjectSrg::m_modelToWorld[0];
    modelToWorld[1] = ObjectSrg::m_modelToWorld[1];
    modelToWorld[2] = ObjectSrg::m_modelToWorld[2];
    return modelToWorld;
}

VertexOutput MainVS(in VertexInput input)
{
    VertexOutput output;

    // Clamp the UVs *after* lerping to ensure that everything aligns properly right to the edge.
    // We use out-of-bounds UV values to denote vertices that need to be removed.
    float2 origUv = lerp(ObjectSrg::m_uvMin, ObjectSrg::m_uvMax, input.UV);
    float2 uv = clamp(origUv, 0.0f, 1.0f);

    // Loop up the height and calculate our final position.
    float height = ObjectSrg::m_heightScale * (ObjectSrg::HeightmapImage.SampleLevel(ObjectSrg::LinearSampler, uv, 0).r - 0.5f);
    float3 worldPosition = mul(GetObject_WorldMatrix(), float4(input.Position, height, 1.0f)).xyz;
    output.Position = mul(ViewSrg::m_viewProjectionMatrix, float4(worldPosition, 1.0f));

    // Remove all vertices outside our bounds by turning them into NaN positions.
    output.Position = output.Position / ((origUv.x >= 0.0f && origUv.x <= 1.0f && origUv.y >= 0.0f && origUv.y <= 1.0f) ? 1.0f : 0.0f);

    output.UV = uv;
    return output;
}

struct PixelOutput
{
     float4 m_color : SV_Target0;
};  
    
PixelOutput MainPS(in VertexOutput input)
{
    PixelOutput output;
    float height = ObjectSrg::HeightmapImage.Sample(ObjectSrg::LinearSampler, input.UV).r;
    output.m_color = float4(height, height, height, 1.0f);
    return output;
}