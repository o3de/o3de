/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */
#include <TerrainSrg.azsli>
#include <TerrainMaterialSrg.azsli>
#include "ClipmapComputeHelpers.azsli"
#include "TerrainDetailHelpers.azsli"

ShaderResourceGroup PassSrg : SRG_PerPass_WithFallback
{
    RWTexture2DArray<float4> m_macroColorClipmaps;
    RWTexture2DArray<float4> m_macroNormalClipmaps;
    RWTexture2DArray<float4> m_detailColorClipmaps;
    RWTexture2DArray<float4> m_detailNormalClipmaps;
    RWTexture2DArray<float> m_detailHeightClipmaps;
    RWTexture2DArray<float4> m_detailMiscClipmaps;
}

void SampleMacroTexture(float2 worldPosition, uint clipmapLevel, out float3 macroColor, out float3 macroNormal)
{
    uint2 macroGridResolution = uint2(TerrainSrg::m_macroMaterialGrid.m_resolution >> 16, TerrainSrg::m_macroMaterialGrid.m_resolution & 0xFFFF);
    float macroTileSize = TerrainSrg::m_macroMaterialGrid.m_tileSize;
    float2 macroGridOffset = TerrainSrg::m_macroMaterialGrid.m_offset;
    uint2 macroGridPosition = (worldPosition - macroGridOffset) / macroTileSize;

    uint macroTileIndex = macroGridResolution.x * macroGridPosition.y + macroGridPosition.x;
    static const uint NumMacroMaterialsPerTile = 4;
    macroTileIndex *= NumMacroMaterialsPerTile;


    for (uint i = 0; i < NumMacroMaterialsPerTile; ++i)
    {
        TerrainSrg::MacroMaterialData macroMaterialData = TerrainSrg::m_macroMaterialData[macroTileIndex + i];
        if ((macroMaterialData.m_flags & 1) == 0)
        {
            break; // No more macro materials for this tile
        }

        if (any(worldPosition < macroMaterialData.m_boundsMin.xy) || any(worldPosition > macroMaterialData.m_boundsMax.xy))
        {
            continue; // Macro material exists for this tile but is out of the bounds of this particular position
        }

        float2 macroUvSize = macroMaterialData.m_boundsMax - macroMaterialData.m_boundsMin;
        macroUvSize.x = -1.0 / macroUvSize.x;
        macroUvSize.y = 1.0 / macroUvSize.y;
        float2 macroUv = (macroMaterialData.m_boundsMin - worldPosition) * macroUvSize;

        // The macro uv gradient can vary massively over the quad because different pixels may choose different macro materials with different UVs.
        // To fix, we use the world position scaled by the macro uv scale which should be fairly uniform across macro materials.
        float2 ddx_macroUv = ddxPosition(clipmapLevel) * macroUvSize;
        float2 ddy_macroUv = ddyPosition(clipmapLevel) * macroUvSize;

        if (macroMaterialData.m_colorMapId != 0xFFFF)
        {
            macroColor = TerrainSrg::m_textures[macroMaterialData.m_colorMapId].SampleGrad(TerrainMaterialSrg::m_sampler, macroUv, ddx_macroUv, ddy_macroUv).rgb;
            macroColor = TransformColor(macroColor, ColorSpaceId::LinearSRGB, ColorSpaceId::ACEScg);
        }
        else
        {
            macroColor = TerrainMaterialSrg::m_baseColor.rgb;
        }

        if (macroMaterialData.m_normalMapId != 0xFFFF)
        {
            bool flipX = macroMaterialData.m_flags & 2;
            bool flipY = macroMaterialData.m_flags & 4;
            float2 sampledValue = TerrainSrg::m_textures[macroMaterialData.m_normalMapId][macroUv].xy;
            if(flipX)
            {
                sampledValue.y = -sampledValue.y;
            }
            if(flipY)
            {
                sampledValue.x = -sampledValue.x;
            }
            macroNormal = normalize(GetTangentSpaceNormal_Unnormalized(sampledValue, macroMaterialData.m_normalFactor));
        }
        else
        {
            macroNormal = float3(0.0, 0.0, 1.0);
        }

        break;
    }
}

[numthreads(32,32,1)]
void MainCS(
    uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint2 pixelPosition = dispatchThreadID.xy;

    for (uint clipmapLevel = 0; clipmapLevel < ClipmapStackSize; ++clipmapLevel)
    {
        float2 worldPosition = GetCurrentWorldPosition(pixelPosition, clipmapLevel);
        if (any(worldPosition < TerrainSrg::m_clipmapData.m_worldBounds.xy) || any(worldPosition > TerrainSrg::m_clipmapData.m_worldBounds.zw))
        {
            PassSrg::m_macroColorClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(TerrainMaterialSrg::m_baseColor.rgb, 1.0);
            PassSrg::m_macroNormalClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(0.0, 0.0, 1.0, 1.0);
            PassSrg::m_detailColorClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(TerrainMaterialSrg::m_baseColor.rgb, 0.0);
            PassSrg::m_detailNormalClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(0.0, 0.0, 1.0, 1.0);
            PassSrg::m_detailHeightClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = 0.0;
            PassSrg::m_detailMiscClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(0.0, 0.0, 0.0, 0.0);
            continue;
        }

        float3 macroColor;
        float3 macroNormal;
        SampleMacroTexture(worldPosition, clipmapLevel, macroColor, macroNormal);

        PassSrg::m_macroColorClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(macroColor, 1.0);
        PassSrg::m_macroNormalClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(macroNormal, 1.0);

        DetailSurface detailSurface;
        float2 detailRegionCoord = worldPosition * TerrainSrg::m_detailMaterialIdScale;
        float2 detailUv = worldPosition * TerrainMaterialSrg::m_detailTextureMultiplier;
        float2 detailUvDdx = ddxPosition(clipmapLevel) * TerrainMaterialSrg::m_detailTextureMultiplier;
        float2 detailUvDdy = ddyPosition(clipmapLevel) * TerrainMaterialSrg::m_detailTextureMultiplier;
        bool hasDetailSurface = GetDetailSurface(detailSurface, detailRegionCoord, detailUv, detailUvDdx, detailUvDdy, macroColor);

        if (hasDetailSurface)
        {
            PassSrg::m_detailColorClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(detailSurface.m_color, 1.0);
            PassSrg::m_detailNormalClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(detailSurface.m_normal, 1.0);
            PassSrg::m_detailHeightClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = detailSurface.m_height;
            PassSrg::m_detailMiscClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(detailSurface.m_roughness, detailSurface.m_specularF0, detailSurface.m_metalness, detailSurface.m_occlusion);
        }
        else
        {
            PassSrg::m_detailColorClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(TerrainMaterialSrg::m_baseColor.rgb, 0.0);
            PassSrg::m_detailNormalClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(0.0, 0.0, 1.0, 1.0);
            PassSrg::m_detailHeightClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = 0.0;
            PassSrg::m_detailMiscClipmaps[uint3(dispatchThreadID.xy, clipmapLevel)] = float4(0.0, 0.0, 0.0, 0.0);
        }
    }
}

