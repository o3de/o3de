/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// Clipmap levels
// --------|--------------|-------- level 0 stack 0
//   ------|--------------|------   level 1 stack 1
//     ----|--------------|----     level 2 stack 2
//       --|--------------|--       level 3 stack 3
//         |--------------|         level 4 pyramid mip 0 (covers the whole map)
//         |  ----------  |         level 5 pyramid mip 1
//         |    ------    |         level 6 pyramid mip 2
//         |      --      |         level 7 pyramid mip 3

float GetClipmapScale(uint clipmapLevel)
{
    return TerrainSrg::m_clipmapData.m_clipmapScaleInv[clipmapLevel].x;
}

float2 GetPreviousClipmapCenter(uint clipmapLevel)
{
    return TerrainSrg::m_clipmapData.m_clipmapCenters[clipmapLevel].xy;
}

float2 GetCurrentClipmapCenter(uint clipmapLevel)
{
    return TerrainSrg::m_clipmapData.m_clipmapCenters[clipmapLevel].zw;
}

float2 GetWorldPosition(float2 clipmapCenter, uint2 pixelPosition, uint clipmapLevel)
{
    float2 normalizedPixelPosition = float2(float(pixelPosition.x) + 0.5, float(pixelPosition.y) + 0.5) / TerrainSrg::m_clipmapData.m_clipmapSize;

    float2 distance = normalizedPixelPosition - clipmapCenter;

    // Toroidal addressing:
    // If distance is out of the normalized range (-0.5, 0.5), meaning we need to start from the other side.
    // The logic is equivalent to a modulation. Using step function for acceleration.
    distance.x -= step(0.5, distance.x);
    distance.x += step(distance.x, -0.5);
    distance.y -= step(0.5, distance.y);
    distance.y += step(distance.y, -0.5);

    float clipmapScale = GetClipmapScale(clipmapLevel);
    float2 maxRenderSize = TerrainSrg::m_clipmapData.m_maxRenderSize.xy;
    float2 viewRelativePosition = distance * (maxRenderSize * clipmapScale);
    return TerrainSrg::m_clipmapData.m_viewPosition.zw + viewRelativePosition;
}

int2 GetPixelPosition(float2 viewRelativePosition, uint clipmapLevel)
{
    float clipmapScale = GetClipmapScale(clipmapLevel);
    float2 maxRenderSize = TerrainSrg::m_clipmapData.m_maxRenderSize.xy;
    float2 normalizedDistance = viewRelativePosition / (maxRenderSize * clipmapScale);
    float2 normalizedPixelPosition = GetCurrentClipmapCenter(clipmapLevel) + normalizedDistance;
    normalizedPixelPosition.x -= normalizedPixelPosition.x > 1.0 ? 1.0 : 0.0;
    normalizedPixelPosition.y -= normalizedPixelPosition.y > 1.0 ? 1.0 : 0.0;
    normalizedPixelPosition.x += normalizedPixelPosition.x < 0.0 ? 1.0 : 0.0;
    normalizedPixelPosition.y += normalizedPixelPosition.y < 0.0 ? 1.0 : 0.0;

    return int2(normalizedPixelPosition * TerrainSrg::m_clipmapData.m_clipmapSize);
}

float2 GetPreviousWorldPosition(uint2 pixelPosition, uint clipmapLevel)
{
    float2 previousClipmapCenter = GetPreviousClipmapCenter(clipmapLevel);
    return GetWorldPosition(previousClipmapCenter, pixelPosition, clipmapLevel);
}

float2 GetCurrentWorldPosition(uint2 pixelPosition, uint clipmapLevel)
{
    float2 currentClipmapCenter = GetCurrentClipmapCenter(clipmapLevel);
    return GetWorldPosition(currentClipmapCenter, pixelPosition, clipmapLevel);
}

float2 ddxPosition(uint clipmapLevel)
{
    float clipmapScale = GetClipmapScale(clipmapLevel);
    float2 dxdy = TerrainSrg::m_clipmapData.m_maxRenderSize / TerrainSrg::m_clipmapData.m_clipmapSize * clipmapScale;
    return float2(dxdy.x, 0.0);
}

float2 ddyPosition(uint clipmapLevel)
{
    float clipmapScale = GetClipmapScale(clipmapLevel);
    float2 dxdy = TerrainSrg::m_clipmapData.m_maxRenderSize / TerrainSrg::m_clipmapData.m_clipmapSize * clipmapScale;
    return float2(0.0, dxdy.y);
}

struct ClipmapSample
{
    float3 m_macroColor;
    float3 m_macroNormal;
    bool   m_hasDetail;
    float3 m_detailColor;
    float3 m_detailNormal;
    float  m_detailRoughness;
    float  m_detailSpecularF0;
    float  m_detailMetalness;
    float  m_detailOcclusion;
    float  m_height;
};

ClipmapSample SampleClipmap(float2 worldPosition)
{
    float2 currentViewPosition = TerrainSrg::m_clipmapData.m_viewPosition.zw;
    float2 halfMaxRenderSize = TerrainSrg::m_clipmapData.m_maxRenderSize / 2.0;
    // The top clipmap's render distance
    float2 halfMinRenderSize = halfMaxRenderSize / (float)(1u << (ClipmapStackSize - 1u));

    float2 distance = worldPosition - currentViewPosition;
    float2 clampedDistance = clamp(halfMinRenderSize, abs(distance), halfMaxRenderSize);
    float2 distanceRatio = halfMaxRenderSize / clampedDistance;
    // Due to clamping, the max result of log2 is (ClipmapStackSize - 1u), which falls into the first clipmap
    uint clipmapLevel = ClipmapStackSize - 1u - uint(floor(log2(min(distanceRatio.x, distanceRatio.y))));
    uint2 pixelPosition = GetPixelPosition(distance, clipmapLevel);
    uint3 sampleIndex = uint3(pixelPosition, clipmapLevel);

    float4 macroColor = TerrainSrg::m_macroColorClipmaps[sampleIndex];
    float4 macroNormal = TerrainSrg::m_macroNormalClipmaps[sampleIndex];
    float4 detailColor = TerrainSrg::m_detailColorClipmaps[sampleIndex];

    ClipmapSample data;
    data.m_macroColor = macroColor.rgb;
    data.m_macroNormal = macroNormal.xyz;
    data.m_hasDetail = detailColor.a > 0.5;
    if (data.m_hasDetail)
    {
        float4 detailNormal = TerrainSrg::m_detailNormalClipmaps[sampleIndex];
        float detailHeight = TerrainSrg::m_detailHeightClipmaps[sampleIndex];
        float4 detailMisc = TerrainSrg::m_detailMiscClipmaps[sampleIndex];

        data.m_detailColor = detailColor.rgb;
        data.m_detailNormal = detailNormal.xyz;
        data.m_detailRoughness = detailMisc.x;
        data.m_detailSpecularF0 = detailMisc.y;
        data.m_detailMetalness = detailMisc.z;
        data.m_detailOcclusion = detailMisc.w;
        data.m_height = detailHeight;
    }

    return data;
}
