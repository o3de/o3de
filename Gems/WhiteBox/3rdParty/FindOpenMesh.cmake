#
# Copyright (c) Contributors to the Open 3D Engine Project.
# For complete copyright and license terms please see the LICENSE at the root of this distribution.
#
# SPDX-License-Identifier: Apache-2.0 OR MIT
#
#

# Always start by checking if the target already exists.
# This prevents repeated calls but also allows the user to substitute their own 3rd party library
# if they wish to do so.

if (TARGET 3rdParty::OpenMesh)
    return()
endif()

# Variables inside a local function are scoped to the function body.
# Putting all of this inside a function lets us basically ensure that any variables set by the 
# external 3rdParty CMake file do not have any effect on the outside world.
# and allows us not to have to save and restore anything.

function(GetOpenMesh)
    # Part 1:  Where do you get the library from?  Make sure to inform the user of the source of the library and any patches applied.
    include(FetchContent)

    set(OPENMESH_GIT_REPO "https://gitlab.vci.rwth-aachen.de:9000/OpenMesh/OpenMesh.git")
    set(OPENMESH_GIT_TAG "OpenMesh-11.0")
    set(OPENMESH_GIT_PATCH "${CMAKE_CURRENT_LIST_DIR}/openmesh-o3de-11.0.patch")

    FetchContent_Declare(
            OpenMesh
            GIT_REPOSITORY ${OPENMESH_GIT_REPO}
            GIT_TAG ${OPENMESH_GIT_TAG}
            PATCH_COMMAND cmake -P "${LY_ROOT_FOLDER}/cmake/PatchIfNotAlreadyPatched.cmake" ${OPENMESH_GIT_PATCH}
    )

    # please always be really clear about what third parties your gem uses.
    message(STATUS "WhiteBox Gem uses ${OPENMESH_GIT_TAG} (BSD-3-Clause) ${OPENMESH_GIT_REPO}")
    message(STATUS "      With patch: ${OPENMESH_GIT_PATCH}")

    # Part 2: Set the build settings and trigger the actual execution of the downloaded CMakeLists.txt file

    # Note that CMAKE_ARGS does NOT WORK for FetchContent_*, only ExternalProject.
    # Thus, you must set any configuration settings here, in the scope in which you call FetchContent_MakeAvailable.

    # These settings will be applied only to the current CMake scope - so it is only worth saving and restoring values from settings
    # that may affect other targets in the same CMake scope, most likely anything "CMAKE_xxxxxxxx".
    set(OLD_LOG_LEVEL ${CMAKE_MESSAGE_LOG_LEVEL}) # save the old CMAKE_MESSAGE_LOG_LEVEL
    set(CMAKE_MESSAGE_LOG_LEVEL ERROR)   # You can comment this line out if you want to see what messages output from its CMakeLists.txt
    set(CMAKE_WARN_DEPRECATED OFF CACHE BOOL "" FORCE)

    # The rest of these are all specific settings that come from OpenMesh's CMakeLists.txt files.
    set(OPENMESH_BUILD_SHARED OFF)
    set(OPENMESH_DISABLE_INSTALL ON)
    set(OPENMESH_DOCS OFF)
    set(OPENMESH_BUILD_UNIT_TESTS OFF)
    set(DISABLE_QMAKE_BUILD ON)
    set(BUILD_APPS OFF)
    set(VCI_NO_LIBRARY_INSTALL ON)
    set(VCI_COMMON_DO_NOT_COPY_POST_BUILD ON)

    # the below line is what actualy runs its CMakeList.txt file and executes targets and so on:
    FetchContent_MakeAvailable(OpenMesh)

    set(CMAKE_MESSAGE_LOG_LEVEL ${OLD_LOG_LEVEL})
    set(CMAKE_WARN_DEPRECATED ON CACHE BOOL "" FORCE)

    # Part 3: alias any targets to 3rdParty::xxx, make sure any O3DE-specific fixups are done on the target compile options
    # generated by the above FetchContent_MakeAvailable call.  Generally, disable things like warnings-as-errors since we 
    # can't really guarantee that the 3rd party library will compile cleanly with our settings.
    set(OPENMESH_TARGETS OpenMeshCore OpenMeshTools OpenMeshCoreStatic OpenMeshToolsStatic)
    foreach(OpenMesh_Target ${OPENMESH_TARGETS})
        # OpenMesh Specific: on non-Windows platforms, it creates both a shared and a static library, and assigns them targetname
        # xxxxxxxx and xxxxxxxxStatic.  On Windows platforms, it only makes a static library, and it is called just the targetname
        # without appending Static on it.  We need to handle both cases here, so we have a "IF (NOT TARGET)" check.
        if (NOT TARGET ${OpenMesh_Target})
            continue()
        endif()
        # customize the compile options for the target, note that these defines already contain the 
        # appropriate level of visibility (PUBLIC / INTERFACE / PRIVATE) and may be blank for a given compiler.
        target_compile_options(${OpenMesh_Target}  
            ${O3DE_COMPILE_OPTION_DISABLE_WARNINGS}     # OpenMesh does not pass Warning Level 4
            ${O3DE_COMPILE_OPTION_EXPORT_SYMBOLS}       # OpenMesh requires symbols to be exported.
            ${O3DE_COMPILE_OPTION_ENABLE_EXCEPTIONS})   # OpenMesh requires Exceptions enabled in it, and things that use it
                
        # this block makes sure that in IDEs like Visual Studio, they show up in the "External" subfolder under the gem.
        get_property(this_gem_root GLOBAL PROPERTY "@GEMROOT:${gem_name}@")
        ly_get_engine_relative_source_dir(${this_gem_root} relative_this_gem_root)
        set_property(TARGET ${OpenMesh_Target} PROPERTY FOLDER "${relative_this_gem_root}/External")
    endforeach()

    # OpenMesh Specific: If the xxxxxxxStatic library exists, prefer using them over the xxxxxxx (without Static) library.
    set(OpenMesh_Primary_Target      OpenMeshCore)
    set(OpenMeshTools_Primary_Target OpenMeshTools)
    if (TARGET OpenMeshCoreStatic)
        set(OpenMesh_Primary_Target OpenMeshCoreStatic)
        set(OpenMeshTools_Primary_Target OpenMeshToolsStatic)
    endif()

    # ly_create_alias is a helper function that creates an alias target with the given name and namespace
    # However, it creates both the 3rdParty::xxxxxx and the xxxxxxx target.  
    # Most importantly, it registers the alias with the installer generator, which will try to recreate the
    # alias and target automatically for us, in the installer, which we don't want to do, since we're providing our
    # own FindOpenMesh.cmake for the installer to use.  So avoid using ly_create_alias when you have a custom find file.
    add_library(3rdParty::OpenMesh ALIAS ${OpenMesh_Primary_Target})
    add_library(3rdParty::OpenMeshTools ALIAS OpenMeshTools)

    # Part 4: Make sure things work in the Installer version of O3DE. 
    # To make it simple, we just have a premade FindOpenMesh.cmake for the installer specifically
    # that we put in a folder (cmake/3rdParty) that is already part of the search path for find_package calls in installers.
    ly_install(FILES ${CMAKE_CURRENT_LIST_DIR}/Installer/FindOpenMesh.cmake DESTINATION cmake/3rdParty)
    ly_install(FILES ${CMAKE_CURRENT_LIST_DIR}/openmesh-o3de-11.0.patch DESTINATION cmake/3rdParty)
    
    # signal that find_package(OpenMesh) has succeeded.
    # we have to set it on the PARENT_SCOPE since we're in a function 
    set(OpenMesh_FOUND TRUE PARENT_SCOPE)

endfunction()

GetOpenMesh()

# for extra safety, we'll remove the function from the global scope, so that it can't be called again.
unset(GetOpenMesh)
