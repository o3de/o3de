/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <scenesrg_all.srgi>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>

#define TILE_DIM_X 16
#define TILE_DIM_Y 16

ShaderResourceGroup PassSrg : SRG_PerPass
{
    Texture2D<float4> m_inputColor;
    Texture2D<float4> m_linearDepth;
    Texture2D<float2> m_inputVelocity;
    Texture2D<float2> m_inputTileVelocity;

    RWTexture2D<float4> m_outputColor;

    struct Constants
    {
        uint m_sampleNumber;
        float m_strength; // [0, 1)
        uint2 m_outputSize; // texture size of output
    };
    Constants m_constants;
}

float GetGradientNoise(uint2 coord)
{
    float2 uv = float2(coord);
    float f = dot(float2(0.06711056f, 0.00583715f), uv);
    return frac(52.9829189f * frac(f));
}

float2 DepthCmp(float centerDepth, float sampleDepth, float depthScale)
{
	return saturate(0.5f + float2(depthScale, -depthScale) * (sampleDepth - centerDepth));
}

float2 SpreadCmp(float offsetLen, float2 spreadLen, float pixelToSampleUnitsScale)
{
	return saturate(pixelToSampleUnitsScale * spreadLen - offsetLen + 1.0f);
}

float SampleWeight(float centerDepth, float sampleDepth, float offsetLen, float centerSpreadLen, float sampleSpreadLen, float pixelToSampleUnitsScale, float depthScale)
{
	float2 depthCmp = DepthCmp(centerDepth, sampleDepth, depthScale);
	float2 spreadCmp = SpreadCmp(offsetLen, float2(centerSpreadLen, sampleSpreadLen), pixelToSampleUnitsScale);
	return dot(depthCmp, spreadCmp);
}


uint2 ClampCoords(int2 coord){
    uint2 clampedCoords;
    clampedCoords.x = uint(clamp(coord.x, 0, PassSrg::m_constants.m_outputSize.x - 1));
    clampedCoords.y = uint(clamp(coord.y, 0, PassSrg::m_constants.m_outputSize.y - 1));
    return clampedCoords;
}

float2 ToPixelVelocity(float2 velocity){
    velocity *= float2(PassSrg::m_constants.m_outputSize);
    velocity *= PassSrg::m_constants.m_strength;
    return velocity;
}


[numthreads(TILE_DIM_X, TILE_DIM_Y, 1)]
void MainCS(
    uint3 dispatchThreadID : SV_DispatchThreadID, 
    uint3 groupID : SV_GroupID, 
    uint groupIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadID.xy;
    if (pixelCoord.x >= PassSrg::m_constants.m_outputSize.x || pixelCoord.y >= PassSrg::m_constants.m_outputSize.y)
    {
        return;
    }

    float3 color = PassSrg::m_inputColor[pixelCoord].rgb;
    PassSrg::m_outputColor[pixelCoord].rgb = color;

    float depth = PassSrg::m_linearDepth[pixelCoord].r;

    float2 tileVelocity = PassSrg::m_inputTileVelocity[pixelCoord / uint2(20, 20)];
    tileVelocity = ToPixelVelocity(tileVelocity);
    float tileVelocityLength = length(tileVelocity);

    // Omit effect for velocities that are too small
    if (tileVelocityLength < 1){
        return;
    }

    // Calculate noise to make it look better with less samples per pixel
	float noise = GetGradientNoise(pixelCoord);

    int2 ditherCoord = int2(pixelCoord.x % 2, pixelCoord.y % 2);
    float samplingDither = (-0.25 + 2.0 * 0.25 * ditherCoord.x) * (-1.0 + 2.0 * ditherCoord.y);
    // PassSrg::m_outputColor[pixelCoord].rgb = float3(samplingDither, samplingDither, samplingDither);

    const int iterationCount = PassSrg::m_constants.m_sampleNumber / 2;
    const float2 sampleStep = tileVelocity / (float)iterationCount;
    const float pixelToSampleUnitsScale = rsqrt(dot(sampleStep, sampleStep));
    float4 accumulatedColor = float4(0.0, 0.0, 0.0, 0.0);
    
    for (int i = 0; i < iterationCount; ++i)
    {
        int2 offset = int2((i + samplingDither) * sampleStep);
        uint2 coord1 = ClampCoords(pixelCoord + offset);
        uint2 coord2 = ClampCoords(pixelCoord - offset);

        float2 sampleVelocity1 = PassSrg::m_inputVelocity[coord1];
        float2 sampleVelocity2 = PassSrg::m_inputVelocity[coord2];
        sampleVelocity1 = ToPixelVelocity(sampleVelocity1);
        sampleVelocity2 = ToPixelVelocity(sampleVelocity2);

        float sampleVelocityLength1 = length(sampleVelocity1);
        float sampleVelocityLength2 = length(sampleVelocity2);

        float sampleDepth1 = PassSrg::m_linearDepth[coord1].r;
        float sampleDepth2 = PassSrg::m_linearDepth[coord2].r;

        float weight1 = SampleWeight(depth, sampleDepth1, i + samplingDither, tileVelocityLength, sampleVelocityLength1, pixelToSampleUnitsScale, 1);
        float weight2 = SampleWeight(depth, sampleDepth2, i + samplingDither, tileVelocityLength, sampleVelocityLength2, pixelToSampleUnitsScale, 1);

        bool2 doMirror = bool2(sampleDepth1 > sampleDepth2, sampleVelocityLength2 > sampleVelocityLength1);
		weight1 = all(doMirror) ? weight2 : weight1;
		weight2 = any(doMirror) ? weight2 : weight1;

        accumulatedColor += weight1 * float4(PassSrg::m_inputColor[coord1].rgb, 1.0);
        accumulatedColor += weight2 * float4(PassSrg::m_inputColor[coord2].rgb, 1.0);
    }
    
    if(accumulatedColor.w == 0)
    {
        return;
    }
    
    accumulatedColor /= float(iterationCount * 2);
    accumulatedColor.rgb = max(0.0, accumulatedColor.rgb);
    // PassSrg::m_outputColor[pixelCoord].rgb = 100 * float3(velocityLength, velocityLength, velocityLength);
    PassSrg::m_outputColor[pixelCoord].rgb = accumulatedColor.rgb + (1. - accumulatedColor.w) * color;
}
