/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

// refer https://github.com/GPUOpen-Effects/FidelityFX-SPD/blob/c52944f547884774a1b33066f740e6bf89f927f5/sample/src/DX12/SPDIntegration.hlsl

#include <Atom/Features/SrgSemantics.azsli>

struct SpdGlobalAtomicBuffer
{
    uint m_counter;
};

ShaderResourceGroup PassSrg : SRG_PerPass
{
    RWTexture2D<float4> m_imageDestination[13]; // don't access MIP [6]. 
    [[verbatim("globallycoherent")]] RWTexture2D<float4> m_imageDestination6;
    [[verbatim("globallycoherent")]] RWStructuredBuffer<SpdGlobalAtomicBuffer> m_globalAtomic;

    uint m_mips;
    uint m_numWorkGroups;
    uint2 m_workGroupOffset;
}

#define A_GPU
#define A_HLSL
#include <3rdParty/Features/PostProcessing/ffx-spd/ffx_a.h>

groupshared AU1 s_spdCounter;

#ifndef SPD_PACKED_ONLY

groupshared AF1 s_spdIntermediateR[16][16];
groupshared AF1 s_spdIntermediateG[16][16];
groupshared AF1 s_spdIntermediateB[16][16];
groupshared AF1 s_spdIntermediateA[16][16];

AF4 SpdLoadSourceImage(AF2 tex, AU1 /* slice */)
{
    return PassSrg::m_imageDestination[0][tex];
}

AF4 SpdLoad(ASU2 tex, AU1 /* slice */)
{
    return PassSrg::m_imageDestination6[tex];
}

void SpdStore(ASU2 pix, AF4 value, AU1 mip, AU1 /* slice */)
{
    if (mip == 5)
        PassSrg::m_imageDestination6[pix] = value;
    else
        PassSrg::m_imageDestination[mip + 1][pix] = value;
}

void SpdIncreaseAtomicCounter(AU1 /* slice*/)
{
    InterlockedAdd(PassSrg::m_globalAtomic[0].m_counter, 1, s_spdCounter);
}

AU1 SpdGetAtomicCounter()
{
    return s_spdCounter;
}

void SpdResetAtomicCounter(AU1 /* slice */)
{
    PassSrg::m_globalAtomic[0].m_counter = 0;
}

AF4 SpdLoadIntermediate(AU1 x, AU1 y)
{
    return AF4(
    s_spdIntermediateR[x][y],
    s_spdIntermediateG[x][y],
    s_spdIntermediateB[x][y],
    s_spdIntermediateA[x][y]);
}

void SpdStoreIntermediate(AU1 x, AU1 y, AF4 value)
{
    s_spdIntermediateR[x][y] = value.x;
    s_spdIntermediateG[x][y] = value.y;
    s_spdIntermediateB[x][y] = value.z;
    s_spdIntermediateA[x][y] = value.w;
}

AF4 SpdReduce4(AF4 v0, AF4 v1, AF4 v2, AF4 v3)
{
    const float minValue = min(min(v0.x, v1.x), min(v2.x, v3.x));
    const float avgValue = (v0.y + v1.y + v2.y + v3.y) * 0.25;
    const float maxValue = max(max(v0.z, v1.z), max(v2.z, v3.z));
    return AF4(minValue, avgValue, maxValue, 0.);
}

#include <3rdParty/Features/PostProcessing/ffx-spd/ffx_spd.h>
 
[numthreads(256, 1, 1)]
void MainCS(uint3 workGroupId : SV_GroupID, uint localThreadIndex : SV_GroupIndex)
{
    // Assuming workGroudId 0 is dispatched first, reset the counter.
    // TODO: Move the reset procedure before this dispatch.
    if (workGroupId.x == 0 && 
        workGroupId.y == 0 &&
        workGroupId.z == 0 &&
        localThreadIndex == 0)
        SpdResetAtomicCounter(0);
    
    SpdDownsample(
        AU2(workGroupId.xy), 
        AU1(localThreadIndex),  
        AU1(PassSrg::m_mips),
        AU1(PassSrg::m_numWorkGroups),
        AU1(workGroupId.z),
        AU2(PassSrg::m_workGroupOffset));
}
