/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#ifndef InitializeLightingData
#define InitializeLightingData InitializeLightingData_BasePBR
#endif

#ifndef FinalizeLightingData
#define FinalizeLightingData FinalizeLightingData_BasePBR
#endif

// Note: See the note in BasePBR_LightingData.azsli as to why this isn't a class method
void BasePBR_InitLightingData(inout LightingData lightingData, float3 positionWS, real3 specularNormal, real roughnessLinear, float3 viewPosition[MAX_SHADING_VIEWS])
{
    lightingData.diffuseLighting = real3(0.0, 0.0, 0.0);
    lightingData.multiScatterCompensation = real3(1.0, 1.0, 1.0);
    lightingData.emissiveLighting = real3(0.0, 0.0, 0.0);
#if ENABLE_TRANSMISSION
    lightingData.translucentBackLighting = real3(0.0, 0.0, 0.0);
#endif
    lightingData.diffuseAmbientOcclusion = 1.0;
    lightingData.specularOcclusion = 1.0;

    [unroll]
    for(uint i = 0; i < GET_SHADING_VIEW_COUNT; ++i)
    {
        lightingData.specularLighting[i] = real3(0.0, 0.0, 0.0);
        lightingData.dirToCamera[i] = normalize(viewPosition[i] - positionWS);
        lightingData.NdotV[i] = saturate(dot(specularNormal, lightingData.dirToCamera[i]));
        // sample BRDF map (indexed by smoothness values rather than roughness)
        float2 brdfUV = float2(lightingData.NdotV[i], (1.0 - roughnessLinear));
        lightingData.brdf[i] = real2(SampleBrdfMap(brdfUV));
    }
}

void InitializeLightingData_BasePBR(Surface surface, float3 viewPositions[MAX_SHADING_VIEWS], inout LightingData lightingData)
{
    BasePBR_InitLightingData(lightingData, surface.position, surface.GetSpecularNormal(),  surface.roughnessLinear, viewPositions);

    // Diffuse and Specular response (used in IBL calculations)
    real3 specularResponse = FresnelSchlickWithRoughness(lightingData.GetSpecularNdotV(), surface.GetSpecularF0(), surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - specularResponse;

    // Multiscatter
    lightingData.CalculateMultiscatterCompensation(surface.GetSpecularF0(), o_specularF0_enableMultiScatterCompensation);
}

void FinalizeLightingData_BasePBR(Surface surface, inout LightingData lightingData)
{
    lightingData.FinalizeLighting(surface);
}

// use the default PBR lights for all supported light types
#include <Atom/Features/PBR/Lights/Lights.azsli>

