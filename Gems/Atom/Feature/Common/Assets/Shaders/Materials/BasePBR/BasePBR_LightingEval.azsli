/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#ifndef InitializeLightingData
#define InitializeLightingData InitializeLightingData_BasePBR
#endif

#ifndef FinalizeLightingData
#define FinalizeLightingData FinalizeLightingData_BasePBR
#endif

// Wrapper arround SampleBrdfMap(). 
// We need this because while the function is defined between the LightingData_BasePBR - class definition and the LightingData_BasePBR::Init() declaration, 
// azslc puts the function declaration with the class definition, and then doesn't find the SampleBrdfMap() function.
// And azslc tends to crash if we add a forward declaration for SampleBrdfMap() directly.
float2 MySampleBrdfMap(float2 brdfUV)
{
    return SampleBrdfMap(brdfUV);
}

void LightingData_BasePBR::Init(float3 positionWS, real3 specularNormal, real roughnessLinear, float3 viewPosition[MAX_SHADING_VIEWS])
{
    diffuseLighting = real3(0.0, 0.0, 0.0);
    multiScatterCompensation = real3(1.0, 1.0, 1.0);
    emissiveLighting = real3(0.0, 0.0, 0.0);
#if ENABLE_TRANSMISSION
    translucentBackLighting = real3(0.0, 0.0, 0.0);
#endif
    diffuseAmbientOcclusion = 1.0;
    specularOcclusion = 1.0;

    [unroll]
    for(uint i = 0; i < GET_SHADING_VIEW_COUNT; ++i)
    {
        specularLighting[i] = real3(0.0, 0.0, 0.0);
        dirToCamera[i] = normalize(viewPosition[i] - positionWS);
        NdotV[i] = saturate(dot(specularNormal, dirToCamera[i]));
        // sample BRDF map (indexed by smoothness values rather than roughness)
        float2 brdfUV = float2(NdotV[i], (1.0 - roughnessLinear));
        brdf[i] = real2(MySampleBrdfMap(brdfUV));
    }
}

void InitializeLightingData_BasePBR(Surface surface, float3 viewPositions[MAX_SHADING_VIEWS], inout LightingData lightingData)
{
    lightingData.Init(surface.position, surface.GetSpecularNormal(),  surface.roughnessLinear, viewPositions);

    // Diffuse and Specular response (used in IBL calculations)
    real3 specularResponse = FresnelSchlickWithRoughness(lightingData.GetSpecularNdotV(), surface.GetSpecularF0(), surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - specularResponse;

    // Multiscatter
    lightingData.CalculateMultiscatterCompensation(surface.GetSpecularF0(), o_specularF0_enableMultiScatterCompensation);
}

void FinalizeLightingData_BasePBR(Surface surface, inout LightingData lightingData)
{
    lightingData.FinalizeLighting(surface);
}

// use the default PBR lights for all supported light types
#include <Atom/Features/PBR/Lights/Lights.azsli>

