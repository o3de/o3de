/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// This #define magic lets you use the EvaluateLighting function in this file without making it the final EvaluateLighting
// used in your shader. Simply #define EvaluateLighting to your custom definition before including this file
//
#ifndef InitializeLightingData
#define InitializeLightingData InitializeLightingData_BasePBR
#endif

#ifndef FinalizeLightingData
#define FinalizeLightingData FinalizeLightingData_BasePBR
#endif


void InitializeLightingData_BasePBR(Surface surface, float3 viewPosition, inout LightingData lightingData)
{
    lightingData.diffuseLighting = real3(0.0, 0.0, 0.0);
    lightingData.specularLighting = real3(0.0, 0.0, 0.0);
    lightingData.multiScatterCompensation = real3(1.0, 1.0, 1.0);
    lightingData.emissiveLighting = real3(0.0, 0.0, 0.0);
#if ENABLE_TRANSMISSION
    lightingData.translucentBackLighting = real3(0.0, 0.0, 0.0);
#endif
    lightingData.diffuseAmbientOcclusion = 1.0;
    lightingData.specularOcclusion = 1.0;
        
    lightingData.dirToCamera = normalize(viewPosition - surface.position);

    // sample BRDF map (indexed by smoothness values rather than roughness)
    lightingData.NdotV = saturate(dot(surface.GetSpecularNormal(), lightingData.dirToCamera));
    float2 brdfUV = float2(lightingData.NdotV, (1.0 - surface.roughnessLinear));
    lightingData.brdf = real2(SampleBrdfMap(brdfUV));
    
    // Diffuse and Specular response (used in IBL calculations)
    real3 specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.GetSpecularF0(), surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - specularResponse;

    // Multiscatter
    lightingData.multiScatterCompensation = GetMultiScatterCompensation(surface.GetSpecularF0(), lightingData.brdf, o_specularF0_enableMultiScatterCompensation);
}


void FinalizeLightingData_BasePBR(Surface surface, inout LightingData lightingData)
{
    lightingData.specularLighting *= lightingData.specularOcclusion;
    lightingData.diffuseLighting *= lightingData.diffuseAmbientOcclusion;

    if(!IsSpecularLightingEnabled())
    {
        lightingData.specularLighting = real3(0, 0, 0);
    }
    if(!IsDiffuseLightingEnabled())
    {
        lightingData.diffuseLighting = real3(0, 0, 0);
    }

    // Transmitted light
#if ENABLE_TRANSMISSION
    if(o_transmission_mode != TransmissionMode::None)
    {
        lightingData.diffuseLighting += lightingData.translucentBackLighting * surface.transmission.tint;
    }
#endif
}

// use the default PBR lights for all supported light types
#include <Atom/Features/PBR/Lights/Lights.azsli>

