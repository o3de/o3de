/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <Atom/Features/ColorManagement/TransformColor.azsli>
#include <Atom/Features/SrgSemantics.azsli>
#include <scenesrg.srgi>
#include <viewsrg.srgi>

struct VSInput
{
    float3 m_position : POSITION;
    float4 m_color : COLOR0;

    uint m_vertexID : SV_VertexID;
};

struct VSOutput
{
    float4 m_position : SV_Position;
    float4 m_color : COLOR0;
    float2 m_quadPos : TEXCOORD;
};

float GetFlickerAmount(in float3 pos)
{
    const float2 StarShimmerTab[8] = 
    {
        float2(0.897907815,-0.347608525), float2(0.550299290, 0.273586675), float2(0.823885965, 0.098853070), float2(0.922739035,-0.122108860),
        float2(0.800630175,-0.088956800), float2(0.711673375, 0.158864420), float2(0.870537795, 0.085484560), float2(0.956022355,-0.058114540)
    };

    float2 hash = frac(pos.xy * 256);  
    float index = frac(hash.x + (hash.y + 1) * SceneSrg::m_starParams.w);
    index *= 8;
  
    float f = frac(index);
    int i = int(index);
    return StarShimmerTab[i].x + f * StarShimmerTab[i].y;
}

VSOutput MainVS(VSInput IN)
{
    VSOutput OUT;
    
    float4 ColAndMag = IN.m_color;

    // Set the w component to 0 in order to project the stars out to infinity.
    float4 pos = float4(mul(SceneSrg::m_starRotationMatrix, IN.m_position), 0.0);
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, pos);    

    // using reverse z, so push depth out to the far plane
    // if can gaurantee the draw order, then can disable depth check entirely
    OUT.m_position.z = 0.0; 
    
    // apparent magnitude is how bright a star appears from earth 
    // magnitude is a logarithmic scale and brighter objects have lower numbers
    // 1.0 magnitude is the brightest, a star of magnitude 2.0 is 2.512 times as
    // bright as a star of magnitude of 3.0
    // Sirius has a magnitude of -1.46
    // humans typically see stars with apparent magnitude ranging from -1.44 .. 6.5
    const float humanMinMag = -1.44;
    const float humanMaxMag = 6.5;

    // scale ColAndMag.w from 0..1 to 6.5..-1.44
    float apparentMagnitude = humanMaxMag + ColAndMag.w * (humanMinMag - humanMaxMag);

    // we want the stars with apparent magnitude of 6.5 to be barely visible
    // and apparent magnitude of -1.44 to be the brightness of Vega/Sirius

    // scale the range from 6.5..-1.44 to 0..1 with a logarithmic scale approximation 
    // e.g. 6.5 = 0.006, 1 = 0.2, 0 = 0.39, -1.44 =  1
    // and dim with animated flicker amount

    float brightness = GetFlickerAmount(IN.m_position) * pow(5.0, (-apparentMagnitude + humanMinMag) / 2.5);
    OUT.m_color = float4(brightness * ColAndMag.xyz, brightness);

    const float2 expansion[6] =
    {
        float2( 1,  1),
        float2(-1,  1),
        float2( 1, -1),
        float2( 1, -1),
        float2(-1,  1),
        float2(-1, -1)
    };

    const float2 texcoord[6] = 
    { 
        float2(1, 0), 
        float2(0, 0),
        float2(1, 1),
        float2(1, 1),
        float2(0, 0),
        float2(0, 1)    
    };

    uint v = uint(IN.m_vertexID) % uint(6);
    OUT.m_position.xy += expansion[v] * SceneSrg::m_starParams.xy;
    OUT.m_quadPos = texcoord[v];
    return OUT;
};

struct PSOutput
{
    float4 m_diffuse : SV_Target0;
};

PSOutput MainPS(VSOutput IN)
{
    PSOutput OUT;

    float2 pos = IN.m_quadPos.xy;

    float2 distCenter = 3.5 * pos.xy - 3.5 * float2(0.5, 0.5);
    float scale = exp(-dot(distCenter, distCenter));

    float3 colCool = IN.m_color.xyz;
    float3 colHot = IN.m_color.www;

    // ACES crushes the range a bit (1.0 becomes 0.8) so we give users an 
    // intensity multiplier 
    float3 colFinal = SceneSrg::m_starParams.z * (colCool * scale + 5.0 * colHot * pow(scale, 10.0));

    OUT.m_diffuse = float4(colFinal, scale);

    // uncomment one of the following lines to more easily debug
    //OUT.m_diffuse = float4(1.0, 1.0, 1.0, scale); // full bright gradient
    //OUT.m_diffuse = float4(1.0, 1.0, 1.0, 1.0); // full bright quad 

    return OUT;
}; 
