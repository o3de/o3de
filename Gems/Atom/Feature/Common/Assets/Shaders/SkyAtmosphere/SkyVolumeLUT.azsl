/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

 // Based on https://github.com/sebh/UnrealEngineSkyAtmosphere by SÃ©bastien Hillaire

#define ENABLE_ATMOSPHERE_SHADOWS 0
#include <viewsrg.srgi>
#include <Atom/Features/SrgSemantics.azsli>
#include <SkyAtmosphereCommon.azsli>

float4 GetSkyVolumeAtPosition(uint3 position)
{
    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    const float worldScale = 0.001f;
    const float lutSize = float(SKY_VOLUME_SLICE_COUNT - 1);
    float2 uv = float2(position.x, position.y) / lutSize;
    float2 ndcPos = float2(uv.x , 1.0f - uv.y) * 2.0f - 1.0f;
    float4 projectedPos = float4(ndcPos, 0.f, 1.0f);
    float4 positionWS = mul(ViewSrg::m_viewProjectionInverseMatrix, projectedPos);
    positionWS /= positionWS.w;

    float3 viewToPosition =  positionWS.xyz / positionWS.w - ViewSrg::m_worldPosition;
    float3 worldDir = normalize(viewToPosition);

    // Atmosphere.PlanetOrigin is in KM already
    // cameraPlanetPosKm is relative to the planet origin
    float3 cameraPlanetPosKm = ViewSrg::m_worldPosition * worldScale - Atmosphere.PlanetOrigin;

    float slice = (float(position.z) + 0.5f) / SKY_VOLUME_SLICE_COUNT;
    slice *= slice;    // squared distribution
    slice *= SKY_VOLUME_SLICE_COUNT;

    float tMax = AerialPerspectiveSliceToDepth(slice);

    // get position relative to planet surface
    float3 froxelPosition = cameraPlanetPosKm + tMax * worldDir;

    // if the froxel is under the ground, make sure to offset it out on the ground.
    float viewHeight = length(froxelPosition);
    if (viewHeight <= (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET_KM))
    {
        // Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
        froxelPosition = normalize(froxelPosition) * (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET_KM + 0.001f);
        worldDir = normalize(froxelPosition - cameraPlanetPosKm);
        tMax = length(froxelPosition - cameraPlanetPosKm);
    }
    float maxTraceDepth = tMax;

    const float depth = -1.0;

    // move ray marching start up to top atmosphere.
    viewHeight = length(froxelPosition);
    if (viewHeight >= Atmosphere.TopRadius)
    {
        float distanceToTop = 0.f;

        if (!MoveToTopAtmosphere(cameraPlanetPosKm, distanceToTop, worldDir, Atmosphere.TopRadius, depth))
        {
            // ray is not intersecting the atmosphere
            return float4(0.0, 0.0, 0.0, 1.0);
        }

        if (maxTraceDepth < distanceToTop)
        {
            // maxTraceDepth for this voxel is not within earth atmosphere
            return float4(0.0, 0.0, 0.0, 1.0);
        }

        // world position has been moved to the atmosphere boundary: we need to reduce maxTraceDepth accordingly. 
        maxTraceDepth = max(0.0, maxTraceDepth - distanceToTop);
    }

    const bool ground = false;

    // setting variableSampleCount false may improve performance, but atmosphere will look thinner 
    // so you may need to increase sampleCountIni
    const float sampleCountIni = max(1.0, float(position.z + 1.0) * 2.0f);
    const bool variableSampleCount = true;
    const bool mieRayPhase = true;
    const float2 screenCoords = float2(0,0); // unused
    SingleScatteringResult ss = IntegrateScatteredLuminance(screenCoords, cameraPlanetPosKm, worldDir, PassSrg::m_constants.m_sunDirection, Atmosphere, ground, sampleCountIni, depth, variableSampleCount, mieRayPhase, maxTraceDepth);

    const float transmittance = dot(ss.Transmittance, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
    return float4(ss.L, 1.0 - transmittance);
}

// total thread count is based on the "Target Thread Count X/Y/Z" in the SkyVolumeLUT.pass file
// and the number of threads per group specified in numthreads() below.
// given a volume texture size is 32x32x32, with 1 thread per froxel
// the following values are based on intention to improve locality when accessing 
// the transmission LUT
[numthreads(1, 8, 32)]
void SkyVolumeLUTCS(uint3 dispatchID : SV_DispatchThreadID)
{
    PassSrg::m_skyVolumeLUTOutput[dispatchID] = GetSkyVolumeAtPosition(dispatchID); 
}
