/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

 // Based on https://github.com/sebh/UnrealEngineSkyAtmosphere by SÃ©bastien Hillaire

#pragma once

#define USE_CORNETTESHANKS 1 // use Cornette Shanks mie phase function
#define USE_NON_LINEAR_SKY_LUT 1 // improve precision at sunset angles

#define PLANET_RADIUS_OFFSET_KM 0.01 // offset when starting raycast to avoid artifacts 
#define SKY_MINIMUM_GROUND_OFFSET_KM 0.05 // prevent the camera from getting too close to the ground to avoid sharp horizon line

option bool o_enableShadows = false;
option bool o_enableSun = true;
option bool o_enableFastSky = true;
option bool o_enableFastAerialPerspective = true;
option bool o_enableAerialPerspective = true;

#include <Atom/Features/SrgSemantics.azsli>

#define SKY_VOLUME_SLICE_COUNT 32
#define SKY_VOLUME_KM_PER_SLICE 4.0

ShaderResourceGroup PassSrg : SRG_PerPass_WithFallback
{
    Texture2DMS<float> m_depth;
    Texture2D<float4> m_transmittanceLUT; // generated by first pass pixel shader
    Texture2D<float4> m_skyViewLUT; 
    Texture3D<float4> m_skyVolumeLUT;
    RWTexture3D<float4> m_skyVolumeLUTOutput;
    Texture2DArray<float> m_directionalLightShadowmap;
    Texture2DArray<float> m_directionalLightExponentialShadowmap;
    Texture2D<float> m_fullscreenShadow;

    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    Sampler PointSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    struct Constants 
    {
        float3   m_absorption;
        float    m_nearClip;

        float3   m_rayleighScattering;
        float    m_miePhaseFunctionG;

        float3   m_mieScattering;
        float    m_bottomRadius;

        float3   m_mieExtinction;
        float    m_topRadius;

        float3  m_mieAbsorption;
        float   m_rayMarchMin;

        float3  m_groundAlbedo;
        float   m_rayMarchMax;

        float  m_rayleighDensityExpScale;
        float  m_mieDensityExpScale;
        float  m_absorptionDensity0LayerWidth;
        float  m_absorptionDensity0ConstantTerm;

        float  m_absorptionDensity0LinearTerm;
        float  m_absorptionDensity1ConstantTerm;
        float  m_absorptionDensity1LinearTerm;
        float  m_nearFadeDistance;

        float3 m_sunColor;
        float  m_sunRadiusFactor;

        float3 m_sunDirection;
        float  m_sunFalloffFactor;

        float3 m_sunLimbColor;
        float  m_sunShadowFarClip; 

        float3 m_luminanceFactor;
        float  m_aerialDepthFactor;

        float3 m_planetOrigin;
        float  m_pad4; // not used
    };

    Constants m_constants;
};

#include <Atom/RPI/Math.azsli>

#if ENABLE_ATMOSPHERE_SHADOWS
// Needed for DirectionalLightShadow.azsli - o_opacity_mode exists in most shaders but not this one.
option enum class OpacityMode 
{
    Opaque, 
    Cutout, 
    Blended, 
    TintedTransparent

} o_opacity_mode = OpacityMode::Blended;

#include <Atom/Features/Shadow/DirectionalLightShadow.azsli>
#endif // ENABLE_ATMOSPHERE_SHADOWS

float fromUnitToSubUvs(float u, float resolution) { return (u + 0.5 / resolution) * (resolution / (resolution + 1.0)); }
float fromSubUvsToUnit(float u, float resolution) { return (u - 0.5 / resolution) * (resolution / (resolution - 1.0)); }

float AerialPerspectiveDepthToSlice(float depth) { return depth * (1.0 / SKY_VOLUME_KM_PER_SLICE); }
float AerialPerspectiveSliceToDepth(float slice) { return slice * SKY_VOLUME_KM_PER_SLICE; }

struct AtmosphereParameters
{
    // Radius of the planet (center to ground)
    float BottomRadius;
    // Maximum considered atmosphere height (center to atmosphere top)
    float TopRadius;

    // Rayleigh scattering exponential distribution scale in the atmosphere
    float RayleighDensityExpScale;
    // Rayleigh scattering coefficients
    float3 RayleighScattering;

    // Mie scattering exponential distribution scale in the atmosphere
    float MieDensityExpScale;
    // Mie scattering coefficients
    float3 MieScattering;
    // Mie extinction coefficients
    float3 MieExtinction;
    // Mie absorption coefficients
    float3 MieAbsorption;
    // Mie phase function excentricity
    float MiePhaseG;

    // Another medium type in the atmosphere
    float AbsorptionDensity0LayerWidth;
    float AbsorptionDensity0ConstantTerm;
    float AbsorptionDensity0LinearTerm;
    float AbsorptionDensity1ConstantTerm;
    float AbsorptionDensity1LinearTerm;
    // This other medium only absorb light, e.g. useful to represent ozone in the earth atmosphere
    float3 Absorption;

    // The albedo of the ground.
    float3 GroundAlbedo;

    float3 PlanetOrigin;
};

AtmosphereParameters GetAtmosphereParameters()
{
    AtmosphereParameters Parameters;
    Parameters.Absorption = PassSrg::m_constants.m_absorption;

    Parameters.RayleighDensityExpScale = PassSrg::m_constants.m_rayleighDensityExpScale;
    Parameters.MieDensityExpScale = PassSrg::m_constants.m_mieDensityExpScale;
    Parameters.AbsorptionDensity0LayerWidth = PassSrg::m_constants.m_absorptionDensity0LayerWidth;
    Parameters.AbsorptionDensity0ConstantTerm = PassSrg::m_constants.m_absorptionDensity0ConstantTerm;
    Parameters.AbsorptionDensity0LinearTerm = PassSrg::m_constants.m_absorptionDensity0LinearTerm;
    Parameters.AbsorptionDensity1ConstantTerm = PassSrg::m_constants.m_absorptionDensity1ConstantTerm;
    Parameters.AbsorptionDensity1LinearTerm = PassSrg::m_constants.m_absorptionDensity1LinearTerm;

    Parameters.MiePhaseG = PassSrg::m_constants.m_miePhaseFunctionG;
    Parameters.RayleighScattering = PassSrg::m_constants.m_rayleighScattering;
    Parameters.MieScattering = PassSrg::m_constants.m_mieScattering;
    Parameters.MieAbsorption = PassSrg::m_constants.m_mieAbsorption;
    Parameters.MieExtinction = PassSrg::m_constants.m_mieExtinction;
    Parameters.GroundAlbedo = PassSrg::m_constants.m_groundAlbedo;
    Parameters.BottomRadius = PassSrg::m_constants.m_bottomRadius;
    Parameters.TopRadius = PassSrg::m_constants.m_topRadius;
    Parameters.PlanetOrigin = PassSrg::m_constants.m_planetOrigin;

    return Parameters;
}

void LutTransmittanceParamsToUv(AtmosphereParameters Atmosphere, in float viewHeight, in float viewZenithCosAngle, out float2 uv)
{
    float H = sqrt(max(0.0, Atmosphere.TopRadius * Atmosphere.TopRadius - Atmosphere.BottomRadius * Atmosphere.BottomRadius));
    float rho = sqrt(max(0.0, viewHeight * viewHeight - Atmosphere.BottomRadius * Atmosphere.BottomRadius));

    float discriminant = viewHeight * viewHeight * (viewZenithCosAngle * viewZenithCosAngle - 1.0) + Atmosphere.TopRadius * Atmosphere.TopRadius;
    float d = max(0.0, (-viewHeight * viewZenithCosAngle + sqrt(discriminant))); // Distance to atmosphere boundary

    float d_min = Atmosphere.TopRadius - viewHeight;
    float d_max = rho + H;
    float x_mu = (d - d_min) / (d_max - d_min);
    float x_r = rho / H;

    uv = float2(x_mu, x_r);
}

float CornetteShanksMiePhaseFunction(float g, float cosTheta)
{
    float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
    return k * (1.0 + cosTheta * cosTheta) / pow(1.0 + g * g - 2.0 * g * -cosTheta, 1.5);
}

float HgPhase(float g, float cosTheta)
{
#if USE_CORNETTESHANKS
    return CornetteShanksMiePhaseFunction(g, cosTheta);
#else
    // Reference implementation (i.e. not schlick approximation). 
    // See http://www.pbr-book.org/3ed-2018/Volume_Scattering/Phase_Functions.html
    float numer = 1.0 - g * g;
    float denom = 1.0 + g * g + 2.0 * g * cosTheta;
    return numer / (4.0 * PI * denom * sqrt(denom));
#endif
}

float RayleighPhase(float cosTheta)
{
    const float factor = 3.0 / (16.0 * PI);
    return factor * (1.0 + cosTheta * cosTheta);
}

float GetAlbedo(float scattering, float extinction)
{
    return scattering / max(0.001, extinction);
}
float3 GetAlbedo(float3 scattering, float3 extinction)
{
    return scattering / max(0.001, extinction);
}

struct MediumSampleRGB
{
    float3 scattering;
    float3 absorption;
    float3 extinction;

    float3 scatteringMie;
    float3 absorptionMie;
    float3 extinctionMie;

    float3 scatteringRay;
    float3 absorptionRay;
    float3 extinctionRay;

    float3 scatteringOzo;
    float3 absorptionOzo;
    float3 extinctionOzo;

    float3 albedo;
};

MediumSampleRGB SampleMediumRGB(in float3 worldPos, in AtmosphereParameters Atmosphere)
{
    const float viewHeight = length(worldPos) - Atmosphere.BottomRadius;

    const float densityMie = exp(Atmosphere.MieDensityExpScale * viewHeight);
    const float densityRay = exp(Atmosphere.RayleighDensityExpScale * viewHeight);
    const float densityOzo = saturate(viewHeight < Atmosphere.AbsorptionDensity0LayerWidth ?
        Atmosphere.AbsorptionDensity0LinearTerm * viewHeight + Atmosphere.AbsorptionDensity0ConstantTerm :
        Atmosphere.AbsorptionDensity1LinearTerm * viewHeight + Atmosphere.AbsorptionDensity1ConstantTerm);

    MediumSampleRGB s;

    s.scatteringMie = densityMie * Atmosphere.MieScattering;
    s.absorptionMie = densityMie * Atmosphere.MieAbsorption;
    s.extinctionMie = densityMie * Atmosphere.MieExtinction;

    s.scatteringRay = densityRay * Atmosphere.RayleighScattering;
    s.absorptionRay = 0.0;
    s.extinctionRay = s.scatteringRay + s.absorptionRay;

    s.scatteringOzo = 0.0;
    s.absorptionOzo = densityOzo * Atmosphere.Absorption;
    s.extinctionOzo = s.scatteringOzo + s.absorptionOzo;

    s.scattering = s.scatteringMie + s.scatteringRay + s.scatteringOzo;
    s.absorption = s.absorptionMie + s.absorptionRay + s.absorptionOzo;
    s.extinction = s.extinctionMie + s.extinctionRay + s.extinctionOzo;
    s.albedo = GetAlbedo(s.scattering, s.extinction);

    return s;
}

void UvToSkyViewLutParams(in AtmosphereParameters Atmosphere, out float viewZenithCosAngle, out float lightViewCosAngle, in float viewHeight, in float2 uv)
{
    // Constrain uvs to valid sub texel range (avoid zenith derivative issue making LUT usage visible)
    uv = float2(fromSubUvsToUnit(uv.x, 192.0), fromSubUvsToUnit(uv.y, 108.0));

    const float vHorizon = sqrt(viewHeight * viewHeight - Atmosphere.BottomRadius * Atmosphere.BottomRadius);
    const float cosBeta = vHorizon / viewHeight;
    const float beta = acos(cosBeta);
    const float zenithHorizonAngle = PI - beta;

    if (uv.y < 0.5)
    {
        float coord = 2.0*uv.y;
        coord = 1.0 - coord;
#if USE_NON_LINEAR_SKY_LUT
        coord *= coord;
#endif
        coord = 1.0 - coord;
        viewZenithCosAngle = cos(zenithHorizonAngle * coord);
    }
    else
    {
        float coord = uv.y*2.0 - 1.0;
#if USE_NON_LINEAR_SKY_LUT
        coord *= coord;
#endif
        viewZenithCosAngle = cos(zenithHorizonAngle + beta * coord);
    }

    lightViewCosAngle = -(uv.x*uv.x*2.0 - 1.0);
}

void SkyViewLutParamsToUv(AtmosphereParameters Atmosphere, in bool intersectGround, in float viewZenithCosAngle, in float lightViewCosAngle, in float viewHeight, out float2 uv)
{
    const float vhorizon = sqrt(viewHeight * viewHeight - Atmosphere.BottomRadius * Atmosphere.BottomRadius);
    const float cosBeta = vhorizon / viewHeight;
    const float beta = acos(cosBeta);
    const float ZenithHorizonAngle = PI - beta;

    if (!intersectGround)
    {
        float coord = acos(viewZenithCosAngle) / ZenithHorizonAngle;
        coord = 1.0 - coord;
#if USE_NON_LINEAR_SKY_LUT
        coord = sqrt(coord);
#endif
        coord = 1.0 - coord;
        uv.y = coord * 0.5;
    }
    else
    {
        float coord = (acos(viewZenithCosAngle) - ZenithHorizonAngle) / beta;
#if USE_NON_LINEAR_SKY_LUT
        coord = sqrt(coord);
#endif
        uv.y = coord * 0.5 + 0.5;
    }

    {
        float coord = -lightViewCosAngle * 0.5 + 0.5;
        coord = sqrt(coord);
        uv.x = coord;
    }

    // Constrain uvs to valid sub texel range (avoid zenith derivative issue making LUT usage visible)
    uv = float2(fromUnitToSubUvs(uv.x, 192.0), fromUnitToSubUvs(uv.y, 108.0));
}

bool MoveToAtmosphere(in AtmosphereParameters Atmosphere, inout float3 worldPos, inout float distanceToAtmosphere, in float3 worldDir, in float depth)
{
    const float viewHeight = length(worldPos);
    if (viewHeight <= Atmosphere.TopRadius && viewHeight >= Atmosphere.BottomRadius)
    {
        // position is inside atmosphere
        return true;
    }

    float offset;
    if (viewHeight > Atmosphere.TopRadius)
    {
        distanceToAtmosphere = RaySphereClosestHitWS(float3(0.0, 0.0, 0.0), Atmosphere.TopRadius, worldPos, worldDir);
        offset = -PLANET_RADIUS_OFFSET_KM;
    }
    else if(viewHeight < Atmosphere.BottomRadius)
    {
        distanceToAtmosphere = RaySphereClosestHitWS(float3(0.0, 0.0, 0.0), Atmosphere.BottomRadius, worldPos, worldDir);
        offset = PLANET_RADIUS_OFFSET_KM;
    }

    if (distanceToAtmosphere < 0.0 || distanceToAtmosphere > depth)
    {
        // ray is not intersecting the atmosphere
        return false;
    }

    const float3 upVector = worldPos / viewHeight;
    worldPos = worldPos + worldDir * distanceToAtmosphere + upVector * offset;
    return true;
}

struct SingleScatteringResult
{
    float3 L;                        // Scattered light (luminance)
    float3 OpticalDepth;            // Optical depth (1/m)
    float3 Transmittance;            // Transmittance in [0,1] (unitless)
};

SingleScatteringResult IntegrateScatteredLuminance(
    in float2 pixPos, in float3 worldPos, in float3 worldDir, in float3 sunDir, in AtmosphereParameters Atmosphere,
    in bool ground, in float sampleCountIni, in float depthBufferValue, in bool variablesampleCount,
    in bool mieRayPhase, in float tMaxMax = 9000000.0)
{
    SingleScatteringResult result = (SingleScatteringResult)0;

    // Compute next intersection with atmosphere or ground 
    const float3 earthOrigin = float3(0.0, 0.0, 0.0);
    float tBottom = RaySphereClosestHitWS(earthOrigin, Atmosphere.BottomRadius, worldPos, worldDir);
    float tTop = RaySphereClosestHitWS(earthOrigin, Atmosphere.TopRadius, worldPos, worldDir);
    float tMax = 0.0;

    // this logic assumes the camera is not inside the planet surface
    if (tBottom < 0.0)
    {
        if (tTop < 0.0)
        {
            tMax = 0.0; // No intersection with earth nor atmosphere: stop right away  
            return result;
        }
        else
        {
            tMax = tTop;
        }
    }
    else
    {
        if (tTop > 0.0)
        {
            // when in the sky looking down we hit the bottom and the top
            // but we just want the distance to the bottom
            tMax = min(tTop, tBottom);
        }
    }

    tMax = min(tMax, tMaxMax);

    float sampleCount = sampleCountIni;
    float sampleCountFloor = sampleCountIni;
    float tMaxFloor = tMax;
    if (variablesampleCount)
    {
        // tMax which indicates the maximum distance we will trace is in kilometers
        // if min rays = 4 and max rays = 14 (14 - 4 = 10 steps) so 1.0/steps is 0.01
        // if tMax is < 1Km then floor(1 * 0.01) = 0, so 4 ray segments
        // if tMax is > 100Km then floor(100 * 0.01) = 1, so 14 ray segments

        // use max samples for anything >= atmosphere height 
        const float sampleRange = 1.0  / (Atmosphere.TopRadius - Atmosphere.BottomRadius);

        sampleCount = lerp(PassSrg::m_constants.m_rayMarchMin, PassSrg::m_constants.m_rayMarchMax, saturate(tMax * sampleRange));
        sampleCountFloor = floor(sampleCount);
        tMaxFloor = tMax * sampleCountFloor / sampleCount;    // rescale tMax to map to the last entire step segment.
    }
    float dt = tMax / sampleCount;

    // Phase functions
    const float uniformPhase = 1.0 / (4.0 * PI);
    const float cosTheta = dot(sunDir, worldDir);
    const float miePhaseValue = HgPhase(Atmosphere.MiePhaseG, -cosTheta);    // negate cosTheta due to worldDir being a "in" direction. 
    const float rayleighPhaseValue = RayleighPhase(cosTheta);
    const float3 globalL = PassSrg::m_constants.m_luminanceFactor;

    // Ray march the atmosphere to integrate optical depth
    float3 luminance = 0.0;
    float3 throughput = 1.0;
    float3 opticalDepth = 0.0;
    float t = 0.0;
    float tPrev = 0.0;
    const float sampleSegmentT = 0.3;
    for (float s = 0.0; s < sampleCount; s += 1.0)
    {
        if (variablesampleCount)
        {
            // More expenssive but artefact free
            float t0 = (s) / sampleCountFloor;
            float t1 = (s + 1.0) / sampleCountFloor;
            // Non linear distribution of sample within the range.
            t0 = t0 * t0;
            t1 = t1 * t1;
            // Make t0 and t1 world space distances.
            t0 = tMaxFloor * t0;
            if (t1 > 1.0)
            {
                t1 = tMax;
            }
            else
            {
                t1 = tMaxFloor * t1;
            }
            t = t0 + (t1 - t0) * sampleSegmentT;
            dt = t1 - t0;
        }
        else
        {
            // use exact difference, important for accuracy of multiple scattering
            float newT = tMax * (s + sampleSegmentT) / sampleCount;
            dt = newT - t;
            t = newT;
        }
        float3 samplePos = worldPos + t * worldDir;

        MediumSampleRGB medium = SampleMediumRGB(samplePos, Atmosphere);
        const float3 sampleOpticalDepth = medium.extinction * dt;
        const float3 sampleTransmittance = exp(-sampleOpticalDepth);
        opticalDepth += sampleOpticalDepth;

        float pHeight = length(samplePos);
        const float3 upVector = samplePos / pHeight;
        float sunZenithCosAngle = dot(sunDir, upVector);
        float2 uv;
        LutTransmittanceParamsToUv(Atmosphere, pHeight, sunZenithCosAngle, uv);
        float3 transmittanceToSun = PassSrg::m_transmittanceLUT.SampleLevel(PassSrg::LinearSampler, uv, 0).rgb;

        float3 phaseTimesScattering;
        if (mieRayPhase)
        {
            phaseTimesScattering = medium.scatteringMie * miePhaseValue + medium.scatteringRay * rayleighPhaseValue;
        }
        else
        {
            phaseTimesScattering = medium.scattering * uniformPhase;
        }

        // Earth shadow 
        const float tEarth = RaySphereClosestHitWS(earthOrigin + PLANET_RADIUS_OFFSET_KM * upVector, Atmosphere.BottomRadius, samplePos, sunDir);
        const float earthShadow = tEarth >= 0.0 ? 0.0 : 1.0;

        float shadow = 1.0;

#if ENABLE_ATMOSPHERE_SHADOWS
        if (o_enableShadows && earthShadow == 1.0 && tMax < PassSrg::m_constants.m_sunShadowFarClip)
        {
            const float3 shadowWorldPosition = (samplePos + Atmosphere.PlanetOrigin) * 1000.;
            shadow = DirectionalLightShadow::GetVisibility(
                ViewSrg::m_shadowIndexDirectionalLight,
                shadowWorldPosition,
                upVector,
                float4(pixPos.x, pixPos.y, 0.0, 0.0));
        }
#endif // ENABLE_ATMOSPHERE_SHADOWS

        float3 scattering = globalL * (earthShadow * shadow * transmittanceToSun * phaseTimesScattering);

        // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/ 
        // integrate along the current step segment
        float3 sampleIntegral = (scattering - scattering * sampleTransmittance) / medium.extinction;     

        // accumulate and also take into account the transmittance from previous steps
        luminance += throughput * sampleIntegral;                                                        
        throughput *= sampleTransmittance;

        tPrev = t;
    }

    if (ground && tMax == tBottom && tBottom > 0.0 && depthBufferValue <= 0.0)
    {
        // Account for bounced light off the earth
        float3 pos = worldPos + tBottom * worldDir;
        float posHeight = length(pos);

        const float3 upVector = pos / posHeight;
        float sunZenithCosAngle = dot(sunDir, upVector);
        float2 uv;
        LutTransmittanceParamsToUv(Atmosphere, posHeight, sunZenithCosAngle, uv);
        float3 transmittanceToSun = PassSrg::m_transmittanceLUT.SampleLevel(PassSrg::LinearSampler, uv, 0).rgb;

        const float ndotL = saturate(dot(normalize(upVector), normalize(sunDir)));
        luminance += globalL * transmittanceToSun * throughput * ndotL * Atmosphere.GroundAlbedo / PI;
    }

    result.L = luminance;
    result.OpticalDepth = opticalDepth;
    result.Transmittance = throughput;
    return result;
}
