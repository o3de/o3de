/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

// SRGs
#include <viewsrg.srgi>
#include <Atom/Features/PBR/ForwardPassSrg.azsli>

// Pass Output
#include <Atom/Features/PBR/ForwardPassOutput.azsli>

// Utility
#include <Atom/Features/ColorManagement/TransformColor.azsli>
#include <Atom/Features/PBR/AlphaUtils.azsli>

// Custom Surface & Lighting
#include <Atom/Features/PBR/Lighting/StandardLighting.azsli>

// Decals
#include <Atom/Features/PBR/Decals.azsli>


// ---------- Vertex Shader ----------

struct VSInput
{
    // Base fields (required by the template azsli file)...
    float3 m_position : POSITION;
    float3 m_normal : NORMAL;
    float4 m_tangent : TANGENT; 
    float3 m_bitangent : BITANGENT; 
 
    // Extended fields (only referenced in this azsl file)...
    float2 m_uv[2] : UV0;
    
    // This gets set automatically by the system at runtime only if it's available.
    // There is a soft naming convention that associates this with o_blendMask_isBound, which will be set to true whenever m_optional_blendMask is available.
    // (search "m_optional_" in ShaderVariantAssetBuilder for details on the naming convention).
    // [GFX TODO][ATOM-14475]: Come up with a more elegant way to associate the isBound flag with the input stream.
    float4 m_optional_blendMask : COLOR0;
};


struct VSOutput
{
    // Base fields (required by the template azsli file)...
    precise linear centroid float4 m_position : SV_Position;
    float3 m_normal: NORMAL;
    float3 m_tangent : TANGENT; 
    float3 m_bitangent : BITANGENT; 
    float3 m_worldPosition : UV0;
    float3 m_shadowCoords[ViewSrg::MaxCascadeCount] : UV3;

    // Extended fields (only referenced in this azsl file)...
    float2 m_uv[UvSetCount] : UV1;
    
    float3 m_blendMask : UV7;
};

#include <Atom/Features/Vertex/VertexHelper.azsli>

VSOutput ForwardPassVS(VSInput IN)
{
    VSOutput OUT;
 
    float4 worldPosition;
    VertexLocalToWorld(IN.m_position, worldPosition);

    EvaluateUVs(IN.m_uv, OUT.m_uv);

    EvaluateWorldSpaceTBN(IN.m_normal, IN.m_tangent, IN.m_bitangent, OUT.m_normal, OUT.m_tangent, OUT.m_bitangent);

    if(o_blendMask_isBound)
    {
        OUT.m_blendMask = IN.m_optional_blendMask.rgb;
    }
    else
    {
        OUT.m_blendMask = float3(0,0,0);
    }
    
    // Shadow coords will be calculated in the pixel shader in this case
    bool skipShadowCoords = ShouldHandleParallax() && o_parallax_enablePixelDepthOffset;
    if (o_enableShadows && !skipShadowCoords && shadowIndex < SceneSrg::m_directionalLightCount)
    {
        DirectionalLightShadow::GetShadowCoords(
            shadowIndex,
            worldPosition.xyz,
            OUT.m_normal,
            OUT.m_shadowCoords);
    }

    return OUT;
}

// ---------- Pixel Shader ----------

PbrLightingOutput ForwardPassPS_Common(VSOutput IN, bool isFrontFace, out float depthNDC)
{
    const float3 vertexNormal = normalize(IN.m_normal);
    depthNDC = IN.m_position.z;

    s_blendMaskFromVertexStream = IN.m_blendMask;

    // ------- Tangents & Bitangets -------
    float3 tangents[UvSetCount] = { IN.m_tangent.xyz, IN.m_tangent.xyz };
    float3 bitangents[UvSetCount] = { IN.m_bitangent.xyz, IN.m_bitangent.xyz };

    if ((o_parallax_feature_enabled && !o_enableSubsurfaceScattering)
        || o_layer1_o_normal_useTexture
        || o_layer2_o_normal_useTexture
        || o_layer3_o_normal_useTexture
        || o_layer1_o_clearCoat_normal_useTexture
        || o_layer2_o_clearCoat_normal_useTexture
        || o_layer3_o_clearCoat_normal_useTexture
        )
    {
        PrepareGeneratedTangent(
            vertexNormal, IN.m_tangent, IN.m_bitangent, IN.m_worldPosition,
            isFrontFace, IN.m_uv, UvSetCount, tangents, bitangents);
    }

    float3 blendMaskValues;
    float3 blendWeights;
    float height;
    Surface surface;
    surface.position = IN.m_worldPosition;
    surface.transmission.InitializeToZero();

    EvaluateOpaqueSurface_Blend(
        IN.m_blendMask,
        vertexNormal,
        IN.m_uv,
        tangents,
        bitangents,
        isFrontFace,
        blendMaskvalues,
        blendWeights,
        height,
        surface
    );

    // ------- Debug Modes -------

    if(o_debugDrawMode == DebugDrawMode::BlendMask)
    {
        return DebugOutput(blendMaskValues);
    }
    
    if(o_debugDrawMode == DebugDrawMode::Displacement)
    {
        return DebugOutput(float3(height,height,height));
    }
    
    if(o_debugDrawMode == DebugDrawMode::FinalBlendWeights)
    {
        return DebugOutput(blendWeights);
    }

    // ------- Parallax -------
    
    bool displacementIsClipped = false;

    if(ShouldHandleParallax())
    {
        EvaluateMultilayerPixelDepth(
            IN.m_blendMask,
            IN.m_position.z,
            IN.m_uv,
            IN.m_normal,
            tangents,
            bitangents,
            depthNDC
        );

        // Adjust directional light shadow coorinates for parallax correction
        if(o_parallax_enablePixelDepthOffset)
        {
            const uint shadowIndex = ViewSrg::m_shadowIndexDirectionalLight;
            if (o_enableShadows && shadowIndex < SceneSrg::m_directionalLightCount)
            {
                DirectionalLightShadow::GetShadowCoords(shadowIndex, IN.m_worldPosition, vertexNormal, IN.m_shadowCoords);
            }
        }
    }

    // ------- Init and Combine Lighting Data -------
    
    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);
    
    // Directional light shadow coordinates
    lightingData.shadowCoords = IN.m_shadowCoords;
    
    lightingData.emissiveLighting = surface.emissiveLighting;
    lightingData.specularOcclusion = surface.specularOcclusion;
    lightingData.diffuseAmbientOcclusion = surface.diffuseAmbientOcclusion;

    lightingData.CalculateMultiscatterCompensation(surface.specularF0, o_specularF0_enableMultiScatterCompensation);

    // Diffuse and Specular response (used in IBL calculations)
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - lightingData.specularResponse;

    if(o_clearCoat_feature_enabled)
    {
        // Clear coat layer has fixed IOR = 1.5 and transparent => F0 = (1.5 - 1)^2 / (1.5 + 1)^2 = 0.04
        lightingData.diffuseResponse *= 1.0 - (FresnelSchlickWithRoughness(lightingData.NdotV, float3(0.04, 0.04, 0.04), surface.clearCoat.roughness) * surface.clearCoat.factor);
    }
    
    // ------- Lighting Calculation -------

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData);

    // Apply Image Based Lighting (IBL)
    ApplyIBL(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting(0);


    const float alpha = 1.0;

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    lightingOutput.m_diffuseColor.w = -1; // Disable subsurface scattering

    return lightingOutput;
}

ForwardPassOutputWithDepth ForwardPassPS(VSOutput IN, bool isFrontFace : SV_IsFrontFace)
{
    ForwardPassOutputWithDepth OUT;
    float depth;

    PbrLightingOutput lightingOutput = ForwardPassPS_Common(IN, isFrontFace, depth);

    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_specularColor = lightingOutput.m_specularColor;
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;
    OUT.m_depth = depth;
    return OUT;
}

[earlydepthstencil]
ForwardPassOutput ForwardPassPS_EDS(VSOutput IN, bool isFrontFace : SV_IsFrontFace)
{
    ForwardPassOutput OUT;
    float depth;

    PbrLightingOutput lightingOutput = ForwardPassPS_Common(IN, isFrontFace, depth);

    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_specularColor = lightingOutput.m_specularColor;
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;

    return OUT;
}

