/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/ParallaxMapping.azsli>
#include <Atom/Features/MatrixUtility.azsli>

#include "../MaterialInputs/ParallaxInput.azsli"

struct UvDeltas
{
    float2 m_uvDelta[UvSetCount],
};

UvDeltas EvaluatePixelDepth(
    float depth,
    inout float2 uv[UvSetCount],
    float3 worldPosition,
    float3 normal,
    // Tangent spaces passed here correspond to uv sets
    float3 tangents[2],
    float3 bitangents[2],
    out float depth)
{
    UvDeltas deltas;
    // Save current uvs (we'll add the new uvs later to encode the delta)
    deltas.m_uvDelta[0] = -uv[0];
    deltas.m_uvDelta[1] = -uv[1];

    float3x3 uvMatrix = MaterialSrg::m_parallaxUvIndex == 0 ? MaterialSrg::m_uvMatrix : CreateIdentity3x3();
    float3x3 uvMatrixInverse = MaterialSrg::m_parallaxUvIndex == 0 ? MaterialSrg::m_uvMatrixInverse : CreateIdentity3x3();

    GetParallaxInput(normal, tangents[MaterialSrg::m_parallaxUvIndex], bitangents[MaterialSrg::m_parallaxUvIndex], MaterialSrg::m_heightmapScale, MaterialSrg::m_heightmapOffset,
                     ObjectSrg::GetWorldMatrix(), uvMatrix, uvMatrixInverse,
                     uv[MaterialSrg::m_parallaxUvIndex], worldPosition, depth);
    
    deltas.m_uvDelta[0] += uv[0];
    deltas.m_uvDelta[1] += uv[1];

    return deltas;
}