/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include "EvaluateEnhancedOpaqueSurface.azsli"

float EvaluateAlphaAndClip(float2 uv[UvSetCount])
{
    float2 baseColorUv = uv[MaterialSrg::m_baseColorMapUvIndex];
    float2 opacityUv = uv[MaterialSrg::m_opacityMapUvIndex];
    return GetAlphaInputAndClip(
        MaterialSrg::m_baseColorMap,
        MaterialSrg::m_opacityMap,
        baseColorUv,
        opacityUv,
        MaterialSrg::m_sampler,
        MaterialSrg::m_opacityFactor,
        o_opacity_source);
}

void EvaluateAlphaClipSurface(
    float3 normal,
    float2 uv[TotalUvSetCount],
    float3 tangents[UvSetCount],
    float3 bitangents[UvSetCount],
    bool isFrontFace,
    // NOTE: Surface::m_worldPosition expected to be populated already
    inout Surface OUT,
    out float alpha,
    // Modulate opacity at grazing angles
    // 0 -> Transparent material like glass (less transparent at grazing angles)
    // 1 -> Indicates absence of surface (Fresnel no longer applies)
    out float opacityAffectsSpecularFactor)
{
    alpha = EvaluateAlphaAndClip(uv);

    opacityAffectsSpecularFactor = MaterialSrg::m_opacityAffectsSpecularFactor;

    EvaluateEnhancedOpaqueSurface(normal, uv, detailUv, tangents, bitangents, isFrontFace, OUT);
}