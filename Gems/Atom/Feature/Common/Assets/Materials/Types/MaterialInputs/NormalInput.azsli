/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/Debug.azsli>
#include <Atom/RPI/TangentSpace.azsli>

// This file provides utilities for common handling of inputs for normal maps for PBR materials.

// These macros can be used to declare common shader inputs for this feature. 
// Use the COMMON_SRG_INPUTS_* macro in your material SRG definition, and use the COMMON_OPTIONS_* macro at the global scope in your shader. Then you can pass these variables to the Get*Input() function below.
// You can optionally provide a prefix for the set of inputs which corresponds to a prefix string supplied by the .materialtype file. This is common for multi-layered material types.

#define COMMON_SRG_INPUTS_NORMAL(prefix) \
float       prefix##m_normalFactor;      \
Texture2D   prefix##m_normalMap;         \
uint        prefix##m_normalMapUvIndex;  \
bool        prefix##m_flipNormalX;       \
bool        prefix##m_flipNormalY;

#define COMMON_OPTIONS_NORMAL(prefix) \
option bool prefix##o_normal_useTexture; 

//! Samples the normal map and returns the XY values of the normal. 
//! (Z must be reconstructed assuming length=1; this is handled by the various utility functions that take float2 in TangentSpace.azsli).
//! The returned XY values will be in the range [-1,1].
float2 SampleNormalXY(Texture2D map, sampler mapSampler, float2 uv)
{
    if (!AreNormalMapsEnabled())
    {
        return float2(0, 0);
    }

    float4 sampledValue = map.Sample(mapSampler, uv);
    
#if AZ_TRAIT_ASTC_COMPRESSION
    //Astc compression is unorm (0 to 1) so we need to accomodate for that. We are using BC5_SNORM (-1 - +1)for other platforms like pc
    //[GFX TODO][ATOM-13435] - Look into moving this offline as part of image processing.
    sampledValue =  (sampledValue * 2) - 1;
#endif

    return sampledValue.xy;
}

//! Samples the normal map and returns the XY values of the normal. 
//! (Z must be reconstructed assuming length=1; this is handled by the various utility functions that take float2 in TangentSpace.azsli).
//! The returned XY values will be in the range [-1,1].
//! Also flips X and/or Y if requested.
float2 SampleNormalXY(Texture2D map, sampler mapSampler, float2 uv, bool flipX, bool flipY)
{
    float2 sampledValue = SampleNormalXY(map, mapSampler, uv);

    // [GFX TODO][ATOM-2404] For some reason, the image build pipeline swaps the R and G channels
    if(flipX)
    {
        sampledValue.y = -sampledValue.y;
    }
    if(flipY)
    {
        sampledValue.x = -sampledValue.x;
    }
    return sampledValue;
}

// Flip normal if back face is rendered
float3 AdjustBackFaceNormal(float3 normal, bool isFrontFace)
{
    normal *= mad(isFrontFace, 2.0, -1.0);
    return normal;
}

// Get the input normal in world space
float3 GetNormalInputWS(Texture2D map, sampler mapSampler, float2 uv, bool flipX, bool flipY, bool isFrontFace,
                        float3 normal, float3 tangent, float3 bitangent, float3x3 uvMatrix, bool useTexture, float normalStrength)
{
    if (useTexture && AreNormalMapsEnabled())
    {
        float2 sampledValue = SampleNormalXY(map, mapSampler, uv, flipX, flipY);
        normal = GetWorldSpaceNormal(sampledValue, normal, tangent, bitangent, uvMatrix, normalStrength);
    }
    else
    {
        normal = normalize(normal);
    }

    normal = AdjustBackFaceNormal(normal, isFrontFace);
    return normal;
}

// Get the input normal in tangent space
float3 GetNormalInputTS(Texture2D map, sampler mapSampler, float2 uv, bool flipX, bool flipY, float3x3 uvMatrix, bool useTexture, float normalStrength)
{
    if (useTexture && AreNormalMapsEnabled())
    {
        float2 sampledValue = SampleNormalXY(map, mapSampler, uv, flipX, flipY);
        return GetTangentSpaceNormal(sampledValue, uvMatrix, normalStrength);
    }
    else
    {
        return float3(0.0f, 0.0f, 1.0f);
    }
}

// Helper with default normal strength = 1.0f
float3 GetNormalInputWS(Texture2D map, sampler mapSampler, float2 uv, bool flipX, bool flipY, bool isFrontFace,
                        float3 normal, float3 tangent, float3 bitangent, float3x3 uvMatrix, bool useTexture)
{
    const float normalStrength = 1.0f;
    return GetNormalInputWS(map, mapSampler, uv, flipX, flipY, isFrontFace, normal, tangent, bitangent, uvMatrix, useTexture, normalStrength);
}

// Helper with default normal strength = 1.0f
float3 GetNormalInputTS(Texture2D map, sampler mapSampler, float2 uv, bool flipX, bool flipY, float3x3 uvMatrix, bool useTexture)
{
    const float normalStrength = 1.0f;
    return GetNormalInputTS(map, mapSampler, uv, flipX, flipY, uvMatrix, useTexture, normalStrength);
}
