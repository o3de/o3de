/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

#include <Atom/Features/PBR/LightingOptions.azsli>

#include <viewsrg.srgi>
#include <scenesrg.srgi>

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>

#include <Atom/RPI/Math.azsli>
#include <Atom/RPI/TangentSpace.azsli>

#include <Atom/Features/PBR/DefaultObjectSrg.azsli>
#include <Atom/Features/PBR/ForwardPassSrg.azsli>

#include <Atom/Features/PBR/Lighting/StandardLighting.azsli>
#include <Atom/Features/PBR/Decals.azsli>

// VSInput, VSOutput, ObjectSrg must be defined before including this file.

// DEPRECATED: Please use the VertexHelper(...) function in VertexHelper.azsli instead.
//! @param skipShadowCoords can be useful for example when PixelDepthOffset is enable, because the pixel shader will have to run before the final world position is known
void PbrVsHelper(in VSInput IN, inout VSOutput OUT, float3 worldPosition, bool skipShadowCoords = false)
{
    OUT.m_worldPosition = worldPosition;
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(OUT.m_worldPosition, 1.0));
    
    float4x4 objectToWorld = ObjectSrg::GetWorldMatrix();
    float3x3 objectToWorldIT = ObjectSrg::GetWorldMatrixInverseTranspose();

    ConstructTBN(IN.m_normal, IN.m_tangent, IN.m_bitangent, objectToWorld, objectToWorldIT, OUT.m_normal, OUT.m_tangent, OUT.m_bitangent);
    
    // directional light shadow 
    const uint shadowIndex = ViewSrg::m_shadowIndexDirectionalLight;
    if (o_enableShadows && !skipShadowCoords && shadowIndex < SceneSrg::m_directionalLightCount)
    {
        DirectionalLightShadow::GetShadowCoords(
            shadowIndex,
            worldPosition,
            OUT.m_shadowCoords);
    }
}


// DEPRECATED: Please use the functions in StandardLighting.azsli instead.
// For an example on how to use those functions, see StandardPBR_forwardPass.azsl
PbrLightingOutput PbrLighting(  VSOutput IN,
                                float3 baseColor,
                                float metallic,
                                float roughness,
                                float specularF0Factor,
                                float3 normal,
                                float3 vtxTangent,
                                float3 vtxBitangent,
                                float2 anisotropy,  // angle and factor
                                float3 emissive,
                                float diffuseAmbientOcclusion,
                                float specularOcclusion,
                                float4 transmissionTintThickness,
                                float4 transmissionParams,
                                float clearCoatFactor,
                                float clearCoatRoughness,
                                float3 clearCoatNormal,
                                float alpha,
                                OpacityMode opacityMode)
{
    float3 worldPosition = IN.m_worldPosition;
    float4 position = IN.m_position;
    float3 shadowCoords[ViewSrg::MaxCascadeCount] = IN.m_shadowCoords;

    // ______________________________________________________________________________________________
    // Surface

    Surface surface;

    surface.position = worldPosition;
    surface.normal = normal;
    surface.roughnessLinear = roughness;
    surface.transmission.tint = transmissionTintThickness.rgb;
    surface.transmission.thickness = transmissionTintThickness.w;
    surface.transmission.transmissionParams = transmissionParams;
    surface.clearCoat.factor = clearCoatFactor;
    surface.clearCoat.roughness = clearCoatRoughness;
    surface.clearCoat.normal = clearCoatNormal;

    surface.CalculateRoughnessA();
    surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);
    surface.anisotropy.Init(normal, vtxTangent, vtxBitangent, anisotropy.x, anisotropy.y, surface.roughnessA);

    // ______________________________________________________________________________________________
    // LightingData

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);
    
    lightingData.emissiveLighting = emissive;
    lightingData.diffuseAmbientOcclusion = diffuseAmbientOcclusion;
    lightingData.specularOcclusion = specularOcclusion;

    // Directional light shadow coordinates
    lightingData.shadowCoords = shadowCoords;

    // manipulate base layer f0 if clear coat is enabled
    if(o_clearCoat_feature_enabled)
    {
        // modify base layer's normal incidence reflectance
        // for the derivation of the following equation please refer to:
        // https://google.github.io/filament/Filament.md.html#materialsystem/clearcoatmodel/baselayermodification
        float3 f0 = (1.0 - 5.0 * sqrt(surface.specularF0)) / (5.0 - sqrt(surface.specularF0));
        surface.specularF0 = lerp(surface.specularF0, f0 * f0, clearCoatFactor);
    }

    // Diffuse and Specular response (used in IBL calculations)
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - lightingData.specularResponse;

    if(o_clearCoat_feature_enabled)
    {
        // Clear coat layer has fixed IOR = 1.5 and transparent => F0 = (1.5 - 1)^2 / (1.5 + 1)^2 = 0.04
        lightingData.diffuseResponse *= 1.0 - (FresnelSchlickWithRoughness(lightingData.NdotV, float3(0.04, 0.04, 0.04), surface.clearCoat.roughness) * surface.clearCoat.factor);
    }

    // Multiscatter compensation factor
    lightingData.CalculateMultiscatterCompensation(surface.specularF0, o_specularF0_enableMultiScatterCompensation);

    // ______________________________________________________________________________________________
    // Lighting

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData);

    // Apply Image Based Lighting (IBL)
    ApplyIBL(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting(surface.transmission.tint);

    if (o_opacity_mode == OpacityMode::Blended || o_opacity_mode == OpacityMode::TintedTransparent)
    {
        alpha = FresnelSchlickWithRoughness(lightingData.NdotV, alpha, surface.roughnessLinear).x; // Increase opacity at grazing angles.
    }

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    return lightingOutput;
}

//! Populates a PbrLightingOutput struct with values that can be used to render a simple debug color in the PBR pipeline.
//! Note that this will not give you a the exact color screen pixels since it is used in the PBR pipeline, it may
//! still have lighting or other affects applied on top of it. But this is still a convenient way to quickly get some
//! colors on screen.
//! @param IN the pixel shader input structure
//! @param debugColor the color to be drawn
//! @param normalWS world space normal vector
//! @return a PbrLightingOutput as returned by the main PbrLighting() function

PbrLightingOutput MakeDebugOutput(VSOutput IN, float3 debugColor, float3 normalWS)
{
    // We happen to set this up initially using baseColor, but we could consider adding an option to use
    // emissive instead to avoid depending on scene lighting.
    const float3 baseColor = debugColor;
    const float metallic = 0;
    const float roughness = 1;
    const float specularF0Factor = 0.5;
    const float3 normal = normalWS;
    const float3 emissive = {0,0,0};
    const float occlusion = 1;
    const float clearCoatFactor = 0.0f;
    const float clearCoatRoughness = 0.0f;
    const float3 clearCoatNormal = {0,0,0};
    const float4 transmissionTintThickness = {0,0,0,0};
    const float4 transmissionParams = {0,0,0,0};
    const float2 anisotropy = 0.0;	// Does not affect calculations unless 'o_enableAnisotropy' is enabled
    const float alpha = 1.0;

    PbrLightingOutput lightingOutput = PbrLighting(IN, baseColor, metallic, roughness, specularF0Factor, 
        normal, IN.m_tangent, IN.m_bitangent, anisotropy,
        emissive, occlusion, occlusion, transmissionTintThickness, transmissionParams, clearCoatFactor, clearCoatRoughness, clearCoatNormal, alpha, OpacityMode::Opaque);

    return lightingOutput;
}

//! Same as above, using the vertex normal
PbrLightingOutput MakeDebugOutput(VSOutput IN, float3 debugColor)
{
    return MakeDebugOutput(IN, debugColor, normalize(IN.m_normal));
}
