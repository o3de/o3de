/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once


#if ENABLE_POLYGON_LTC_LIGHTS

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
#include <Atom/Features/PBR/Lights/Ltc.azsli>
#include <Atom/RPI/Math.azsli>


#ifndef PolygonLightUtil
#define PolygonLightUtil PolygonLightUtil_PBR
#endif


class PolygonLightUtil_PBR
{

    real3 posToLight;
    real distanceToLight2;
    bool doubleSided;
    real falloff;

    static PolygonLightUtil_PBR Init(PolygonLight light, Surface surface, float3 cameraPositionWS)
    {
        PolygonLightUtil_PBR result;
        result.posToLight = light.m_position - surface.position;
        result.distanceToLight2 = dot(result.posToLight, result.posToLight); // light distance squared
        result.falloff = result.distanceToLight2 * abs(light.m_invAttenuationRadiusSquared);
    
        result.doubleSided = light.m_invAttenuationRadiusSquared < 0.0;
        if (!result.doubleSided)
        {
            if (dot(result.posToLight, -light.m_direction) <= 0.0)
            {
                result.falloff = 1.0f; // Light isn't facing the surface
            }
        }
        return result;
    }

    real GetFalloff()
    {
        return falloff;
    }

    void Apply(PolygonLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at the attenuation radius
        
        uint startIndex = ViewSrg::PolygonLightGetStartIndex(light.m_startEndIndex);
        uint endIndex = ViewSrg::PolygonLightGetEndIndex(light.m_startEndIndex);
        
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        float diffuse = 0.0;
        float3 specularRgb = 0.0;

        LtcPolygonEvaluate(surface, lightingData, SceneSrg::m_ltcMatrix, SceneSrg::m_ltcAmplification, ViewSrg::m_polygonLightPoints, startIndex, endIndex, diffuse, specularRgb);

        diffuse = doubleSided ? abs(diffuse) : max(0.0, diffuse);
        specularRgb = doubleSided ? abs(specularRgb) : max(0.0, specularRgb);

        // Scale by inverse surface area of hemisphere (1/2pi), attenuation, and light intensity
        float3 intensity = 0.5 * INV_PI * radiusAttenuation * abs(light.m_rgbIntensityNits);

        lightingData.diffuseLighting += surface.albedo * diffuse * intensity * litRatio;
        lightingData.specularLighting += specularRgb * intensity * litRatio;

    }
};

#endif // ENABLE_POLYGON_LTC_LIGHTS
