/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once


#if ENABLE_POLYGON_LTC_LIGHTS

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
#include <Atom/Features/PBR/Lights/Ltc.azsli>
#include <Atom/RPI/Math.azsli>


#ifndef PolygonLightUtil
#define PolygonLightUtil PolygonLightUtil_PBR
#endif


class PolygonLightUtil_PBR
{

    real3 m_posToLight;
    real m_distanceToLight2;
    bool m_doubleSided;
    real m_falloff;

    static PolygonLightUtil_PBR Init(PolygonLight light, Surface surface)
    {
        PolygonLightUtil_PBR result;
        result.m_posToLight = light.m_position - surface.position;
        result.m_distanceToLight2 = dot(result.m_posToLight, result.m_posToLight); // light distance squared
        result.m_falloff = result.m_distanceToLight2 * abs(light.m_invAttenuationRadiusSquared);
    
        result.m_doubleSided = light.m_invAttenuationRadiusSquared < 0.0;
        if (!result.m_doubleSided)
        {
            if (dot(result.m_posToLight, -light.m_direction) <= 0.0)
            {
                result.m_falloff = 1.0f; // Light isn't facing the surface
            }
        }
        return result;
    }

    real GetFalloff()
    {
        return m_falloff;
    }

    void Apply(PolygonLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at the attenuation radius
        
        uint startIndex = ViewSrg::PolygonLightGetStartIndex(light.m_startEndIndex);
        uint endIndex = ViewSrg::PolygonLightGetEndIndex(light.m_startEndIndex);
        
        float radiusAttenuation = 1.0 - (m_falloff * m_falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Scale by inverse surface area of hemisphere (1/2pi), attenuation, and light intensity
        float3 intensity = 0.5 * INV_PI * radiusAttenuation * abs(light.m_rgbIntensityNits);

        // Calculate lighting for each view
        [unroll]
        for (uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
        {

            float diffuse = 0.0;
            float3 specularRgb = 0.0;

            LtcPolygonEvaluate(surface, lightingData, SceneSrg::m_ltcMatrix, SceneSrg::m_ltcAmplification, ViewSrg::m_polygonLightPoints, startIndex, endIndex, viewIndex, diffuse, specularRgb);

            diffuse = m_doubleSided ? abs(diffuse) : max(0.0, diffuse);
            specularRgb = m_doubleSided ? abs(specularRgb) : max(0.0, specularRgb);

            // Only add diffuse lighting once (for the first view)
            if (viewIndex == 0)
            {
                lightingData.diffuseLighting += surface.albedo * diffuse * intensity * litRatio;
            }
            lightingData.specularLighting[viewIndex] += specularRgb * intensity * litRatio;
        }
    }
};

#endif // ENABLE_POLYGON_LTC_LIGHTS
