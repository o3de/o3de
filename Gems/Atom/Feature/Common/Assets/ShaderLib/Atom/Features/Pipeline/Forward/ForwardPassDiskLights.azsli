#pragma once

#include <Atom/Features/LightCulling/LightCullingTileIterator.azsli>

// the DiskLight class is defined by the Material, but usually points to Atom/Features/Light/PBR/DiskLight.azsli

#if ENABLE_DISK_LIGHTS

#if ENABLE_SHADOWS
#include <Atom/Features/Shadow/ProjectedShadow.azsli>
#endif


#ifndef DiskLightUtil
#error "DiskLightUtil needs to be defined"
#endif // DiskLightUtil

void ApplyDiskLight(int lightIndex, Surface surface, inout LightingData lightingData)
{
    DiskLight srgLight = ViewSrg::m_diskLights[lightIndex];

    if (!IsSameLightChannel(srgLight.m_lightingChannelMask, surface.lightingChannels))
    {
        return;
    }

    DiskLightUtil light = DiskLightUtil::Init(srgLight, surface, ViewSrg::m_worldPosition);

    if (light.GetFalloff() >= 1.0f)
    {
        return;
    }

    real litRatio = 1.0f;

#if ENABLE_SHADOWS
    if (o_enableShadows && o_enableDiskLightShadows)
    {
        litRatio = ProjectedShadow::GetVisibility(
                srgLight.m_shadowIndex,
                srgLight.m_position,
                surface.position,
                -light.GetDirectionToConeTip(),
                surface.vertexNormal);
             
        real transmissionDistance = -1.0f;
        // o_transmission_mode == NONE is not taken into account because GetBackLighting already ignores this case
#if ENABLE_TRANSMISSION            
        if (o_transmission_mode == TransmissionMode::ThickObject)
        {
            transmissionDistance = ProjectedShadow::GetThickness(srgLight.m_shadowIndex, surface.position);
        }
        else if (o_transmission_mode == TransmissionMode::ThinObject)
        {
            transmissionDistance = ProjectedShadow::GetThickness(srgLight.m_shadowIndex, surface.position - surface.transmission.GetShrinkFactor() * surface.vertexNormal);
        }
        light.SetTransmissionDistance(transmissionDistance);
#endif // ENABLE_TRANSMISSION
    }
#endif // ENABLE_SHADOWS

#if ENABLE_AREA_LIGHT_VALIDATION
    if (o_area_light_validation)
    {
        light.ApplySampled(srgLight, surface, lightingData);
    }
    else
#endif // ENABLE_AREA_LIGHT_VALIDATION
    {
        light.Apply(srgLight, surface, litRatio, lightingData);
    }
}


void ApplyDiskLights(Surface surface, inout LightingData lightingData, inout LightCullingTileIterator tileIterator)
{
#if ENABLE_LIGHT_CULLING
    tileIterator.LoadAdvance();    
    while( !tileIterator.IsDone() ) 
    { 
        uint currLightIndex = tileIterator.GetValue(); 
        tileIterator.LoadAdvance();
        ApplyDiskLight(currLightIndex, surface, lightingData);
    }
#else

    for(uint lightIndex = 0; lightIndex < ViewSrg::m_pointLightCount; lightIndex++)
    {
        ApplyDiskLight(lightIndex, surface, lightingData);
    }
#endif /* ENABLE_LIGHT_CULLING */
}
#else 
void ApplyDiskLights(Surface surface, inout LightingData lightingData, inout LightCullingTileIterator tileIterator)
{
    // empty
}
#endif /* ENABLE_DISK_LIGHTS */


