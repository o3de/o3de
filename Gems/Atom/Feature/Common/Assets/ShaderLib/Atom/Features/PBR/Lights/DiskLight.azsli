/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#if ENABLE_DISK_LIGHTS

#ifndef DiskLightUtil
#define DiskLightUtil DiskLightUtil_PBR
#endif

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

class DiskLightUtil_PBR
{
    real3 surfaceToLight;
    real3 surfaceToLightDirection;
    real  lightDistanceSquared;
    
    real3 dirToConeTip;
    real  dotWithDirection;

    real  falloff;
    real  angleFalloff;


#if ENABLE_TRANSMISSION
    // Distance travelled by the light inside the object. If not redefined to a non-negative value, it will take the following behavior:
    // - If transmission mode is thick object -> use transmission thickness parameter instead
    // - If transmission mode is thin object -> ignore back lighting
    real transmissionDistance;
#endif

    static DiskLightUtil_PBR Init(DiskLight light, Surface surface, float3 cameraPositionWS)
    {
        DiskLightUtil_PBR result;
        result.surfaceToLight = light.m_position - surface.position;
        result.lightDistanceSquared = dot(result.surfaceToLight, result.surfaceToLight); // light distance squared
        result.falloff = result.lightDistanceSquared * light.m_invAttenuationRadiusSquared;
        result.surfaceToLightDirection = normalize(result.surfaceToLight);

        // Reduce the brightness based on how much the disk is facing this pixel.
        result.angleFalloff = dot(result.surfaceToLightDirection, -light.m_direction);
    
        bool useConeAngle = light.m_flags & DiskLightFlag::UseConeAngle;
        if (useConeAngle)
        {
            float3 coneTipPosition = light.m_position + light.m_bulbPositionOffset * -light.m_direction;
            result.dirToConeTip = normalize(coneTipPosition - surface.position);
            result.dotWithDirection = dot(result.dirToConeTip, -normalize(light.m_direction));
            if (result.dotWithDirection < light.m_cosOuterConeAngle)
            {
                // outside of the outer cone: Make sure we return a falloff-value of 1 so Apply() wont be called
                result.angleFalloff = 0.0f;
            }
        }
        return result;
    }

    real3 GetSurfaceToLightDirection()
    {
        return surfaceToLightDirection;
    }

#if ENABLE_TRANSMISSION
    void SetTransmissionDistance(real distance)
    {
        transmissionDistance = distance;
    }
#endif

    real GetFalloff()
    {
        return select(angleFalloff > 0.0f, falloff, 1.0f);
    }

    real3 GetDirectionToConeTip()
    {
        return dirToConeTip;
    }

    void Apply(DiskLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;
        
        // Find the distance to the closest point on the disk
        float distanceToPlane = dot(surfaceToLight, -light.m_direction);
        float distanceToPlane2 = distanceToPlane * distanceToPlane;
        float pointOnPlaneToLightDistance = sqrt(lightDistanceSquared - distanceToPlane2); // pythagorean theorem 
        float pointOnPlaneToDiskDistance = max(pointOnPlaneToLightDistance - light.m_diskRadius, 0.0f); 
        float distanceToDisk2 = pointOnPlaneToDiskDistance * pointOnPlaneToDiskDistance + distanceToPlane2;

        // Update the light direction based on the edges of the disk as visible from this point instead of the center.
        float3 pointOnPlane = -light.m_direction * distanceToPlane;
        float3 pointOnPlaneToLightDir = normalize(surfaceToLight - pointOnPlane);
        float3 nearSideDir = normalize(pointOnPlane + pointOnPlaneToLightDir * (pointOnPlaneToLightDistance - light.m_diskRadius));
        float3 farSideDir = normalize(pointOnPlane + pointOnPlaneToLightDir * (pointOnPlaneToLightDistance + light.m_diskRadius));
        float3 posToLightDir = normalize((nearSideDir + farSideDir) * 0.5);

        // Standard quadratic falloff
        lightDistanceSquared = max(0.001 * 0.001, lightDistanceSquared); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / lightDistanceSquared) * radiusAttenuation * angleFalloff;

        // Adjust brightness based on the disk size relative to its distance.
        // The larger the disk is relative to the surface point, the dimmer it becomes.
        // 0 radius disks are unaffected.
        lightIntensity /= ((light.m_diskRadius / distanceToPlane) + 1.0);

        bool useConeAngle = light.m_flags & DiskLightFlag::UseConeAngle;
        if (useConeAngle && dotWithDirection < light.m_cosInnerConeAngle) // in penumbra
        {   
            // Normalize into 0.0 - 1.0 space.
            float penumbraMask = (dotWithDirection - light.m_cosOuterConeAngle) / (light.m_cosInnerConeAngle - light.m_cosOuterConeAngle);
            
            // Apply smoothstep
            penumbraMask = penumbraMask * penumbraMask * (3.0 - 2.0 * penumbraMask);
            
            lightIntensity *= penumbraMask;
        }

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, posToLightDir) * litRatio;

        // Transmission contribution
#if ENABLE_TRANSMISSION
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, lightIntensity, posToLightDir, transmissionDistance, lightDistanceSquared) * litRatio;
#endif

        // Adjust the light direction for specular based on disk size

        // Calculate the reflection off the normal from the view direction
        float3 reflectionDir = reflect(-lightingData.dirToCamera, surface.GetSpecularNormal());
        float reflectionDotLight = dot(reflectionDir, -light.m_direction);
        
        // Let 'Intersection' denote the point where the reflection ray intersects the diskLight plane
        // As such, posToIntersection denotes the vector from pos to the intersection of the reflection ray and the disk plane:
        float3 posToIntersection;
        
        if (reflectionDotLight >= 0.0001)
        {
            // Reflection going towards the light
            posToIntersection = reflectionDir * distanceToPlane / reflectionDotLight;
        }
        else
        {
            // Reflection going away from the light. Choose a point far off and project it on the plane,
            // then treat that as the reflection plane intersection.
            float3 posToFarOffPoint = reflectionDir * distanceToPlane * 10000.0;
            float3 lightToFarOffPoint = posToFarOffPoint - surfaceToLight;
            float3 intersectionToFarOffPoint = dot(lightToFarOffPoint, light.m_direction) * light.m_direction;
            posToIntersection = posToFarOffPoint - intersectionToFarOffPoint;
        }
    
        // Calculate a vector from the reflection vector to the light
        float3 intersectionToLight = surfaceToLight - posToIntersection;

        // Adjust the direction to light based on the bulb size
        surfaceToLight -= intersectionToLight * saturate(light.m_diskRadius / length(intersectionToLight));

        // Adjust the intensity of the light based on the bulb size to conserve energy
        float diskIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, light.m_diskRadius, lightDistanceSquared);

        // Specular contribution
        lightingData.specularLighting += diskIntensityNormalization * GetSpecularLighting(surface, lightingData, lightIntensity, normalize(surfaceToLight)) * litRatio;

    }

    void ApplySampled(DiskLight light, Surface surface, inout LightingData lightingData, const uint sampleCount = 512)
    {

        float3 diffuseAcc = float3(0.0, 0.0, 0.0);
        float3 specularAcc = float3(0.0, 0.0, 0.0);
        float3 translucentAcc = float3(0.0, 0.0, 0.0);

        for (uint i = 0; i < sampleCount; ++i)
        {
            float2 randomPoint = GetHammersleyPoint(i, sampleCount);
            float3 samplePoint = SampleDisk(randomPoint, light);
            AddSampleContribution(surface, lightingData, samplePoint, light.m_direction, 0.0, diffuseAcc, specularAcc, translucentAcc);
        }
        
        lightingData.diffuseLighting += (diffuseAcc / float(sampleCount)) * light.m_rgbIntensityCandelas;
        lightingData.specularLighting += (specularAcc / float(sampleCount)) * light.m_rgbIntensityCandelas;
    }
};

#endif // ENABLE_DISK_LIGHTS
