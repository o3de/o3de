/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#if ENABLE_CAPSULE_LIGHTS

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

#ifndef CapsuleLightUtil
#define CapsuleLightUtil CapsuleLightUtil_PBR
#endif

class CapsuleLightUtil_PBR
{
    real  m_lightLength;
    real3 m_startPoint;
    real3 m_startToEnd;
    real3 m_endPoint;
    real3 m_surfaceToStart;
    real  m_closestPointDistance;
    real3 m_dirToClosestPoint;
    real  m_d2;
    real  m_falloff;

    static CapsuleLightUtil_PBR Init(CapsuleLight light, Surface surface)
    {
        CapsuleLightUtil_PBR result;

        result.m_lightLength = light.m_length;
        result.m_startPoint = light.m_startPoint;
        result.m_startToEnd = light.m_direction * result.m_lightLength;
        result.m_endPoint = result.m_startPoint + result.m_startToEnd;
        
        // Do simple distance check to line for m_falloff and tight culling.
        result.m_surfaceToStart = result.m_startPoint - surface.position;
        result.m_closestPointDistance = dot(-result.m_surfaceToStart, light.m_direction);
        result.m_closestPointDistance = clamp(result.m_closestPointDistance, 0.0f, result.m_lightLength);

        result.m_dirToClosestPoint = result.m_surfaceToStart + result.m_closestPointDistance * light.m_direction;
        result.m_d2 = dot(result.m_dirToClosestPoint, result.m_dirToClosestPoint);
        result.m_falloff = result.m_d2 * light.m_invAttenuationRadiusSquared;
        return result;
    }

    real GetFalloff()
    {
        return m_falloff;
    }

    void Apply(CapsuleLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (m_falloff * m_falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Check if the capsule intersects the plane formed by the surface normal. If so, the capsule should be
        // truncated to just the portion above the plane.
        float startProjection = dot(surface.GetDiffuseNormal(), m_surfaceToStart);
        float lengthProjection = dot(surface.GetDiffuseNormal(), m_startToEnd);
        float startOverLength = startProjection / lengthProjection;
        float ratioVisible = 1.0;

        // Check if part of the capsule light is behind the surface
        // If startOverLength is less than -1.0, then the length isn't great enough to cross the surface plane
        // If startOverLength is positive, the capsule start and capsule direction are on the same side of the surface plane
        if (-1.0f < startOverLength && startOverLength < 0.0)
        {
            startOverLength = abs(startOverLength);

            // clamp the capsule light to above the surface
            if (startProjection < 0.0f)
            {
                // start point is behind the surface, so move it
                m_startPoint = m_startPoint + m_lightLength * startOverLength * light.m_direction;
                ratioVisible = 1.0 - startOverLength;
                m_lightLength *= ratioVisible;
                m_surfaceToStart = m_startPoint - surface.position;
            }
            else
            {
                // end point is behind the surface so adjust the capsule length
                m_lightLength *= startOverLength;
                ratioVisible = startOverLength;
                m_endPoint = light.m_startPoint + light.m_direction * m_lightLength;
            }
            m_startToEnd = light.m_direction * m_lightLength;
        }

        // Calculate the distances to start and end
        float distanceToStart = length(m_surfaceToStart);
        float3 surfaceToEnd = m_endPoint - surface.position;
        float distanceToEnd = length(surfaceToEnd);

        // Integration of lambert reflectance of a line segment to get diffuse intensity
        // See https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
        float NdotStart = dot(surface.GetDiffuseNormal(), m_surfaceToStart) / distanceToStart;
        float NdotEnd =  dot(surface.GetDiffuseNormal(), surfaceToEnd) / distanceToEnd;
        float intensity = (NdotStart + NdotEnd) / (distanceToStart * distanceToEnd + dot(m_surfaceToStart, surfaceToEnd));
        intensity *= INV_PI; // normalize for lambert reflectance.

        float3 lightIntensity = (intensity * radiusAttenuation * ratioVisible) * light.m_rgbIntensityCandelas;
        lightingData.diffuseLighting += max(0.0, surface.albedo * lightIntensity) * litRatio;

#if ENABLE_TRANSMISSION
        // Transmission contribution
        // We cannot compute the actual transmission distance so we want to:
        // - If transmission mode is thick object -> use transmission thickness parameter instead
        // - If transmission mode is thin object -> ignore back lighting
        // To detect and apply this behavior in the GetBackLighting function, we need to use a negative transmissionDistance
        const float transmissionDistance = -1.0f;
        // If the transmissionDistance is ignored then the attenuation distance (only used on thin objects) does not have any influence
        const float attenuationDistance = 0.0f;

        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, lightIntensity, normalize(m_dirToClosestPoint), transmissionDistance, attenuationDistance) * litRatio;
#endif

        // Calculate specular lighting for each view
        [unroll]
        for (uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
        {
            // Calculate the reflection of the normal from the view direction
            float3 reflectionDir = reflect(-lightingData.dirToCamera[viewIndex], surface.GetSpecularNormal());

            // Find closest point on light to reflection vector.
            // See https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
            float reflDotm_startToEnd = dot(reflectionDir, m_startToEnd);
            float closestT = (dot(reflectionDir, m_surfaceToStart) * reflDotm_startToEnd - dot(m_surfaceToStart, m_startToEnd)) / (dot(m_startToEnd, m_startToEnd) - reflDotm_startToEnd * reflDotm_startToEnd);
            closestT = saturate(closestT);

            float3 closestIntersectionPoint = m_startPoint + closestT * m_startToEnd;
            float3 posToLight = closestIntersectionPoint - surface.position;

            // Calculate the offset from the nearest point on the reflection vector to the nearest point on the capsule light
            float3 posToClosestPointAlongReflection = dot(posToLight, reflectionDir) * reflectionDir;
            float3 lightReflectionOffset = posToLight - posToClosestPointAlongReflection;

            // Adjust the direction to light based on the capsule radius
            posToLight -= lightReflectionOffset * saturate(light.m_radius / length(lightReflectionOffset));
            m_d2 = dot(posToLight, posToLight);
            m_d2 = max(light.m_radius * light.m_radius, m_d2);

            // Adjust the intensity of the light based on the capsule radius to conserve energy
            float sphereIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, light.m_radius, m_d2);

            // Capsule specular is done just like spherical specular, we just move the position of the sphere along the capsule depending
            // on the point being shaded. However this means that the intensity needs to be reduced by the ratio of the capsule surface
            // area to a sphere of the same radius.
            float sphereToCapsuleAreaRatio = 2.0 * light.m_radius / max(2.0 * light.m_radius + light.m_length, EPSILON);

            // Specular contribution
            float3 viewLightIntensity = sphereToCapsuleAreaRatio * radiusAttenuation / m_d2;
            viewLightIntensity *= light.m_rgbIntensityCandelas;
            lightingData.specularLighting[viewIndex] += sphereIntensityNormalization * GetSpecularLighting(surface, lightingData, viewLightIntensity, normalize(posToLight), viewIndex) * litRatio;
        }
    }

    static void ApplySampled(CapsuleLight light, Surface surface, inout LightingData lightingData, const uint sampleCount = 1024)
    {
        float capArea =  4.0 * PI * light.m_radius * light.m_radius;
        float cylinderArea = 2.0 * PI * light.m_radius * light.m_length;
        float capToCylinderAreaRatio = capArea / (capArea + cylinderArea);
        
        // Construct local to world matrix for transforming sample points.
        float3x3 localToWorld;
        localToWorld[0] = light.m_direction;
        if (abs(light.m_direction.z) > 0.9)
        {
            // If vector is close to aligned with z axis choose y as up.
            localToWorld[2] = normalize(cross(light.m_direction, float3(0.0, 1.0, 0.0)));
        }
        else
        {
            localToWorld[2] = normalize(cross(light.m_direction, float3(0.0, 0.0, 1.0)));
        }
        localToWorld[1]= cross(localToWorld[0], localToWorld[2]);

        real3 diffuseAcc = float3(0.0, 0.0, 0.0);
        real3 translucentAcc = float3(0.0, 0.0, 0.0);
        real3 specularAcc[MAX_SHADING_VIEWS]; 

        [unroll]
        for (uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
            specularAcc[viewIndex] = float3(0.0, 0.0, 0.0);

        for (uint i = 0; i < sampleCount; ++i)
        {
            float3 position;
            float3 direction;
            float2 randomPoint = GetHammersleyPoint(i, sampleCount);
            SampleCapsule(randomPoint, light, capToCylinderAreaRatio, localToWorld, position, direction);
            AddSampleContribution(surface, lightingData, position, direction, 0.0, diffuseAcc, specularAcc, translucentAcc);
        }

        // Lighting value is in Candela, convert to Lumen for total light output of the light
        float3 intensityLumens = light.m_rgbIntensityCandelas * 4.0 * PI;
        // Each of the N samples will contribute intensity / N lumens. However it will radiate in
        // equal directions across the hemisphere, so we need to account for that
        float3 intensity = intensityLumens * INV_PI;
        
        lightingData.diffuseLighting += (diffuseAcc / float(sampleCount)) * intensity;
        [unroll]
        for (uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
            lightingData.specularLighting[viewIndex] += (specularAcc[viewIndex] / float(sampleCount)) * intensity;

#if ENABLE_TRANSMISSION
        lightingData.translucentBackLighting += (translucentAcc / float(sampleCount)) * intensity;
#endif
    }
};

#endif // ENABLE_CAPSULE_LIGHTS
