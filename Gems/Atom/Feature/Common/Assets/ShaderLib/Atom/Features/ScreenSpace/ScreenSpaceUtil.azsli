/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */
#include <viewsrg.srgi>

// Given a depthStencil depth and the fragment XY position, reconstruct the world space position
// screenCoords - from 0.. dimension of the screen of the current pixel
// depthStencilTexture - the depth stencil buffer (non linear depth)
// sDepth - zbuffer non linear depth at the fragment location


float4 WorldPositionFromDepthBuffer(const float2 UV, const float zDepth )
{ 
    float x = UV.x * 2.0f - 1.0f;
    float y = (1.0f - UV.y) * 2.0f - 1.0f;
    float4 projectedPos = float4(x, y, zDepth, 1.0f);    // warped projected space [0..1]
    float4 positionVS = mul(ViewSrg::m_projectionMatrixInverse, projectedPos);

    positionVS /= positionVS.w;
    float4 positionWS = mul(ViewSrg::m_viewMatrixInverse, positionVS);
    return positionWS;
}

float4 WorldPositionFromDepthBuffer(const float2 depthBufferDimensions, const float zDepth, const float2 screenCoords )
{ 
    float2 UV = saturate(screenCoords / depthBufferDimensions);
    return WorldPositionFromDepthBuffer(UV, zDepth);
}
 
float4 WorldPositionFromDepthBuffer(const Texture2D<float2> depthStencilTexture, const float zDepth, const float2 screenCoords )
{ 
    uint2 dimensions;
    depthStencilTexture.GetDimensions(dimensions.x, dimensions.y);
    return WorldPositionFromDepthBuffer(dimensions, zDepth, screenCoords);
}

float4 WorldPositionFromDepthBufferMS(const Texture2DMS<float2> depthStencilTexture, const float zDepth, const float2 screenCoords )
{ 
    uint2 dimensions;
    uint sampleCount;
    depthStencilTexture.GetDimensions(dimensions.x, dimensions.y, sampleCount);
    return WorldPositionFromDepthBuffer(dimensions, zDepth, screenCoords);
}

//! Calculates the view position and normal from the fragment position.
void ViewPositionAndNormalFromDepth(const Texture2DMS<float2> depthStencilTexture, const VSOutput IN, out float3 outPositionWS, out float3 outNormalWS)
{
    uint2 dimensions;
    depthStencilTexture.GetDimensions(dimensions.x, dimensions.y);
    const float2 pixelSize = recip(dimensions); // How big a pixel is in screen UV space
    const float2 halfPixel = pixelSize * 0.5f; 
    const int2   screenPos = IN.m_position.xy;  // The coordinates of the screen pixel being shaded
    const float2 screenUV  = IN.m_texCoord.xy;  // The UV value [0, 1] of the screen pixel

    // Do 2 depth gather ops to get 5 depth values (cross centered on pixel being shaded). Reminder that gather is laid out like so:
    //  W Z
    //  X Y
    float4 depthUpLeft = depthStencilTexture.Gather(PassSrg::PointSampler, screenUV - halfPixel);
    float4 depthBottomRight = depthStencilTexture.Gather(PassSrg::PointSampler, screenUV + halfPixel);

    depthUpLeft = CalculateLinearDepth(depthUpLeft);
    depthBottomRight = CalculateLinearDepth(depthBottomRight);

    float3 positionVS = ViewSrg::GetViewSpacePosition(screenUV, depthUpLeft.y);

    float3 diffX;
    {
        float3 positionLeft  = ViewSrg::GetViewSpacePosition( float2(screenUV.x - pixelSize.x, screenUV.y), depthUpLeft.x);
        float3 positionRight = ViewSrg::GetViewSpacePosition( float2(screenUV.x + pixelSize.x, screenUV.y), depthBottomRight.z);
        float3 diffLeft = positionVS - positionLeft;
        float3 diffRight = positionRight - positionVS;
        diffX = (abs(diffLeft.z) < abs(diffRight.z)) ? diffLeft : diffRight;
    }
    float3 diffY;
    {
        float3 positionUp   = ViewSrg::GetViewSpacePosition( float2(screenUV.x, screenUV.y - pixelSize.y), depthUpLeft.z);
        float3 positionDown = ViewSrg::GetViewSpacePosition( float2(screenUV.x, screenUV.y + pixelSize.y), depthBottomRight.x);
        float3 diffUp = positionVS - positionUp;
        float3 diffDown = positionDown - positionVS;
        diffY = (abs(diffUp.z) < abs(diffDown.z)) ? diffUp : diffDown;
    }

    float3 normalVS = normalize( cross(diffX, diffY) );
    
    positionVS.z = -positionVS.z;
    normalVS.z = -normalVS.z;

    outPositionWS = positionVS;
    outNormalWS = normalVS;
}

//! Returns the world position from the view position.
float3 WorldPositionFromViewPosition(in float3 positionVS)
{
    return mul(ViewSrg::m_viewMatrixInverse, float4(positionVS, 1)).xyz;
}

//! Returns the world normal from the view normal.
float3 WorldNormalFromViewNormal(in float3 normalVS)
{
    return mul(ViewSrg::m_viewMatrixInverse, float4(normalVS, 0)).xyz;
}