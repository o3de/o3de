/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

float3 DecodePositionDelta(uint3 xyz, float min, float max)
{
    // Position deltas are encoded using 16 bits per channel, which represent a 0-1 range between the min and max values
    // They are converted to 32 bit uints after being loaded from memory before calling this function since AZSL does not support 16-bit uint
    // Divide by 65535 to get from 0-1, multiply by the magnitude of the range between min and max,
    // and add the value of min to get back the original value
    float f = (max - min) / 65535.0f;
    return float3(xyz) * f + min;
}

float3 DecodeTBNDelta(uint3 encodedTBN)
{
	// Similar to positions, but TBN deltas are assumed to be in the range of -2.0 to 2.0
	// and only use 8 bits per channel
	float f = 4.0f / 255.0f;
	return float3(encodedTBN) * f - 2.0f;
}

int3 EncodeFloatsToInts(float3 f, float integerEncoding)
{
    return int3(f * integerEncoding);
}

float3 DecodeIntsToFloats(int3 i, float inverseIntegerEncoding)
{
    return float3(i) * inverseIntegerEncoding;
}
