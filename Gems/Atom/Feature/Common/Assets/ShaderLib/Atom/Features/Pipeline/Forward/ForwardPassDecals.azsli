/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/LightCulling/LightCullingTileIterator.azsli>
#include <Atom/Features/PBR/Decals.azsli>

#if ENABLE_DECALS
void ApplyDecals_ForwardPass(inout LightCullingTileIterator tileIterator, inout Surface surface)
{
#if ENABLE_LIGHT_CULLING
    tileIterator.LoadAdvance();

    while( !tileIterator.IsDone() )
    {
        uint currDecalIndex = tileIterator.GetValue();
        tileIterator.LoadAdvance();

        if (o_enableDecals)  // i need to advance the iterator, even if decals are disabled
        {
            ApplyDecal(currDecalIndex, surface);
        }
    }
#else
        // Since there's no GPU culling for decals, we rely on culling done by CPU
        // Only apply visible decals
    if (o_enableDecals)
    {
        for(uint decalIndex = 0; (decalIndex < ENABLE_DECALS_CAP && decalIndex < ViewSrg::m_visibleDecalCount); decalIndex++)
        {
            ApplyDecal(decalIndex, surface);
        }
    }
#endif
}

#else
void ApplyDecals_ForwardPass(inout LightCullingTileIterator tileIterator, inout Surface surface)
{
    //Not Enabled
}
#endif
