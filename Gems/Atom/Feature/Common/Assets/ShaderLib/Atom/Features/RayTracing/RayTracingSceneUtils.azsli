/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <Atom/Features/Bindless.azsli>

// returns the normalized camera view ray into the scene for this raytracing dispatch thread
float3 GetViewRayDirection(float4x4 projectionInverseMatrix, float4x4 viewInverseMatrix)
{
    float2 pixel = ((float2)DispatchRaysIndex().xy + float2(0.5f, 0.5f)) / (float2)DispatchRaysDimensions();
    float2 ndc = pixel * float2(2.0f, -2.0f) + float2(-1.0f, 1.0f);
    float4 viewDir = normalize(mul(projectionInverseMatrix, float4(ndc, 0.0f, 1.0f)));
    return normalize(mul(viewInverseMatrix, float4(viewDir.xyz, 0.0f)).xyz);
}


#include <Atom/Feature/Common/Assets/Shaders/Materials/MaterialInputs/UvSetCount.azsli>
// tell the MeshInfoUtil what vertex-data we need
#define MATERIAL_USES_VERTEX_POSITION 1
#define MATERIAL_USES_VERTEX_NORMAL 1
#define MATERIAL_USES_VERTEX_TANGENT 1
#define MATERIAL_USES_VERTEX_BITANGENT 1
#define MATERIAL_USES_VERTEX_UV 1

struct VsInput
{
    float3 position;
    float3 normal;
    float4 tangent;
    float3 bitangent;
    float2 uv0;
    float2 uv1;
};

#include <Atom/Features/MeshInfo/MeshInfoUtil.azsli>

VsInput GetHitInterpolatedVertexData(const MeshInfo meshInfo, const uint primitiveIndex, const float2 builtInBarycentrics)
{
    float3 barycentrics = float3((1.0f - builtInBarycentrics.x - builtInBarycentrics.y), builtInBarycentrics.x, builtInBarycentrics.y);
    VsInput vertex;
    LoadInterpolatedVertexData(meshInfo, primitiveIndex, barycentrics, vertex);
    return vertex;
}

VsInput GetHitInterpolatedVertexData(const uint instanceId, const uint primitiveIndex, const float2 builtInBarycentrics)
{
    MeshInfo meshInfo;
    if (GetMeshInfoEntry(instanceId, meshInfo))
    {
        return GetHitInterpolatedVertexData(meshInfo, primitiveIndex, builtInBarycentrics);
    }
    return (VsInput)0;
}


uint GetBindlessBufferIndex()
{
    return RayTracingSceneSrg::m_proceduralGeometryInfo[NonUniformResourceIndex(InstanceIndex()) - RayTracingSceneSrg::m_blasMeshCount][0];
}

uint GetLocalInstanceIndex()
{
    return RayTracingSceneSrg::m_proceduralGeometryInfo[NonUniformResourceIndex(InstanceIndex()) - RayTracingSceneSrg::m_blasMeshCount][1];
}
