/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

#ifndef DirectionalLightUtil
#define DirectionalLightUtil DirectionalLightUtil_PBR
#endif

class DirectionalLightUtil_PBR
{
#if ENABLE_TRANSMISSION
    real transmissionDistance;
#endif

    static DirectionalLightUtil_PBR Init(DirectionalLight light, Surface surface)
    {
        DirectionalLightUtil_PBR result;
#if ENABLE_TRANSMISSION
        result.transmissionDistance = 0.0f;
#endif
        return result;
    }

#if ENABLE_TRANSMISSION
    void SetTransmissionDistance(real distance)
    {
        transmissionDistance = distance;
    }
#endif

    void Apply(DirectionalLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {
        real3 dirToLight = normalize(real3(-light.m_direction));

        // Transmission contribution
#if ENABLE_TRANSMISSION
        // We evaluate translucent backlighting only for one camera
        real camToSurfDist = real(distance(ViewSrg::m_worldPosition, surface.position));
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, real3(light.m_rgbIntensityLux), dirToLight, real(transmissionDistance), camToSurfDist);
#endif
        
        // Calculate diffuse lighting (same for all views)
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, real3(light.m_rgbIntensityLux), dirToLight) * litRatio;
                // Calculate specular lighting for each view
        [unroll]
        for (uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
        {
            // Adjust the direction of the light based on its angular diameter for this view
            real3 reflectionDir = reflect(-lightingData.dirToCamera[viewIndex], surface.GetSpecularNormal());
            real3 lightDirToReflectionDir = reflectionDir - dirToLight;
            real lightDirToReflectionDirLen = length(lightDirToReflectionDir);
            lightDirToReflectionDir = lightDirToReflectionDir / lightDirToReflectionDirLen; // normalize the length
            lightDirToReflectionDirLen = min(real(light.m_angularRadius), lightDirToReflectionDirLen);
            real3 viewDirToLight = dirToLight + lightDirToReflectionDir * lightDirToReflectionDirLen;
            lightingData.specularLighting[viewIndex] += GetSpecularLighting(surface, lightingData, real3(light.m_rgbIntensityLux), dirToLight, viewIndex) * litRatio;
        }
#if ENABLE_SHADER_DEBUGGING
        if(IsDebuggingEnabled_PLACEHOLDER() && GetRenderDebugViewMode() == RenderDebugViewMode::CascadeShadows)
        {
            customDebugFloats.rgb = litRatio.xxx;
        }
#endif
    }
};
