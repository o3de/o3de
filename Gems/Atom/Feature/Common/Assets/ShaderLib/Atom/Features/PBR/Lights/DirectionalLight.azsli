/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

#ifndef DirectionalLightUtil
#define DirectionalLightUtil DirectionalLightUtil_PBR
#endif

class DirectionalLightUtil_PBR
{
#if ENABLE_TRANSMISSION
    real transmissionDistance;
    real camToSurfDist;
#endif

    static DirectionalLightUtil_PBR Init(DirectionalLight light, Surface surface, float3 cameraPositionWS)
    {
        DirectionalLightUtil_PBR result;
#if ENABLE_TRANSMISSION
        result.transmissionDistance = 0.0f;
        result.camToSurfDist = real(distance(cameraPositionWS, surface.position));
#endif
        return result;
    }

#if ENABLE_TRANSMISSION
    void SetTransmissionDistance(real distance)
    {
        transmissionDistance = distance;
    }
#endif

    void Apply(DirectionalLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {
        real3 dirToLight = normalize(real3(-light.m_direction));

        // Adjust the direction of the light based on its angular diameter.
        real3 reflectionDir = reflect(-lightingData.dirToCamera, surface.GetSpecularNormal());
        real3 lightDirToReflectionDir = reflectionDir - dirToLight;
        real lightDirToReflectionDirLen = length(lightDirToReflectionDir);
        lightDirToReflectionDir = lightDirToReflectionDir / lightDirToReflectionDirLen; // normalize the length
        lightDirToReflectionDirLen = min(real(light.m_angularRadius), lightDirToReflectionDirLen);
        dirToLight += lightDirToReflectionDir * lightDirToReflectionDirLen;

        // Transmission contribution
#if ENABLE_TRANSMISSION
        real camToSurfDist = real(distance(ViewSrg::m_worldPosition, surface.position));
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, real3(light.m_rgbIntensityLux), dirToLight, real(transmissionDistance), camToSurfDist);
#endif
        
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, real3(light.m_rgbIntensityLux), dirToLight) * litRatio;
        lightingData.specularLighting += GetSpecularLighting(surface, lightingData, real3(light.m_rgbIntensityLux), dirToLight) * litRatio;
    }
};

