/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

#include <Atom/Features/PBR/LightingOptions.azsli>

#include <Atom/RPI/Math.azsli>
#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
#include <Atom/Features/PBR/LightingUtils.azsli>

void ApplyIblDiffuse(float3 normal, float3 albedo, float3 diffuseResponse, out float3 outDiffuse)
{
    float3 irradianceDir = MultiplyVectorQuaternion(normal, SceneSrg::m_iblOrientation);
    float3 diffuseSample = SceneSrg::m_diffuseEnvMap.Sample(SceneSrg::m_samplerEnv, GetCubemapCoords(irradianceDir)).rgb;

    outDiffuse = diffuseResponse * albedo * diffuseSample;
}

void ApplyIblSpecular(float3 position, float3 normal, float3 specularF0, float roughnessLinear, float3 specularResponse, float3 dirToCamera, float2 brdf, out float3 outSpecular)
{
    float3 reflectDir = reflect(-dirToCamera, normal);
    
    // global
    outSpecular = SceneSrg::m_specularEnvMap.SampleLevel(SceneSrg::m_samplerEnv, GetCubemapCoords(reflectDir), GetRoughnessMip(roughnessLinear)).rgb;
    outSpecular *= (specularF0 * brdf.x + brdf.y);
    
    // reflection probe
    if (ObjectSrg::m_reflectionProbeData.m_useReflectionProbe)
    {
        if (ObjectSrg::m_reflectionProbeData.m_useParallaxCorrection)
        {
            reflectDir = ApplyParallaxCorrection(
                ObjectSrg::m_reflectionProbeData.m_outerAabbMin,
                ObjectSrg::m_reflectionProbeData.m_outerAabbMax,
                ObjectSrg::m_reflectionProbeData.m_aabbPos,
                position,
                reflectDir);
        }
    
        float3 probeSpecular = ObjectSrg::m_reflectionProbeCubeMap.SampleLevel(SceneSrg::m_samplerEnv, GetCubemapCoords(reflectDir), GetRoughnessMip(roughnessLinear)).rgb;
        probeSpecular *= (specularF0 * brdf.x + brdf.y);
    
        // compute blend amount based on world position in the reflection probe volume
        float blendAmount = ComputeLerpBetweenInnerOuterAABBs(
            ObjectSrg::m_reflectionProbeData.m_innerAabbMin,
            ObjectSrg::m_reflectionProbeData.m_innerAabbMax,
            ObjectSrg::m_reflectionProbeData.m_outerAabbMax,
            ObjectSrg::m_reflectionProbeData.m_aabbPos,
            position);
    
        outSpecular = lerp(outSpecular, probeSpecular, blendAmount);
    }
}

void ApplyIBL(Surface surface, inout LightingData lightingData)
{
    if (o_opacity_mode == OpacityMode::Blended || o_opacity_mode == OpacityMode::TintedTransparent)
    {
        // transparencies currently require IBL in the forward pass
        if (o_enableIBL)
        {
            float3 iblDiffuse = 0.0f;
            float3 iblSpecular = 0.0f;
            ApplyIblDiffuse(surface.normal, surface.albedo, lightingData.diffuseResponse, iblDiffuse);
            ApplyIblSpecular(surface.position, surface.normal, surface.specularF0, surface.roughnessLinear, lightingData.specularResponse, lightingData.dirToCamera, lightingData.brdf, iblSpecular);

            // Adjust IBL lighting by exposure.
            float iblExposureFactor = pow(2.0, SceneSrg::m_iblExposure);
            lightingData.diffuseLighting += (iblDiffuse * iblExposureFactor * lightingData.occlusion);
            lightingData.specularLighting += (iblSpecular * iblExposureFactor);
        }
    }
    else if (o_meshUseForwardPassIBLSpecular || o_materialUseForwardPassIBLSpecular)
    {
        if (o_enableIBL)
        {
            float3 iblSpecular = 0.0f;
            ApplyIblSpecular(surface.position, surface.normal, surface.specularF0, surface.roughnessLinear, lightingData.specularResponse, lightingData.dirToCamera, lightingData.brdf, iblSpecular);
            
            float iblExposureFactor = pow(2.0f, SceneSrg::m_iblExposure);
            lightingData.specularLighting += (iblSpecular * iblExposureFactor);
        }
    }
}

