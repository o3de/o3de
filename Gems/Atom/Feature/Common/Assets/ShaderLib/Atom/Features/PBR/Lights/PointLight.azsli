/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#if ENABLE_SPHERE_LIGHTS

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

#ifndef PointLightUtil
#define PointLightUtil PointLightUtil_PBR
#endif

class PointLightUtil_PBR
{
    real3 m_surfaceToLight;
    real3 m_surfaceToLightDirection;
    real  m_lightDistanceSquared;
    real  m_falloff;

    // calculated in Apply(), but can be useful afterwards
    real3 m_lightIntensity;

#if ENABLE_TRANSMISSION
    // Distance travelled by the light inside the object. If not redefined to a non-negative value, it will take the following behavior:
    // - If transmission mode is thick object -> use transmission thickness parameter instead
    // - If transmission mode is thin object -> ignore back lighting
    real m_transmissionDistance;
#endif

    static PointLightUtil_PBR Init(PointLight light, Surface surface)
    {
        PointLightUtil_PBR result;

        result.m_surfaceToLight = real3(light.m_position) - real3(surface.position);
        result.m_surfaceToLightDirection = normalize(result.m_surfaceToLight);
        result.m_lightDistanceSquared = dot(result.m_surfaceToLight, result.m_surfaceToLight);
        result.m_falloff = result.m_lightDistanceSquared * real(light.m_invAttenuationRadiusSquared);
        return result;
    }


    real3 GetSurfaceToLightDirection()
    {
        return m_surfaceToLightDirection;
    }

#if ENABLE_TRANSMISSION
    void SetTransmissionDistance(real distance)
    {
        m_transmissionDistance = distance;
    }
#endif

    real GetFalloff()
    {
        return m_falloff;
    }

    void Apply(PointLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {

        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        real radiusAttenuation = 1.0 - (m_falloff * m_falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;

        // Standard quadratic m_falloff
        m_lightDistanceSquared = max(0.001 * 0.001, m_lightDistanceSquared); // clamp the light to at least 1mm away to avoid extreme values.
        m_lightIntensity = (real3(light.m_rgbIntensityCandelas) / m_lightDistanceSquared) * radiusAttenuation;

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, m_lightIntensity, m_surfaceToLightDirection) * litRatio;

        // Transmission contribution
#if ENABLE_TRANSMISSION
        real posToLightDist = length(m_surfaceToLight);
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, m_lightIntensity, m_surfaceToLightDirection, m_transmissionDistance, posToLightDist) * litRatio;
#endif

        // Calculate specular lighting for each view
        [unroll]
        for (uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
        {
            // Calculate the reflection off the normal from the view direction
            real3 reflectionDir = reflect(-lightingData.dirToCamera[viewIndex], surface.GetSpecularNormal());

            // Calculate a vector from the reflection vector to the light
            real3 reflectionPosToLight = m_surfaceToLight - dot(m_surfaceToLight, reflectionDir) * reflectionDir;

            // Adjust the direction to light based on the bulb size
            real3 m_surfaceToLightAdjusted = m_surfaceToLight - (reflectionPosToLight * saturate(real(light.m_bulbRadius) / length(reflectionPosToLight)));
            
            // Adjust the intensity of the light based on the bulb size to conserve energy
            real sphereIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, real(light.m_bulbRadius), m_lightDistanceSquared);

            // Specular contribution
            lightingData.specularLighting[viewIndex] += sphereIntensityNormalization * GetSpecularLighting(surface, lightingData, m_lightIntensity, normalize(m_surfaceToLightAdjusted), viewIndex) * litRatio;
        }
    }

    void ApplySampled(PointLight light, Surface surface, inout LightingData lightingData, const uint sampleCount = 512)
    {
        real3 diffuseAcc = real3(0.0, 0.0, 0.0);
        real3 translucentAcc = real3(0.0, 0.0, 0.0);
        real3 specularAcc[MAX_SHADING_VIEWS];
        
        [unroll]
        for(uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
        {
            specularAcc[viewIndex] = float3(0.0, 0.0, 0.0);
        }

        for (uint i = 0; i < sampleCount; ++i)
        {
            real2 randomPoint = GetHammersleyPoint(i, sampleCount);
            real3 sampleDirection = SampleSphere(randomPoint);
            real3 samplePoint = real3(light.m_position) + sampleDirection * real(light.m_bulbRadius);
            AddSampleContribution(surface, lightingData, samplePoint, sampleDirection, 0.0, diffuseAcc, specularAcc, translucentAcc);
        }

        // Lighting value is in Candela, convert to Lumen for total light output of the light
        real3 intensityLumens = real3(light.m_rgbIntensityCandelas) * 4.0 * PI;
        // Each of the N samples will contribute intensity / N lumens. However it will radiate in
        // equal directions across the hemisphere, so we need to account for that
        real3 intensity = intensityLumens * INV_PI;

        lightingData.diffuseLighting += (diffuseAcc / real(sampleCount)) * intensity;

        [unroll]
        for(uint viewIndex = 0; viewIndex < GET_SHADING_VIEW_COUNT; ++viewIndex)
        {
            lightingData.specularLighting[viewIndex] += (specularAcc[viewIndex] / real(sampleCount)) * intensity;
        }

    #if ENABLE_TRANSMISSION
        lightingData.translucentBackLighting += (translucentAcc / real(sampleCount)) * intensity;
    #endif
    }

};

#endif // ENABLE_SPHERE_LIGHTS

