/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/

#pragma once

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>
#include <Atom/Features/Shadow/ProjectedShadow.azsli>

int GetShadowDirectionIndex(const float3 targetPos, const float3 lightPos)
{
    const float3 toPoint = targetPos - lightPos;    
    const float maxElement = max(abs(toPoint.z), max(abs(toPoint.x), abs(toPoint.y)));
    if (toPoint.x == -maxElement)
    {
        return 0;
    }
    else if (toPoint.x == maxElement)
    {
        return 1;
    }   
    else if (toPoint.y == -maxElement)
    {
        return 2;
    }
    else if (toPoint.y == maxElement)
    {
        return 3;
    }
    else if (toPoint.z == -maxElement)
    {
        return 4;
    }
    else 
    {
        return 5;
    }   
}

int UnpackShadowIndex(const ViewSrg::PointLight light, const int i)
{
    if (i == 0)
    {
        return light.m_shadowIndices[0] & 0xFFFF;
    }
    else if (i==1)
    {
        return (light.m_shadowIndices[0] >> 16) & 0xFFFF;       
    }
    else if (i==2)
    {
        return (light.m_shadowIndices[1]) & 0xFFFF;             
    }
    else if (i==3)
    {   
        return (light.m_shadowIndices[1] >> 16) & 0xFFFF;                       
    }
    else if (i==4)
    {
        return (light.m_shadowIndices[2]) & 0xFFFF;                             
    }
    else 
    {
        return (light.m_shadowIndices[2] >> 16) & 0xFFFF;                                           
    }
}

void ApplyPointLight(ViewSrg::PointLight light, Surface surface, inout LightingData lightingData)
{
    float3 posToLight = light.m_position - surface.position;
    float d2 = dot(posToLight, posToLight); // light distance squared
    float falloff = d2 * light.m_invAttenuationRadiusSquared;
    
    // Only calculate shading if light is in range
    if (falloff < 1.0f)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;
        
        // Standard quadratic falloff
        d2 = max(0.001 * 0.001, d2); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / d2) * radiusAttenuation;

        // shadow
        float litRatio = 1.0;

        // How much is back face shadowed, it's set to the reverse of litRatio to share the same default value with thickness, which should be 0 if no shadow map available
        float backShadowRatio = 0.0;
        if (o_enableShadows)
        {
            // The order should match m_pointShadowTransforms in PointLightFeatureProcessor.h/.cpp
            const float3 PointShadowDirections[6] = {float3(-1,0,0), float3(1,0,0), float3(0,-1,0), float3(0,1,0), float3(0,0,-1), float3(0,0,1)};                  
            const int shadowDirectionIndex = GetShadowDirectionIndex(surface.position, light.m_position);
            const int shadowIndex = UnpackShadowIndex(light, shadowDirectionIndex);
            litRatio *= ProjectedShadow::GetVisibility(
                    shadowIndex,
                    light.m_position,
                    surface.position,
                    PointShadowDirections[shadowDirectionIndex],
                    surface.normal);
                        
            // Use backShadowRatio to carry thickness from shadow map for thick mode
            backShadowRatio = 1.0 - litRatio;
            if (o_transmission_mode == TransmissionMode::ThickObject)
            {
                backShadowRatio = ProjectedShadow::GetThickness(
                    shadowIndex,
                    surface.position);
            }                   
        }

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, normalize(posToLight)) * litRatio;

        // Tranmission contribution
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, lightIntensity, normalize(posToLight), 0.0) * litRatio;

        // Adjust the light direcion for specular based on bulb size

        // Calculate the reflection off the normal from the view direction
        float3 reflectionDir = reflect(-lightingData.dirToCamera, surface.normal);

        // Calculate a vector from the reflection vector to the light
        float3 reflectionPosToLight = posToLight - dot(posToLight, reflectionDir) * reflectionDir;

        // Adjust the direction to light based on the bulb size
        posToLight -= reflectionPosToLight * saturate(light.m_bulbRadius / length(reflectionPosToLight));
        
        // Adjust the intensity of the light based on the bulb size to conserve energy
        float sphereIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, light.m_bulbRadius, d2);

        // Specular contribution
        lightingData.specularLighting += sphereIntensityNormalization * GetSpecularLighting(surface, lightingData, lightIntensity, normalize(posToLight));
    }
}

float3 SampleSphere(float2 randomPoint)
{
    // Generates uniformly distributed sample on a unit sphere from a 2d position in the 0.0 -> 1.0 range.
    float angle = 2.0 * PI * randomPoint.y;
    float cosTheta = 1.0 - 2.0 * randomPoint.x; // Transform x from 0.0 -> 1.0 to -1.0 -> 1.0
    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));
    return float3(sinTheta * cos(angle), sinTheta * sin(angle), cosTheta);
}

void ValidatePointLight(ViewSrg::PointLight light, Surface surface, inout LightingData lightingData)
{
    const uint sampleCount = 512;

    float3 diffuseAcc = float3(0.0, 0.0, 0.0);
    float3 specularAcc = float3(0.0, 0.0, 0.0);
    float3 translucentAcc = float3(0.0, 0.0, 0.0);

    for (uint i = 0; i < sampleCount; ++i)
    {
        float2 randomPoint = GetHammersleyPoint(i, sampleCount);
        float3 sampleDirection = SampleSphere(randomPoint);
        float3 samplePoint = light.m_position + sampleDirection * light.m_bulbRadius;
        AddSampleContribution(surface, lightingData, samplePoint, sampleDirection, 0.0, diffuseAcc, specularAcc, translucentAcc);
    }

    // Lighting value is in Candela, convert to Lumen for total light output of the light
    float3 intensityLumens = light.m_rgbIntensityCandelas * 4.0 * PI;
    // Each of the N samples will contribute intensity / N lumens. However it will radiate in
    // equal directions across the hemisphere, so we need to account for that
    float3 intensity = intensityLumens * INV_PI;

    lightingData.diffuseLighting += (diffuseAcc / float(sampleCount)) * intensity;
    lightingData.translucentBackLighting += (translucentAcc / float(sampleCount)) * intensity;
    lightingData.specularLighting += (specularAcc / float(sampleCount)) * intensity;
}

void ApplyPointLights(Surface surface, inout LightingData lightingData)
{
    lightingData.tileIterator.LoadAdvance();
    
    while( !lightingData.tileIterator.IsDone() ) 
    { 
        uint currLightIndex = lightingData.tileIterator.GetValue(); 
        lightingData.tileIterator.LoadAdvance();
    
        ViewSrg::PointLight light = ViewSrg::m_pointLights[currLightIndex];
        
        if (o_area_light_validation)
        {
            ValidatePointLight(light, surface, lightingData);
        }
        else
        {
            ApplyPointLight(light, surface, lightingData);
        }
    }
}
