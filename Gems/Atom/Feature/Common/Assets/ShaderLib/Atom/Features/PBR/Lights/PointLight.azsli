/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#if ENABLE_SPHERE_LIGHTS

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

#ifndef PointLightUtil
#define PointLightUtil PointLightUtil_PBR
#endif

class PointLightUtil_PBR
{
    real3 surfaceToLight;
    real3 surfaceToLightDirection;
    real  lightDistanceSquared;
    real  falloff;

    // calculated in Apply(), but can be useful afterwards
    real3 lightIntensity;

#if ENABLE_TRANSMISSION
    // Distance travelled by the light inside the object. If not redefined to a non-negative value, it will take the following behavior:
    // - If transmission mode is thick object -> use transmission thickness parameter instead
    // - If transmission mode is thin object -> ignore back lighting
    real transmissionDistance;
#endif

    static PointLightUtil_PBR Init(PointLight light, Surface surface, float3 cameraPositionWS)
    {
        PointLightUtil_PBR result;

        result.surfaceToLight = real3(light.m_position) - real3(surface.position);
        result.surfaceToLightDirection = normalize(result.surfaceToLight);
        result.lightDistanceSquared = dot(result.surfaceToLight, result.surfaceToLight);
        result.falloff = result.lightDistanceSquared * real(light.m_invAttenuationRadiusSquared);
        return result;
    }


    real3 GetSurfaceToLightDirection()
    {
        return surfaceToLightDirection;
    }

#if ENABLE_TRANSMISSION
    void SetTransmissionDistance(real distance)
    {
        transmissionDistance = distance;
    }
#endif

    real GetFalloff()
    {
        return falloff;
    }

    void Apply(PointLight light, Surface surface, real litRatio, inout LightingData lightingData)
    {

        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        real radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;
        
        // Standard quadratic falloff
        lightDistanceSquared = max(0.001 * 0.001, lightDistanceSquared); // clamp the light to at least 1mm away to avoid extreme values.
        lightIntensity = (real3(light.m_rgbIntensityCandelas) / lightDistanceSquared) * radiusAttenuation;

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, surfaceToLightDirection) * litRatio;

        // Transmission contribution
#if ENABLE_TRANSMISSION
        real posToLightDist = length(surfaceToLight);
        lightingData.translucentBackLighting += GetBackLighting(surface, lightingData, lightIntensity, surfaceToLightDirection, transmissionDistance, posToLightDist) * litRatio;
#endif

        // Adjust the light direcion for specular based on bulb size

        // Calculate the reflection off the normal from the view direction
        real3 reflectionDir = reflect(-lightingData.dirToCamera, surface.GetSpecularNormal());

        // Calculate a vector from the reflection vector to the light
        real3 reflectionPosToLight = surfaceToLight - dot(surfaceToLight, reflectionDir) * reflectionDir;

        // Adjust the direction to light based on the bulb size
        real3 surfaceToLightAdjusted = surfaceToLight - (reflectionPosToLight * saturate(real(light.m_bulbRadius) / length(reflectionPosToLight)));
        
        // Adjust the intensity of the light based on the bulb size to conserve energy
        real sphereIntensityNormalization = GetIntensityAdjustedByRadiusAndRoughness(surface.roughnessA, real(light.m_bulbRadius), lightDistanceSquared);

        // Specular contribution
        lightingData.specularLighting += sphereIntensityNormalization * GetSpecularLighting(surface, lightingData, lightIntensity, normalize(surfaceToLightAdjusted)) * litRatio;

    }

    void ApplySampled(PointLight light, Surface surface, inout LightingData lightingData, const uint sampleCount = 512)
    {
        real3 diffuseAcc = real3(0.0, 0.0, 0.0);
        real3 specularAcc = real3(0.0, 0.0, 0.0);
        real3 translucentAcc = real3(0.0, 0.0, 0.0);

        for (uint i = 0; i < sampleCount; ++i)
        {
            real2 randomPoint = GetHammersleyPoint(i, sampleCount);
            real3 sampleDirection = SampleSphere(randomPoint);
            real3 samplePoint = real3(light.m_position) + sampleDirection * real(light.m_bulbRadius);
            AddSampleContribution(surface, lightingData, samplePoint, sampleDirection, 0.0, diffuseAcc, specularAcc, translucentAcc);
        }

        // Lighting value is in Candela, convert to Lumen for total light output of the light
        real3 intensityLumens = real3(light.m_rgbIntensityCandelas) * 4.0 * PI;
        // Each of the N samples will contribute intensity / N lumens. However it will radiate in
        // equal directions across the hemisphere, so we need to account for that
        real3 intensity = intensityLumens * INV_PI;

        lightingData.diffuseLighting += (diffuseAcc / real(sampleCount)) * intensity;
        lightingData.specularLighting += (specularAcc / real(sampleCount)) * intensity;

    #if ENABLE_TRANSMISSION
        lightingData.translucentBackLighting += (translucentAcc / real(sampleCount)) * intensity;
    #endif
    }

};

#endif // ENABLE_SPHERE_LIGHTS

