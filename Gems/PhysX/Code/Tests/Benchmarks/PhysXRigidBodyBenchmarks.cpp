/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#ifdef HAVE_BENCHMARK
#include <benchmark/benchmark.h>

#include <AzTest/AzTest.h>
#include <AzFramework/Physics/Collision/CollisionEvents.h>
#include <AzFramework/Physics/Common/PhysicsEvents.h>

#include <Benchmarks/PhysXBenchmarksUtilities.h>
#include <Benchmarks/PhysXBenchmarksCommon.h>
#include <Benchmarks/PhysXBenchmarkWashingMachine.h>

#include <PhysXTestCommon.h>
#include <PhysXTestUtil.h>

namespace PhysX::Benchmarks
{
    namespace RigidBodyConstants
    {
        //! Controls the simulation length of the test. 30secs at 60fps
        static const int GameFramesToSimulate = 1800;

        //! The size of safe the test region, used for spawning Rigid bodies
        static const float TestRadius = 250.0f;

        //! The size of the test terrain
        static const float TerrainSize = 1000.0f;

        //! Decide if CCD should be on/off for the following tests
        static const bool CCDEnabled = true;

        //! Decide if active actors should be on/off for the following tests.
        static const bool ActiveActorsEnabled = true;

        //! Constant seed to use with random number generation
        static const long long RandGenSeed = 8010412111588; //(Number generated by concatenating 'PhysX' ascii character codes (80 104 121 115 88).

        //! Constants for setting up the washing machine
        namespace WashingMachine
        {
            static const float CylinderHeight = 500.0f;
            static const float BladeRPM = 10.0f;
        } // namespace WashingMachine

        //! Constants for setting up the Rigid Bodies
        namespace RigidBodys
        {
            static const float BoxSize = 5.0f;

            //! Default starting value of Entity Ids for rigid bodies
            static const AZ::u64 RigidBodyEntityIdStart = 2000u;
        }

        //! Settings used to setup each benchmark
        namespace BenchmarkSettings
        {
            //! Values passed to benchmark to select the number of rigid bodies to spawn during each test
            //! Current values will run tests between StartRange to EndRange (inclusive), multiplying by RangeMultiplier each step.
            static const int StartRange = 128;
            static const int EndRange = 8192;
            static const int RangeMultipler = 2;

            //!Flags to adjust how the collision handlers benchmark runs
            static const int AllCollisionHanders = 0; // create the same number of handlers as rigid bodies
            static const int HalfCollisionHandlers = 1; // create half the number of handlers as rigid bodies
            static const int NoCollisionHandlers = 2; // create the no handlers

            //! Number of iterations for each test
            static const int NumIterations = 3;
        } // namespace BenchmarkRange

        //! Settings used to setup the activation benchmark
        namespace ActivationBenchmarkSettings
        {
            //! Values passed to activation benchmark to select the number of rigid bodies to activate during each test
            //! Current values will run tests between StartRange to EndRange (inclusive), multiplying by RangeMultiplier each step.
            static const int StartRange = 100;
            static const int EndRange = 100000;
            static const int RangeMultipler = 10;

            //! Number of iterations for each test
            static const int NumIterations = 10;
        } // namespace ActivationBenchmarkSettings
    } // namespace RigidBodyConstants

    namespace Utils
    {
        //! Object that will connect to the collision notification bus of the provided entity id
        struct SimulatedBodyCollisionHandler
        {
            SimulatedBodyCollisionHandler(AzPhysics::SceneHandle sceneHandle, AzPhysics::SimulatedBodyHandle bodyHandle)
                : m_onCollisionBeginHandler(
                    [this]([[maybe_unused]] AzPhysics::SimulatedBodyHandle bodyHandle,
                    [[maybe_unused]] const AzPhysics::CollisionEvent& event)
                    {
                        m_beginCount++;
                    })
                , m_onCollisionPersistHandler(
                    [this]([[maybe_unused]] AzPhysics::SimulatedBodyHandle bodyHandle,
                    [[maybe_unused]] const AzPhysics::CollisionEvent& event)
                    {
                        m_persistCount++;
                    })
                , m_onCollisionEndHandler(
                    [this]([[maybe_unused]] AzPhysics::SimulatedBodyHandle bodyHandle,
                    [[maybe_unused]] const AzPhysics::CollisionEvent& event)
                    {
                        m_endCount++;
                    })
            {
                AzPhysics::SimulatedBodyEvents::RegisterOnCollisionBeginHandler(sceneHandle, bodyHandle, m_onCollisionBeginHandler);
                AzPhysics::SimulatedBodyEvents::RegisterOnCollisionBeginHandler(sceneHandle, bodyHandle, m_onCollisionPersistHandler);
                AzPhysics::SimulatedBodyEvents::RegisterOnCollisionBeginHandler(sceneHandle, bodyHandle, m_onCollisionEndHandler);
            }

            SimulatedBodyCollisionHandler(SimulatedBodyCollisionHandler&& other)
            {
                m_onCollisionBeginHandler = AZStd::move(other.m_onCollisionBeginHandler);
                m_onCollisionPersistHandler = AZStd::move(other.m_onCollisionPersistHandler);
                m_onCollisionEndHandler = AZStd::move(other.m_onCollisionEndHandler);
                m_beginCount = other.m_beginCount;
                m_persistCount = other.m_persistCount;
                m_endCount = other.m_endCount;
            }

            ~SimulatedBodyCollisionHandler()
            {
                m_onCollisionBeginHandler.Disconnect();
                m_onCollisionPersistHandler.Disconnect();
                m_onCollisionEndHandler.Disconnect();
            }

            int m_beginCount = 0;
            int m_persistCount = 0;
            int m_endCount = 0;
        private:
            AzPhysics::SimulatedBodyEvents::OnCollisionBegin::Handler m_onCollisionBeginHandler;
            AzPhysics::SimulatedBodyEvents::OnCollisionPersist::Handler m_onCollisionPersistHandler;
            AzPhysics::SimulatedBodyEvents::OnCollisionEnd::Handler m_onCollisionEndHandler;
        };

        //! Class to mock a runtime component that needs a rigid body during activation.
        class MockRigidBodyDependantComponent
            : public AZ::Component
            , protected Physics::RigidBodyNotificationBus::Handler
        {
        public:
            AZ_COMPONENT(MockRigidBodyDependantComponent, "{3122D81F-525A-4577-A8D7-5F0A2D474F78}");
            static void Reflect(AZ::ReflectContext* context)
            {
                if (auto serializeContext = azrtti_cast<AZ::SerializeContext*>(context))
                {
                    serializeContext->Class<MockRigidBodyDependantComponent, AZ::Component>()
                        ->Version(1);
                }
            }

            MockRigidBodyDependantComponent() = default;
            ~MockRigidBodyDependantComponent() = default;

        protected:
            static void GetRequiredServices(AZ::ComponentDescriptor::DependencyArrayType& required)
            {
                required.push_back(AZ_CRC_CE("TransformService"));
                required.push_back(AZ_CRC_CE("PhysicsDynamicRigidBodyService"));
            }

            void Activate() override
            {
                // During activation the simulated bodies are not created yet.
                // Connect to RigidBodyNotificationBus to listen when it's enabled after creation.
                Physics::RigidBodyNotificationBus::Handler::BusConnect(GetEntityId());
            }

            void Deactivate() override
            {
                Physics::RigidBodyNotificationBus::Handler::BusDisconnect();
            }

            void OnPhysicsEnabled(const AZ::EntityId& entityId) override
            {
                m_physicsRigidBodyComponent = Physics::RigidBodyRequestBus::FindFirstHandler(entityId);
                AZ_Assert(m_physicsRigidBodyComponent, "Physics Rigid Body is required on entity %s", GetEntity()->GetName().c_str());
            }

            void OnPhysicsDisabled([[maybe_unused]] const AZ::EntityId& entityId) override
            {
                m_physicsRigidBodyComponent = nullptr;
            }

            Physics::RigidBodyRequests* m_physicsRigidBodyComponent = nullptr;
        };
    } // namespace Utils

    //! Rigid body performance fixture.
    //! Will create a world, and terrain.
    class PhysXRigidbodyBenchmarkFixture
        : public PhysXBaseBenchmarkFixture
    {
    protected:
        virtual void internalSetUp()
        {
            // Register MockRigidBodyDependantComponent with the serialize context
            AZ::SerializeContext* serializeContext = nullptr;
            AZ::ComponentApplicationBus::BroadcastResult(serializeContext, &AZ::ComponentApplicationBus::Events::GetSerializeContext);
            if (serializeContext)
            {
                m_mockRigidBodyDependantComponentDescriptor =
                    AZStd::unique_ptr<AZ::ComponentDescriptor>(Utils::MockRigidBodyDependantComponent::CreateDescriptor());
                m_mockRigidBodyDependantComponentDescriptor->Reflect(serializeContext);
            }

            PhysXBaseBenchmarkFixture::SetUpInternal();
            //need to get the Physics::System to be able to spawn the rigid bodies
            m_system = AZ::Interface<Physics::System>::Get();

            m_terrainEntity = PhysX::TestUtils::CreateFlatTestTerrain(m_testSceneHandle, RigidBodyConstants::TerrainSize, RigidBodyConstants::TerrainSize);
        }

        virtual void internalTearDown()
        {
            m_terrainEntity = nullptr;
            PhysXBaseBenchmarkFixture::TearDownInternal();

            // Unregister MockRigidBodyDependantComponent with the serialize context
            AZ::SerializeContext* serializeContext = nullptr;
            AZ::ComponentApplicationBus::BroadcastResult(serializeContext, &AZ::ComponentApplicationBus::Events::GetSerializeContext);
            if (serializeContext)
            {
                serializeContext->UnregisterType(azrtti_typeid<Utils::MockRigidBodyDependantComponent>());
            }
            m_mockRigidBodyDependantComponentDescriptor.reset();
        }
    public:
        void SetUp(const benchmark::State&) override
        {
            internalSetUp();
        }
        void SetUp(benchmark::State&) override
        {
            internalSetUp();
        }

        void TearDown(const benchmark::State&) override
        {
            internalTearDown();
        }
        void TearDown(benchmark::State&) override
        {
            internalTearDown();
        }

    protected:
        // PhysXBaseBenchmarkFixture Interface ---------
        AzPhysics::SceneConfiguration GetDefaultSceneConfiguration() override
        {
            AzPhysics::SceneConfiguration sceneConfig = AzPhysics::SceneConfiguration::CreateDefault();
            sceneConfig.m_enableCcd = RigidBodyConstants::CCDEnabled;
            sceneConfig.m_enableActiveActors = RigidBodyConstants::ActiveActorsEnabled;
            return sceneConfig;
        }
        // PhysXBaseBenchmarkFixture Interface ---------

        void SetLabel(benchmark::State& state, int rigidBodyType);

        Physics::System *m_system;
        EntityPtr m_terrainEntity;
        AZStd::unique_ptr<AZ::ComponentDescriptor> m_mockRigidBodyDependantComponentDescriptor;
    };

    void PhysXRigidbodyBenchmarkFixture::SetLabel(benchmark::State& state, int rigidBodyType)
    {
        if (rigidBodyType == PhysX::Benchmarks::RigidBodyApiObject)
        {
            state.SetLabel("RigidBodyApiObject");
        }
        else if (rigidBodyType == PhysX::Benchmarks::RigidBodyEntity)
        {
            state.SetLabel("RigidBodyEntity");
        }
    }

    //! BM_RigidBody_AtRest - This test will spawn the requested number of rigid bodies and place them near the ground
    //! and the rigid bodies will go 'asleep'
    //! The test will run the simulation for ~1800 game frames at 60fps.
    BENCHMARK_DEFINE_F(PhysXRigidbodyBenchmarkFixture, BM_RigidBody_AtRest)(benchmark::State& state)
    {
        //get the request number of rigid bodies and prepare to spawn them
        const int numRigidBodies = aznumeric_cast<int>(state.range(0));
        const int bodyType = aznumeric_cast<int>(state.range(1));

        //common settings for each rigid body
        const float boxSizeWithSpacing = RigidBodyConstants::RigidBodys::BoxSize + 2.0f;
        const int boxesPerCol = static_cast<const int>(RigidBodyConstants::TerrainSize / boxSizeWithSpacing) - 1;
        int spawnColIdx = 0;
        int spawnRowIdx = 0;

        //function to generate the rigid bodies position / orientation / mass
        Utils::GenerateSpawnPositionFuncPtr posGenerator = [boxSizeWithSpacing, boxesPerCol, &spawnColIdx, &spawnRowIdx]([[maybe_unused]] int idx) -> const AZ::Vector3 {
            const float x = boxSizeWithSpacing + (boxSizeWithSpacing * spawnColIdx);
            const float y = boxSizeWithSpacing + (boxSizeWithSpacing * spawnRowIdx);
            const float z = RigidBodyConstants::RigidBodys::BoxSize / 2.0f;

            //advance to the next position to spawn the next rigid body
            spawnColIdx++;
            if (spawnColIdx >= boxesPerCol)
            {
                spawnColIdx = 0;
                spawnRowIdx++;
            }
            return AZ::Vector3(x, y, z);
        };

        auto boxShapeConfiguration = AZStd::make_shared<Physics::BoxShapeConfiguration>(AZ::Vector3(RigidBodyConstants::RigidBodys::BoxSize));
        Utils::GenerateColliderFuncPtr colliderGenerator = [&boxShapeConfiguration]([[maybe_unused]] int idx)
        {
            return boxShapeConfiguration;
        };

        //spawn the rigid bodies
        Utils::BenchmarkRigidBodies rigidBodies = Utils::CreateRigidBodies(
            numRigidBodies, GetDefaultSceneHandle(), RigidBodyConstants::CCDEnabled, bodyType, &colliderGenerator, &posGenerator);

        //setup the sub tick tracker
        Utils::PrePostSimulationEventHandler subTickTracker;
        subTickTracker.Start(m_defaultScene);

        //setup the frame timer tracker
        Types::TimeList tickTimes;
        for ([[maybe_unused]] auto _ : state)
        {
            for (AZ::u32 i = 0; i < RigidBodyConstants::GameFramesToSimulate; i++)
            {
                auto start = AZStd::chrono::steady_clock::now();
                StepScene1Tick(DefaultTimeStep);

                //time each physics tick and store it to analyze
                auto tickElapsedMilliseconds = Types::double_milliseconds(AZStd::chrono::steady_clock::now() - start);
                tickTimes.emplace_back(tickElapsedMilliseconds.count());
            }
        }
        subTickTracker.Stop();

        //object clean up
        if (auto handlesList = AZStd::get_if<AzPhysics::SimulatedBodyHandleList>(&rigidBodies))
        {
            m_defaultScene->RemoveSimulatedBodies(*handlesList);
        }

        AZStd::visit(
            [](auto& rigidBodies)
            {
                rigidBodies.clear();
            },
            rigidBodies);

        //sort the frame times and get the P50, P90, P99 percentiles
        Utils::ReportFramePercentileCounters(state, tickTimes, subTickTracker.GetSubTickTimes());
        Utils::ReportFrameStandardDeviationAndMeanCounters(state, tickTimes, subTickTracker.GetSubTickTimes());

        SetLabel(state, bodyType);
    }

    //! BM_RigidBody_MovingAndColliding - This test will create the physics washing machine, a cylinder with a spinning blade where
    //! it will spawn the requested number of rigid bodies above the machine and let them fall into a spinning blade.
    //! The test will run the simulation for ~1800 game frames at 60fps.
    BENCHMARK_DEFINE_F(PhysXRigidbodyBenchmarkFixture, BM_RigidBody_MovingAndColliding)(benchmark::State &state)
    {
        //setup some pieces for the test
        AZ::SimpleLcgRandom rand;
        rand.SetSeed(RigidBodyConstants::RandGenSeed);

        //Create a washing machine of physx objects. This is a cylinder with a spinning blade that rigid bodies are placed inside
        const AZ::Vector3 washingMachineCentre(500.0f, 500.0f, 1.0f);
        WashingMachine washingMachine;
        washingMachine.SetupWashingMachine(
            m_testSceneHandle, RigidBodyConstants::TestRadius, RigidBodyConstants::WashingMachine::CylinderHeight,
            washingMachineCentre, RigidBodyConstants::WashingMachine::BladeRPM);

        //get the request number of rigid bodies and prepare to spawn them
        const int numRigidBodies = aznumeric_cast<int>(state.range(0));
        const int bodyType = aznumeric_cast<int>(state.range(1));

        //add the rigid bodies
        //function to generate the rigid bodies position / orientation / mass
        Utils::GenerateSpawnPositionFuncPtr posGenerator = [washingMachineCentre, &rand](int idx) -> const AZ::Vector3 {
            const float spawnArea = (RigidBodyConstants::TestRadius * 1.5f);
            const float x = washingMachineCentre.GetX() + (rand.GetRandomFloat() - 0.5f) * spawnArea;
            const float y = washingMachineCentre.GetY() + (rand.GetRandomFloat() - 0.5f) * spawnArea;
            const float z = washingMachineCentre.GetZ() + RigidBodyConstants::WashingMachine::CylinderHeight + ((RigidBodyConstants::RigidBodys::BoxSize / 2.0f) * idx);
            return AZ::Vector3(x, y, z);
        };
        Utils::GenerateSpawnOrientationFuncPtr oriGenerator = [&rand]([[maybe_unused]] int idx) -> AZ::Quaternion {
            return AZ::CreateRandomQuaternion(rand);
        };
        Utils::GenerateMassFuncPtr massGenerator = [&rand]([[maybe_unused]] int idx) -> float {
            return rand.GetRandomFloat() * 25.0f + 5.0f;
        };
        auto boxShapeConfiguration = AZStd::make_shared<Physics::BoxShapeConfiguration>(AZ::Vector3(RigidBodyConstants::RigidBodys::BoxSize));
        Utils::GenerateColliderFuncPtr colliderGenerator = [&boxShapeConfiguration]([[maybe_unused]] int idx)
        {
            return boxShapeConfiguration;
        };
        //spawn the rigid bodies
        Utils::BenchmarkRigidBodies rigidBodies = Utils::CreateRigidBodies(
            numRigidBodies,
            GetDefaultSceneHandle(),
            RigidBodyConstants::CCDEnabled, bodyType, &colliderGenerator, &posGenerator, &oriGenerator, &massGenerator);

        //setup the sub tick tracker
        Utils::PrePostSimulationEventHandler subTickTracker;
        subTickTracker.Start(m_defaultScene);

        //setup the frame timer tracker
        AZStd::vector<double> tickTimes;
        tickTimes.reserve(RigidBodyConstants::GameFramesToSimulate);
        for ([[maybe_unused]] auto _ : state)
        {
            for (AZ::u32 i = 0; i < RigidBodyConstants::GameFramesToSimulate; i++)
            {
                auto start = AZStd::chrono::steady_clock::now();
                StepScene1Tick(DefaultTimeStep);

                //time each physics tick and store it to analyze
                auto tickElapsedMilliseconds = Types::double_milliseconds(AZStd::chrono::steady_clock::now() - start);
                tickTimes.emplace_back(tickElapsedMilliseconds.count());
            }
        }
        subTickTracker.Stop();

        //object clean up
        washingMachine.TearDownWashingMachine();

        if (auto handlesList = AZStd::get_if<AzPhysics::SimulatedBodyHandleList>(&rigidBodies))
        {
            m_defaultScene->RemoveSimulatedBodies(*handlesList);
        }

        AZStd::visit(
            [](auto& rigidBodies)
            {
                rigidBodies.clear();
            },
            rigidBodies);

        //sort the frame times and get the P50, P90, P99 percentiles
        Utils::ReportFramePercentileCounters(state, tickTimes, subTickTracker.GetSubTickTimes());
        Utils::ReportFrameStandardDeviationAndMeanCounters(state, tickTimes, subTickTracker.GetSubTickTimes());

        SetLabel(state, bodyType);
    }

    //! BM_RigidBody_Activation - This test will create the requested number of rigid bodies, including
    //! mock components that depend on the rigid bodies, and measure the time it takes to activate them.
    BENCHMARK_DEFINE_F(PhysXRigidbodyBenchmarkFixture, BM_RigidBody_Activation)(benchmark::State& state)
    {
        // get the request number of rigid bodies and prepare to spawn them
        const int numRigidBodies = aznumeric_cast<int>(state.range(0));

        const float boxSize = 1.0f;
        const float boxSpacing = 0.25f;

        // common settings for each rigid body
        const float boxSizeWithSpacing = boxSize + boxSpacing;
        const int boxesPerCol = static_cast<const int>(RigidBodyConstants::TerrainSize / boxSizeWithSpacing) - 1;
        int spawnColIndex = 0;
        int spawnRowIndex = 0;

        // function to generate the rigid bodies position / orientation / mass
        Utils::GenerateSpawnPositionFuncPtr posGenerator =
            [boxSize, boxSizeWithSpacing, boxesPerCol, &spawnColIndex, &spawnRowIndex]([[maybe_unused]] int idx) -> const AZ::Vector3
        {
            const float x = boxSizeWithSpacing + (boxSizeWithSpacing * spawnColIndex);
            const float y = boxSizeWithSpacing + (boxSizeWithSpacing * spawnRowIndex);
            const float z = boxSize / 2.0f;

            // advance to the next position to spawn the next rigid body
            spawnColIndex++;
            if (spawnColIndex >= boxesPerCol)
            {
                spawnColIndex = 0;
                spawnRowIndex++;
            }
            return AZ::Vector3(x, y, z);
        };

        auto boxShapeConfiguration =
            AZStd::make_shared<Physics::BoxShapeConfiguration>(AZ::Vector3(RigidBodyConstants::RigidBodys::BoxSize));
        Utils::GenerateColliderFuncPtr colliderGenerator = [&boxShapeConfiguration]([[maybe_unused]] int idx)
        {
            return boxShapeConfiguration;
        };

        // spawn the rigid bodies without activating them
        Utils::BenchmarkRigidBodies rigidBodies = Utils::CreateRigidBodies(
            numRigidBodies,
            GetDefaultSceneHandle(),
            RigidBodyConstants::CCDEnabled,
            RigidBodyEntity,
            &colliderGenerator,
            &posGenerator,
            nullptr /*genSpawnOriFuncPtr*/,
            nullptr /*genMassFuncPtr*/,
            nullptr /*genEntityIdFuncPtr*/,
            false /*activateEntities*/);

        auto& entityList = AZStd::get<PhysX::EntityList>(rigidBodies);

        // Add mock components that depend on rigid body during activation and
        // therefore are required to use RigidBodyNotification bus.
        for (auto& entity : entityList)
        {
            entity->CreateComponent<Utils::MockRigidBodyDependantComponent>();
        }

        Types::TimeList activationTimes;

        for ([[maybe_unused]] auto _ : state)
        {
            // Measure time to activate the entities
            auto start = AZStd::chrono::steady_clock::now();

            for (auto& entity : entityList)
            {
                entity->Activate();
            }

            auto tickElapsedMilliseconds = Types::double_milliseconds(AZStd::chrono::steady_clock::now() - start);
            activationTimes.emplace_back(tickElapsedMilliseconds.count());

            // Deactivate the entities for the next state iteration
            for (auto& entity : entityList)
            {
                entity->Deactivate();
            }
        }

        entityList.clear();

        // sort the activation times and get the P50, P90, P99 percentiles
        Utils::ReportPercentiles(state, activationTimes);
        Utils::ReportStandardDeviationAndMeanCounters(state, activationTimes);
    }

    //! Same as the PhysXRigidbodyBenchmarkFixture, adds a world event handler to receive collision events
    class PhysXRigidbodyCollisionsBenchmarkFixture
        : public PhysXRigidbodyBenchmarkFixture
    {
        void internalSetUp() override
        {
            PhysXRigidbodyBenchmarkFixture::internalSetUp();

            m_collisionBeginCount = 0;
            m_collisionPersistCount = 0;
            m_collisionEndCount = 0;

            m_onSceneCollisionHandler = AzPhysics::SceneEvents::OnSceneCollisionsEvent::Handler(
                [this]([[maybe_unused]] AzPhysics::SceneHandle sceneHandle,
                    const AzPhysics::CollisionEventList& collisionData)
                {
                    //count the events
                    for (const auto& collisionEvent : collisionData)
                    {
                        switch (collisionEvent.m_type)
                        {
                        case AzPhysics::CollisionEvent::Type::Begin:
                            m_collisionBeginCount++;
                            break;
                        case AzPhysics::CollisionEvent::Type::Persist:
                            m_collisionPersistCount++;
                            break;
                        case AzPhysics::CollisionEvent::Type::End:
                            m_collisionEndCount++;
                            break;
                        }
                    }
                }
            );
            m_defaultScene->RegisterSceneCollisionEventHandler(m_onSceneCollisionHandler);
        }

        void internalTearDown() override
        {
            m_onSceneCollisionHandler.Disconnect();

            PhysXRigidbodyBenchmarkFixture::internalTearDown();
        }

    public:
        void SetUp(const benchmark::State&) override
        {
            internalSetUp();
        }
        void SetUp(benchmark::State&) override
        {
            internalSetUp();
        }

        void TearDown(const benchmark::State&) override
        {
            internalTearDown();
        }
        void TearDown(benchmark::State&) override
        {
            internalTearDown();
        }

    protected:
        // Collision counters to track and report the number of events
        int m_collisionBeginCount;
        int m_collisionPersistCount;
        int m_collisionEndCount;

        AzPhysics::SceneEvents::OnSceneCollisionsEvent::Handler m_onSceneCollisionHandler;
    };

    //! BM_RigidBody_MovingAndColliding_CollisionHandlers - Runs that same benchmark as BM_RigidBody_MovingAndColliding, under a different fixture that adds world event handler for collisions
    //! Will have an equal number of Collision Handlers and rigid bodies. Not all rigid bodies will get a handler, some will have multiple.
    //! The test will run the simulation for ~1800 game frames at 60fps.
    BENCHMARK_DEFINE_F(PhysXRigidbodyCollisionsBenchmarkFixture, BM_RigidBody_MovingAndColliding_CollisionHandlers)(benchmark::State& state)
    {
        //setup some pieces for the test
        AZ::SimpleLcgRandom rand;
        rand.SetSeed(RigidBodyConstants::RandGenSeed);

        //Create a washing machine of physx objects. This is a cylinder with a spinning blade that rigid bodies are placed inside
        const AZ::Vector3 washingMachineCentre(500.0f, 500.0f, 1.0f);
        WashingMachine washingMachine;
        washingMachine.SetupWashingMachine(
            m_testSceneHandle, RigidBodyConstants::TestRadius, RigidBodyConstants::WashingMachine::CylinderHeight,
            washingMachineCentre, RigidBodyConstants::WashingMachine::BladeRPM);

        //get the request number of rigid bodies and prepare to spawn them
        const int numRigidBodies = aznumeric_cast<int>(state.range(0));
        const int bodyType = aznumeric_cast<int>(state.range(2));

        //add the rigid bodies
        //function to generate the rigid bodies position / orientation / mass
        Utils::GenerateSpawnPositionFuncPtr posGenerator = [washingMachineCentre, &rand](int idx) -> const AZ::Vector3 {
            const float u = std::sqrt(rand.GetRandomFloat());
            const float theta = AZ::Constants::TwoPi * rand.GetRandomFloat();
            const float x = washingMachineCentre.GetX() + RigidBodyConstants::TestRadius * u * std::sin(theta);
            const float y = washingMachineCentre.GetY() + RigidBodyConstants::TestRadius * u * std::cos(theta);
            const float z = washingMachineCentre.GetZ() + RigidBodyConstants::WashingMachine::CylinderHeight + ((RigidBodyConstants::RigidBodys::BoxSize / 2.0f) * idx);
            return AZ::Vector3(x, y, z);
        };
        Utils::GenerateSpawnOrientationFuncPtr oriGenerator = [&rand]([[maybe_unused]] int idx) -> AZ::Quaternion {
            return AZ::CreateRandomQuaternion(rand);
        };
        Utils::GenerateMassFuncPtr massGenerator = [&rand]([[maybe_unused]] int idx) -> float {
            return rand.GetRandomFloat() * 25.0f + 5.0f;
        };

        Utils::GenerateEntityIdFuncPtr entityIdGenerator = [](int idx) -> AZ::EntityId {
            return AZ::EntityId(static_cast<AZ::u64>(idx) + RigidBodyConstants::RigidBodys::RigidBodyEntityIdStart);
        };
        auto boxShapeConfiguration = AZStd::make_shared<Physics::BoxShapeConfiguration>(AZ::Vector3(RigidBodyConstants::RigidBodys::BoxSize));
        Utils::GenerateColliderFuncPtr colliderGenerator = [&boxShapeConfiguration]([[maybe_unused]] int idx)
        {
            return boxShapeConfiguration;
        };
        //spawn the rigid bodies
        Utils::BenchmarkRigidBodies benchmarkRigidBodies = Utils::CreateRigidBodies(
            numRigidBodies,
            GetDefaultSceneHandle(),
            RigidBodyConstants::CCDEnabled, bodyType, &colliderGenerator, &posGenerator, &oriGenerator, &massGenerator);

        //create the collision handlers
        AZStd::vector<Utils::SimulatedBodyCollisionHandler> collisionHandlers;
        int numberCollisionHandlers = 0;
        if (aznumeric_cast<int>(state.range(1)) == RigidBodyConstants::BenchmarkSettings::AllCollisionHanders)
        {
            numberCollisionHandlers = numRigidBodies;
        }
        else if (aznumeric_cast<int>(state.range(1)) == RigidBodyConstants::BenchmarkSettings::HalfCollisionHandlers)
        {
            numberCollisionHandlers = numRigidBodies / 2;
        }
        collisionHandlers.reserve(numberCollisionHandlers);

        for (int i = 0; i < numberCollisionHandlers; i++)
        {
            const AZ::u64 randIndex = rand.Getu64Random() % numRigidBodies; //randomly select the offset.

            if (auto handlesList = AZStd::get_if<AzPhysics::SimulatedBodyHandleList>(&benchmarkRigidBodies))
            {
                collisionHandlers.emplace_back(m_testSceneHandle, (*handlesList)[randIndex]);
            }
            else if (auto entityList = AZStd::get_if<PhysX::EntityList>(&benchmarkRigidBodies))
            {
                const EntityPtr& entity = (*entityList)[randIndex];
                auto* rigidBodyComponent = entity->FindComponent<RigidBodyComponent>();
                collisionHandlers.emplace_back(m_testSceneHandle, rigidBodyComponent->GetSimulatedBodyHandle());
            }
        }

        //setup the sub tick tracker
        Utils::PrePostSimulationEventHandler subTickTracker;
        subTickTracker.Start(m_defaultScene);

        //setup the frame timer tracker
        AZStd::vector<double> tickTimes;
        tickTimes.reserve(RigidBodyConstants::GameFramesToSimulate);
        for ([[maybe_unused]] auto _ : state)
        {
            for (AZ::u32 i = 0; i < RigidBodyConstants::GameFramesToSimulate; i++)
            {
                auto start = AZStd::chrono::steady_clock::now();
                StepScene1Tick(DefaultTimeStep);

                //time each physics tick and store it to analyze
                auto tickElapsedMilliseconds = Types::double_milliseconds(AZStd::chrono::steady_clock::now() - start);
                tickTimes.emplace_back(tickElapsedMilliseconds.count());
            }
        }
        subTickTracker.Stop();

        //object clean up
        collisionHandlers.clear();
        washingMachine.TearDownWashingMachine();

        if (auto handlesList = AZStd::get_if<AzPhysics::SimulatedBodyHandleList>(&benchmarkRigidBodies))
        {
            m_defaultScene->RemoveSimulatedBodies(*handlesList);
        }

        AZStd::visit(
            [](auto& rigidBodies)
            {
                rigidBodies.clear();
            },
            benchmarkRigidBodies);

        //sort the frame times and get the P50, P90, P99 percentiles
        Utils::ReportFramePercentileCounters(state, tickTimes, subTickTracker.GetSubTickTimes());
        Utils::ReportFrameStandardDeviationAndMeanCounters(state, tickTimes, subTickTracker.GetSubTickTimes());

        //add the collision counts
        state.counters["Collisions-Begin"] = static_cast<double>(m_collisionBeginCount);
        state.counters["Collisions-Persist"] = static_cast<double>(m_collisionPersistCount);
        state.counters["Collisions-End"] = static_cast<double>(m_collisionEndCount);

        SetLabel(state, bodyType);
    }

    BENCHMARK_REGISTER_F(PhysXRigidbodyBenchmarkFixture, BM_RigidBody_AtRest)
        ->RangeMultiplier(RigidBodyConstants::BenchmarkSettings::RangeMultipler)
        ->Ranges({ { RigidBodyConstants::BenchmarkSettings::StartRange, RigidBodyConstants::BenchmarkSettings::EndRange },
                   { RigidBodyApiObject, RigidBodyEntity } })
        ->Unit(benchmark::kMillisecond)
        ->Iterations(RigidBodyConstants::BenchmarkSettings::NumIterations)
        ->MeasureProcessCPUTime()
        ;

    BENCHMARK_REGISTER_F(PhysXRigidbodyBenchmarkFixture, BM_RigidBody_MovingAndColliding)
        ->RangeMultiplier(RigidBodyConstants::BenchmarkSettings::RangeMultipler)
        ->Ranges({ { RigidBodyConstants::BenchmarkSettings::StartRange, RigidBodyConstants::BenchmarkSettings::EndRange },
                   { RigidBodyApiObject, RigidBodyEntity } })
        ->Unit(benchmark::kMillisecond)
        ->Iterations(RigidBodyConstants::BenchmarkSettings::NumIterations)
        ->MeasureProcessCPUTime();
        ;

    BENCHMARK_REGISTER_F(PhysXRigidbodyBenchmarkFixture, BM_RigidBody_Activation)
        ->RangeMultiplier(RigidBodyConstants::ActivationBenchmarkSettings::RangeMultipler)
        ->Ranges({ { RigidBodyConstants::ActivationBenchmarkSettings::StartRange, RigidBodyConstants::ActivationBenchmarkSettings::EndRange } })
        ->Unit(benchmark::kMillisecond)
        ->Iterations(RigidBodyConstants::ActivationBenchmarkSettings::NumIterations)
        ->MeasureProcessCPUTime();
        ;

    BENCHMARK_REGISTER_F(PhysXRigidbodyCollisionsBenchmarkFixture, BM_RigidBody_MovingAndColliding_CollisionHandlers)
        ->RangeMultiplier(RigidBodyConstants::BenchmarkSettings::RangeMultipler)
        ->Ranges({  {RigidBodyConstants::BenchmarkSettings::StartRange, RigidBodyConstants::BenchmarkSettings::EndRange},
                    {RigidBodyConstants::BenchmarkSettings::AllCollisionHanders, RigidBodyConstants::BenchmarkSettings::AllCollisionHanders},
                    {RigidBodyApiObject, RigidBodyEntity} })
        ->Unit(benchmark::kMillisecond)
        ->Iterations(RigidBodyConstants::BenchmarkSettings::NumIterations)
        ;

    BENCHMARK_REGISTER_F(PhysXRigidbodyCollisionsBenchmarkFixture, BM_RigidBody_MovingAndColliding_CollisionHandlers)
        ->RangeMultiplier(RigidBodyConstants::BenchmarkSettings::RangeMultipler)
        ->Ranges({  {RigidBodyConstants::BenchmarkSettings::StartRange, RigidBodyConstants::BenchmarkSettings::EndRange},
                    {RigidBodyConstants::BenchmarkSettings::HalfCollisionHandlers, RigidBodyConstants::BenchmarkSettings::HalfCollisionHandlers},
                    {RigidBodyApiObject, RigidBodyEntity} })
        ->Unit(benchmark::kMillisecond)
        ->Iterations(RigidBodyConstants::BenchmarkSettings::NumIterations)
        ;

    BENCHMARK_REGISTER_F(PhysXRigidbodyCollisionsBenchmarkFixture, BM_RigidBody_MovingAndColliding_CollisionHandlers)
        ->RangeMultiplier(RigidBodyConstants::BenchmarkSettings::RangeMultipler)
        ->Ranges({  {RigidBodyConstants::BenchmarkSettings::StartRange, RigidBodyConstants::BenchmarkSettings::EndRange},
                    {RigidBodyConstants::BenchmarkSettings::NoCollisionHandlers, RigidBodyConstants::BenchmarkSettings::NoCollisionHandlers},
                    {RigidBodyApiObject, RigidBodyEntity} })
        ->Unit(benchmark::kMillisecond)
        ->Iterations(RigidBodyConstants::BenchmarkSettings::NumIterations)
        ;
} // namespace PhysX::Benchmarks
#endif
